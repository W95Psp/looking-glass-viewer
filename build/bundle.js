/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@yomguithereal/helpers/extend.js":
/*!*******************************************************!*\
  !*** ./node_modules/@yomguithereal/helpers/extend.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * Extend function
 * ================
 *
 * Function used to push a bunch of values into an array at once.
 *
 * Its strategy is to mutate target array's length then setting the new indices
 * to be the values to add.
 *
 * A benchmark proved that it is faster than the following strategies:
 *   1) `array.push.apply(array, values)`.
 *   2) A loop of pushes.
 *   3) `array = array.concat(values)`, obviously.
 *
 * Intuitively, this is correct because when adding a lot of elements, the
 * chosen strategies does not need to handle the `arguments` object to
 * execute #.apply's variadicity and because the array know its final length
 * at the beginning, avoiding potential multiple reallocations of the underlying
 * contiguous array. Some engines may be able to optimize the loop of push
 * operations but empirically they don't seem to do so.
 */

/**
 * Extends the target array with the given values.
 *
 * @param  {array} array  - Target array.
 * @param  {array} values - Values to add.
 */
module.exports = function extend(array, values) {
  var l2 = values.length;

  if (l2 === 0)
    return;

  var l1 = array.length;

  array.length += l2;

  for (var i = 0; i < l2; i++)
    array[l1 + i] = values[i];
};


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/defaults.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/defaults.js ***!
  \****************************************************************/
/***/ ((module) => {

/**
 * Graphology ForceAtlas2 Layout Default Settings
 * ===============================================
 */
module.exports = {
  linLogMode: false,
  outboundAttractionDistribution: false,
  adjustSizes: false,
  edgeWeightInfluence: 1,
  scalingRatio: 1,
  strongGravityMode: false,
  gravity: 1,
  slowDown: 1,
  barnesHutOptimize: false,
  barnesHutTheta: 0.5
};


/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/helpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology ForceAtlas2 Helpers
 * ===============================
 *
 * Miscellaneous helper functions.
 */

/**
 * Constants.
 */
var PPN = 10;
var PPE = 3;

/**
 * Very simple Object.assign-like function.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
exports.assign = function (target) {
  target = target || {};

  var objects = Array.prototype.slice.call(arguments).slice(1),
    i,
    k,
    l;

  for (i = 0, l = objects.length; i < l; i++) {
    if (!objects[i]) continue;

    for (k in objects[i]) target[k] = objects[i][k];
  }

  return target;
};

/**
 * Function used to validate the given settings.
 *
 * @param  {object}      settings - Settings to validate.
 * @return {object|null}
 */
exports.validateSettings = function (settings) {
  if ('linLogMode' in settings && typeof settings.linLogMode !== 'boolean')
    return {message: 'the `linLogMode` setting should be a boolean.'};

  if (
    'outboundAttractionDistribution' in settings &&
    typeof settings.outboundAttractionDistribution !== 'boolean'
  )
    return {
      message:
        'the `outboundAttractionDistribution` setting should be a boolean.'
    };

  if ('adjustSizes' in settings && typeof settings.adjustSizes !== 'boolean')
    return {message: 'the `adjustSizes` setting should be a boolean.'};

  if (
    'edgeWeightInfluence' in settings &&
    typeof settings.edgeWeightInfluence !== 'number'
  )
    return {
      message: 'the `edgeWeightInfluence` setting should be a number.'
    };

  if (
    'scalingRatio' in settings &&
    !(typeof settings.scalingRatio === 'number' && settings.scalingRatio >= 0)
  )
    return {message: 'the `scalingRatio` setting should be a number >= 0.'};

  if (
    'strongGravityMode' in settings &&
    typeof settings.strongGravityMode !== 'boolean'
  )
    return {message: 'the `strongGravityMode` setting should be a boolean.'};

  if (
    'gravity' in settings &&
    !(typeof settings.gravity === 'number' && settings.gravity >= 0)
  )
    return {message: 'the `gravity` setting should be a number >= 0.'};

  if (
    'slowDown' in settings &&
    !(typeof settings.slowDown === 'number' || settings.slowDown >= 0)
  )
    return {message: 'the `slowDown` setting should be a number >= 0.'};

  if (
    'barnesHutOptimize' in settings &&
    typeof settings.barnesHutOptimize !== 'boolean'
  )
    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};

  if (
    'barnesHutTheta' in settings &&
    !(
      typeof settings.barnesHutTheta === 'number' &&
      settings.barnesHutTheta >= 0
    )
  )
    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};

  return null;
};

/**
 * Function generating a flat matrix for both nodes & edges of the given graph.
 *
 * @param  {Graph}    graph         - Target graph.
 * @param  {function} getEdgeWeight - Edge weight getter function.
 * @return {object}                 - Both matrices.
 */
exports.graphToByteArrays = function (graph, getEdgeWeight) {
  var order = graph.order;
  var size = graph.size;
  var index = {};
  var j;

  // NOTE: float32 could lead to issues if edge array needs to index large
  // number of nodes.
  var NodeMatrix = new Float32Array(order * PPN);
  var EdgeMatrix = new Float32Array(size * PPE);

  // Iterate through nodes
  j = 0;
  graph.forEachNode(function (node, attr) {
    // Node index
    index[node] = j;

    // Populating byte array
    NodeMatrix[j] = attr.x;
    NodeMatrix[j + 1] = attr.y;
    NodeMatrix[j + 2] = 0; // dx
    NodeMatrix[j + 3] = 0; // dy
    NodeMatrix[j + 4] = 0; // old_dx
    NodeMatrix[j + 5] = 0; // old_dy
    NodeMatrix[j + 6] = 1; // mass
    NodeMatrix[j + 7] = 1; // convergence
    NodeMatrix[j + 8] = attr.size || 1;
    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;
    j += PPN;
  });

  // Iterate through edges
  j = 0;
  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {
    var sj = index[source];
    var tj = index[target];

    // Handling node mass through degree
    NodeMatrix[sj + 6] += 1;
    NodeMatrix[tj + 6] += 1;

    // Populating byte array
    EdgeMatrix[j] = sj;
    EdgeMatrix[j + 1] = tj;
    EdgeMatrix[j + 2] = getEdgeWeight(edge, attr, source, target, sa, ta, u);
    j += PPE;
  });

  return {
    nodes: NodeMatrix,
    edges: EdgeMatrix
  };
};

/**
 * Function applying the layout back to the graph.
 *
 * @param {Graph}         graph         - Target graph.
 * @param {Float32Array}  NodeMatrix    - Node matrix.
 * @param {function|null} outputReducer - A node reducer.
 */
exports.assignLayoutChanges = function (graph, NodeMatrix, outputReducer) {
  var i = 0;

  graph.updateEachNodeAttributes(function (node, attr) {
    attr.x = NodeMatrix[i];
    attr.y = NodeMatrix[i + 1];

    i += PPN;

    return outputReducer ? outputReducer(node, attr) : attr;
  });
};

/**
 * Function reading the positions (only) from the graph, to write them in the matrix.
 *
 * @param {Graph}        graph      - Target graph.
 * @param {Float32Array} NodeMatrix - Node matrix.
 */
exports.readGraphPositions = function (graph, NodeMatrix) {
  var i = 0;

  graph.forEachNode(function (node, attr) {
    NodeMatrix[i] = attr.x;
    NodeMatrix[i + 1] = attr.y;

    i += PPN;
  });
};

/**
 * Function collecting the layout positions.
 *
 * @param  {Graph}         graph         - Target graph.
 * @param  {Float32Array}  NodeMatrix    - Node matrix.
 * @param  {function|null} outputReducer - A nodes reducer.
 * @return {object}                      - Map to node positions.
 */
exports.collectLayoutChanges = function (graph, NodeMatrix, outputReducer) {
  var nodes = graph.nodes(),
    positions = {};

  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {
    if (outputReducer) {
      var newAttr = Object.assign({}, graph.getNodeAttributes(nodes[j]));
      newAttr.x = NodeMatrix[i];
      newAttr.y = NodeMatrix[i + 1];
      newAttr = outputReducer(nodes[j], newAttr);
      positions[nodes[j]] = {
        x: newAttr.x,
        y: newAttr.y
      };
    } else {
      positions[nodes[j]] = {
        x: NodeMatrix[i],
        y: NodeMatrix[i + 1]
      };
    }

    j++;
  }

  return positions;
};

/**
 * Function returning a web worker from the given function.
 *
 * @param  {function}  fn - Function for the worker.
 * @return {DOMString}
 */
exports.createWorker = function createWorker(fn) {
  var xURL = window.URL || window.webkitURL;
  var code = fn.toString();
  var objectUrl = xURL.createObjectURL(
    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})
  );
  var worker = new Worker(objectUrl);
  xURL.revokeObjectURL(objectUrl);

  return worker;
};


/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology ForceAtlas2 Layout
 * ==============================
 *
 * Library endpoint.
 */
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
var createEdgeWeightGetter =
  (__webpack_require__(/*! graphology-utils/getters */ "./node_modules/graphology-utils/getters.js").createEdgeWeightGetter);
var iterate = __webpack_require__(/*! ./iterate.js */ "./node_modules/graphology-layout-forceatlas2/iterate.js");
var helpers = __webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-layout-forceatlas2/helpers.js");

var DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-layout-forceatlas2/defaults.js");

/**
 * Asbtract function used to run a certain number of iterations.
 *
 * @param  {boolean}       assign          - Whether to assign positions.
 * @param  {Graph}         graph           - Target graph.
 * @param  {object|number} params          - If number, params.iterations, else:
 * @param  {function}        getWeight     - Edge weight getter function.
 * @param  {number}          iterations    - Number of iterations.
 * @param  {function|null}   outputReducer - A node reducer
 * @param  {object}          [settings]    - Settings.
 * @return {object|undefined}
 */
function abstractSynchronousLayout(assign, graph, params) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout-forceatlas2: the given graph is not a valid graphology instance.'
    );

  if (typeof params === 'number') params = {iterations: params};

  var iterations = params.iterations;

  if (typeof iterations !== 'number')
    throw new Error(
      'graphology-layout-forceatlas2: invalid number of iterations.'
    );

  if (iterations <= 0)
    throw new Error(
      'graphology-layout-forceatlas2: you should provide a positive number of iterations.'
    );

  var getEdgeWeight = createEdgeWeightGetter(params.getEdgeWeight).fromEntry;

  var outputReducer =
    typeof params.outputReducer === 'function' ? params.outputReducer : null;

  // Validating settings
  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);
  var validationError = helpers.validateSettings(settings);

  if (validationError)
    throw new Error(
      'graphology-layout-forceatlas2: ' + validationError.message
    );

  // Building matrices
  var matrices = helpers.graphToByteArrays(graph, getEdgeWeight);

  var i;

  // Iterating
  for (i = 0; i < iterations; i++)
    iterate(settings, matrices.nodes, matrices.edges);

  // Applying
  if (assign) {
    helpers.assignLayoutChanges(graph, matrices.nodes, outputReducer);
    return;
  }

  return helpers.collectLayoutChanges(graph, matrices.nodes);
}

/**
 * Function returning sane layout settings for the given graph.
 *
 * @param  {Graph|number} graph - Target graph or graph order.
 * @return {object}
 */
function inferSettings(graph) {
  var order = typeof graph === 'number' ? graph : graph.order;

  return {
    barnesHutOptimize: order > 2000,
    strongGravityMode: true,
    gravity: 0.05,
    scalingRatio: 10,
    slowDown: 1 + Math.log(order)
  };
}

/**
 * Exporting.
 */
var synchronousLayout = abstractSynchronousLayout.bind(null, false);
synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
synchronousLayout.inferSettings = inferSettings;

module.exports = synchronousLayout;


/***/ }),

/***/ "./node_modules/graphology-layout-forceatlas2/iterate.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/iterate.js ***!
  \***************************************************************/
/***/ ((module) => {

/* eslint no-constant-condition: 0 */
/**
 * Graphology ForceAtlas2 Iteration
 * =================================
 *
 * Function used to perform a single iteration of the algorithm.
 */

/**
 * Matrices properties accessors.
 */
var NODE_X = 0;
var NODE_Y = 1;
var NODE_DX = 2;
var NODE_DY = 3;
var NODE_OLD_DX = 4;
var NODE_OLD_DY = 5;
var NODE_MASS = 6;
var NODE_CONVERGENCE = 7;
var NODE_SIZE = 8;
var NODE_FIXED = 9;

var EDGE_SOURCE = 0;
var EDGE_TARGET = 1;
var EDGE_WEIGHT = 2;

var REGION_NODE = 0;
var REGION_CENTER_X = 1;
var REGION_CENTER_Y = 2;
var REGION_SIZE = 3;
var REGION_NEXT_SIBLING = 4;
var REGION_FIRST_CHILD = 5;
var REGION_MASS = 6;
var REGION_MASS_CENTER_X = 7;
var REGION_MASS_CENTER_Y = 8;

var SUBDIVISION_ATTEMPTS = 3;

/**
 * Constants.
 */
var PPN = 10;
var PPE = 3;
var PPR = 9;

var MAX_FORCE = 10;

/**
 * Function used to perform a single interation of the algorithm.
 *
 * @param  {object}       options    - Layout options.
 * @param  {Float32Array} NodeMatrix - Node data.
 * @param  {Float32Array} EdgeMatrix - Edge data.
 * @return {object}                  - Some metadata.
 */
module.exports = function iterate(options, NodeMatrix, EdgeMatrix) {
  // Initializing variables
  var l, r, n, n1, n2, rn, e, w, g, s;

  var order = NodeMatrix.length,
    size = EdgeMatrix.length;

  var adjustSizes = options.adjustSizes;

  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;

  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;

  var RegionMatrix = [];

  // 1) Initializing layout data
  //-----------------------------

  // Resetting positions & computing max values
  for (n = 0; n < order; n += PPN) {
    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];
    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];
    NodeMatrix[n + NODE_DX] = 0;
    NodeMatrix[n + NODE_DY] = 0;
  }

  // If outbound attraction distribution, compensate
  if (options.outboundAttractionDistribution) {
    outboundAttCompensation = 0;
    for (n = 0; n < order; n += PPN) {
      outboundAttCompensation += NodeMatrix[n + NODE_MASS];
    }

    outboundAttCompensation /= order / PPN;
  }

  // 1.bis) Barnes-Hut computation
  //------------------------------

  if (options.barnesHutOptimize) {
    // Setting up
    var minX = Infinity,
      maxX = -Infinity,
      minY = Infinity,
      maxY = -Infinity,
      q,
      q2,
      subdivisionAttempts;

    // Computing min and max values
    for (n = 0; n < order; n += PPN) {
      minX = Math.min(minX, NodeMatrix[n + NODE_X]);
      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);
      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);
      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);
    }

    // squarify bounds, it's a quadtree
    var dx = maxX - minX,
      dy = maxY - minY;
    if (dx > dy) {
      minY -= (dx - dy) / 2;
      maxY = minY + dx;
    } else {
      minX -= (dy - dx) / 2;
      maxX = minX + dy;
    }

    // Build the Barnes Hut root region
    RegionMatrix[0 + REGION_NODE] = -1;
    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;
    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;
    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);
    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;
    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;
    RegionMatrix[0 + REGION_MASS] = 0;
    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;
    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;

    // Add each node in the tree
    l = 1;
    for (n = 0; n < order; n += PPN) {
      // Current region, starting with root
      r = 0;
      subdivisionAttempts = SUBDIVISION_ATTEMPTS;

      while (true) {
        // Are there sub-regions?

        // We look at first child index
        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
          // There are sub-regions

          // We just iterate to find a "leaf" of the tree
          // that is an empty region or a region with a single node
          // (see next case)

          // Find the quadrant of n
          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
              // Top Left quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD];
            } else {
              // Bottom Left quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
            }
          } else {
            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
              // Top Right quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
            } else {
              // Bottom Right quarter
              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
            }
          }

          // Update center of mass and mass (we only do it for non-leave regions)
          RegionMatrix[r + REGION_MASS_CENTER_X] =
            (RegionMatrix[r + REGION_MASS_CENTER_X] *
              RegionMatrix[r + REGION_MASS] +
              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /
            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

          RegionMatrix[r + REGION_MASS_CENTER_Y] =
            (RegionMatrix[r + REGION_MASS_CENTER_Y] *
              RegionMatrix[r + REGION_MASS] +
              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /
            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);

          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];

          // Iterate on the right quadrant
          r = q;
          continue;
        } else {
          // There are no sub-regions: we are in a "leaf"

          // Is there a node in this leave?
          if (RegionMatrix[r + REGION_NODE] < 0) {
            // There is no node in region:
            // we record node n and go on
            RegionMatrix[r + REGION_NODE] = n;
            break;
          } else {
            // There is a node in this region

            // We will need to create sub-regions, stick the two
            // nodes (the old one r[0] and the new one n) in two
            // subregions. If they fall in the same quadrant,
            // we will iterate.

            // Create sub-regions
            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;
            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)

            // NOTE: we use screen coordinates
            // from Top Left to Bottom Right

            // Top Left sub-region
            g = RegionMatrix[r + REGION_FIRST_CHILD];

            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] - w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] - w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Bottom Left sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] - w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] + w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Top Right sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] + w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] - w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            // Bottom Right sub-region
            g += PPR;
            RegionMatrix[g + REGION_NODE] = -1;
            RegionMatrix[g + REGION_CENTER_X] =
              RegionMatrix[r + REGION_CENTER_X] + w;
            RegionMatrix[g + REGION_CENTER_Y] =
              RegionMatrix[r + REGION_CENTER_Y] + w;
            RegionMatrix[g + REGION_SIZE] = w;
            RegionMatrix[g + REGION_NEXT_SIBLING] =
              RegionMatrix[r + REGION_NEXT_SIBLING];
            RegionMatrix[g + REGION_FIRST_CHILD] = -1;
            RegionMatrix[g + REGION_MASS] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;

            l += 4;

            // Now the goal is to find two different sub-regions
            // for the two nodes: the one previously recorded (r[0])
            // and the one we want to add (n)

            // Find the quadrant of the old node
            if (
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <
              RegionMatrix[r + REGION_CENTER_X]
            ) {
              if (
                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <
                RegionMatrix[r + REGION_CENTER_Y]
              ) {
                // Top Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD];
              } else {
                // Bottom Left quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
              }
            } else {
              if (
                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <
                RegionMatrix[r + REGION_CENTER_Y]
              ) {
                // Top Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
              } else {
                // Bottom Right quarter
                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
              }
            }

            // We remove r[0] from the region r, add its mass to r and record it in q
            RegionMatrix[r + REGION_MASS] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];
            RegionMatrix[r + REGION_MASS_CENTER_X] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];
            RegionMatrix[r + REGION_MASS_CENTER_Y] =
              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];

            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];
            RegionMatrix[r + REGION_NODE] = -1;

            // Find the quadrant of n
            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                // Top Left quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD];
              } else {
                // Bottom Left quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
              }
            } else {
              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                // Top Right quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
              } else {
                // Bottom Right quarter
                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
              }
            }

            if (q === q2) {
              // If both nodes are in the same quadrant,
              // we have to try it again on this quadrant
              if (subdivisionAttempts--) {
                r = q;
                continue; // while
              } else {
                // we are out of precision here, and we cannot subdivide anymore
                // but we have to break the loop anyway
                subdivisionAttempts = SUBDIVISION_ATTEMPTS;
                break; // while
              }
            }

            // If both quadrants are different, we record n
            // in its quadrant
            RegionMatrix[q2 + REGION_NODE] = n;
            break;
          }
        }
      }
    }
  }

  // 2) Repulsion
  //--------------
  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient

  if (options.barnesHutOptimize) {
    coefficient = options.scalingRatio;

    // Applying repulsion through regions
    for (n = 0; n < order; n += PPN) {
      // Computing leaf quad nodes iteration

      r = 0; // Starting with root region
      while (true) {
        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
          // The region has sub-regions

          // We run the Barnes Hut test to see if we are at the right distance
          distance =
            Math.pow(
              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],
              2
            ) +
            Math.pow(
              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],
              2
            );

          s = RegionMatrix[r + REGION_SIZE];

          if ((4 * s * s) / distance < thetaSquared) {
            // We treat the region as a single body, and we repulse

            xDist =
              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];
            yDist =
              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];

            if (adjustSizes === true) {
              //-- Linear Anti-collision Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              } else if (distance < 0) {
                factor =
                  (-coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  Math.sqrt(distance);

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            } else {
              //-- Linear Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    RegionMatrix[r + REGION_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            }

            // When this is done, we iterate. We have to look at the next sibling.
            r = RegionMatrix[r + REGION_NEXT_SIBLING];
            if (r < 0) break; // No next sibling: we have finished the tree

            continue;
          } else {
            // The region is too close and we have to look at sub-regions
            r = RegionMatrix[r + REGION_FIRST_CHILD];
            continue;
          }
        } else {
          // The region has no sub-region
          // If there is a node r[0] and it is not n, then repulse
          rn = RegionMatrix[r + REGION_NODE];

          if (rn >= 0 && rn !== n) {
            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];
            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];

            distance = xDist * xDist + yDist * yDist;

            if (adjustSizes === true) {
              //-- Linear Anti-collision Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              } else if (distance < 0) {
                factor =
                  (-coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  Math.sqrt(distance);

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            } else {
              //-- Linear Repulsion
              if (distance > 0) {
                factor =
                  (coefficient *
                    NodeMatrix[n + NODE_MASS] *
                    NodeMatrix[rn + NODE_MASS]) /
                  distance;

                NodeMatrix[n + NODE_DX] += xDist * factor;
                NodeMatrix[n + NODE_DY] += yDist * factor;
              }
            }
          }

          // When this is done, we iterate. We have to look at the next sibling.
          r = RegionMatrix[r + REGION_NEXT_SIBLING];

          if (r < 0) break; // No next sibling: we have finished the tree

          continue;
        }
      }
    }
  } else {
    coefficient = options.scalingRatio;

    // Square iteration
    for (n1 = 0; n1 < order; n1 += PPN) {
      for (n2 = 0; n2 < n1; n2 += PPN) {
        // Common to both methods
        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

        if (adjustSizes === true) {
          //-- Anticollision Linear Repulsion
          distance =
            Math.sqrt(xDist * xDist + yDist * yDist) -
            NodeMatrix[n1 + NODE_SIZE] -
            NodeMatrix[n2 + NODE_SIZE];

          if (distance > 0) {
            factor =
              (coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS]) /
              distance /
              distance;

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] += xDist * factor;
            NodeMatrix[n2 + NODE_DY] += yDist * factor;
          } else if (distance < 0) {
            factor =
              100 *
              coefficient *
              NodeMatrix[n1 + NODE_MASS] *
              NodeMatrix[n2 + NODE_MASS];

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] -= xDist * factor;
            NodeMatrix[n2 + NODE_DY] -= yDist * factor;
          }
        } else {
          //-- Linear Repulsion
          distance = Math.sqrt(xDist * xDist + yDist * yDist);

          if (distance > 0) {
            factor =
              (coefficient *
                NodeMatrix[n1 + NODE_MASS] *
                NodeMatrix[n2 + NODE_MASS]) /
              distance /
              distance;

            // Updating nodes' dx and dy
            NodeMatrix[n1 + NODE_DX] += xDist * factor;
            NodeMatrix[n1 + NODE_DY] += yDist * factor;

            NodeMatrix[n2 + NODE_DX] -= xDist * factor;
            NodeMatrix[n2 + NODE_DY] -= yDist * factor;
          }
        }
      }
    }
  }

  // 3) Gravity
  //------------
  g = options.gravity / options.scalingRatio;
  coefficient = options.scalingRatio;
  for (n = 0; n < order; n += PPN) {
    factor = 0;

    // Common to both methods
    xDist = NodeMatrix[n + NODE_X];
    yDist = NodeMatrix[n + NODE_Y];
    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));

    if (options.strongGravityMode) {
      //-- Strong gravity
      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;
    } else {
      //-- Linear Anti-collision Repulsion n
      if (distance > 0)
        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;
    }

    // Updating node's dx and dy
    NodeMatrix[n + NODE_DX] -= xDist * factor;
    NodeMatrix[n + NODE_DY] -= yDist * factor;
  }

  // 4) Attraction
  //---------------
  coefficient =
    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);

  // TODO: simplify distance
  // TODO: coefficient is always used as -c --> optimize?
  for (e = 0; e < size; e += PPE) {
    n1 = EdgeMatrix[e + EDGE_SOURCE];
    n2 = EdgeMatrix[e + EDGE_TARGET];
    w = EdgeMatrix[e + EDGE_WEIGHT];

    // Edge weight influence
    ewc = Math.pow(w, options.edgeWeightInfluence);

    // Common measures
    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];

    // Applying attraction to nodes
    if (adjustSizes === true) {
      distance =
        Math.sqrt(xDist * xDist + yDist * yDist) -
        NodeMatrix[n1 + NODE_SIZE] -
        NodeMatrix[n2 + NODE_SIZE];

      if (options.linLogMode) {
        if (options.outboundAttractionDistribution) {
          //-- LinLog Degree Distributed Anti-collision Attraction
          if (distance > 0) {
            factor =
              (-coefficient * ewc * Math.log(1 + distance)) /
              distance /
              NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- LinLog Anti-collision Attraction
          if (distance > 0) {
            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;
          }
        }
      } else {
        if (options.outboundAttractionDistribution) {
          //-- Linear Degree Distributed Anti-collision Attraction
          if (distance > 0) {
            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- Linear Anti-collision Attraction
          if (distance > 0) {
            factor = -coefficient * ewc;
          }
        }
      }
    } else {
      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));

      if (options.linLogMode) {
        if (options.outboundAttractionDistribution) {
          //-- LinLog Degree Distributed Attraction
          if (distance > 0) {
            factor =
              (-coefficient * ewc * Math.log(1 + distance)) /
              distance /
              NodeMatrix[n1 + NODE_MASS];
          }
        } else {
          //-- LinLog Attraction
          if (distance > 0)
            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;
        }
      } else {
        if (options.outboundAttractionDistribution) {
          //-- Linear Attraction Mass Distributed
          // NOTE: Distance is set to 1 to override next condition
          distance = 1;
          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];
        } else {
          //-- Linear Attraction
          // NOTE: Distance is set to 1 to override next condition
          distance = 1;
          factor = -coefficient * ewc;
        }
      }
    }

    // Updating nodes' dx and dy
    // TODO: if condition or factor = 1?
    if (distance > 0) {
      // Updating nodes' dx and dy
      NodeMatrix[n1 + NODE_DX] += xDist * factor;
      NodeMatrix[n1 + NODE_DY] += yDist * factor;

      NodeMatrix[n2 + NODE_DX] -= xDist * factor;
      NodeMatrix[n2 + NODE_DY] -= yDist * factor;
    }
  }

  // 5) Apply Forces
  //-----------------
  var force, swinging, traction, nodespeed, newX, newY;

  // MATH: sqrt and square distances
  if (adjustSizes === true) {
    for (n = 0; n < order; n += PPN) {
      if (NodeMatrix[n + NODE_FIXED] !== 1) {
        force = Math.sqrt(
          Math.pow(NodeMatrix[n + NODE_DX], 2) +
            Math.pow(NodeMatrix[n + NODE_DY], 2)
        );

        if (force > MAX_FORCE) {
          NodeMatrix[n + NODE_DX] =
            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;
          NodeMatrix[n + NODE_DY] =
            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;
        }

        swinging =
          NodeMatrix[n + NODE_MASS] *
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
          );

        traction =
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));

        // Updating node's positon
        newX =
          NodeMatrix[n + NODE_X] +
          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_X] = newX;

        newY =
          NodeMatrix[n + NODE_Y] +
          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_Y] = newY;
      }
    }
  } else {
    for (n = 0; n < order; n += PPN) {
      if (NodeMatrix[n + NODE_FIXED] !== 1) {
        swinging =
          NodeMatrix[n + NODE_MASS] *
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
          );

        traction =
          Math.sqrt(
            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *
              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +
              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *
                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
          ) / 2;

        nodespeed =
          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /
          (1 + Math.sqrt(swinging));

        // Updating node convergence
        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(
          1,
          Math.sqrt(
            (nodespeed *
              (Math.pow(NodeMatrix[n + NODE_DX], 2) +
                Math.pow(NodeMatrix[n + NODE_DY], 2))) /
              (1 + Math.sqrt(swinging))
          )
        );

        // Updating node's positon
        newX =
          NodeMatrix[n + NODE_X] +
          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_X] = newX;

        newY =
          NodeMatrix[n + NODE_Y] +
          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
        NodeMatrix[n + NODE_Y] = newY;
      }
    }
  }

  // We return the information about the layout (no need to return the matrices)
  return {};
};


/***/ }),

/***/ "./node_modules/graphology-layout/circlepack.js":
/*!******************************************************!*\
  !*** ./node_modules/graphology-layout/circlepack.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology CirclePack Layout
 * =============================
 *
 * Circlepack layout from d3-hierarchy/gephi.
 */
var resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ "./node_modules/graphology-utils/defaults.js");
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
var shuffle = __webpack_require__(/*! pandemonium/shuffle-in-place */ "./node_modules/pandemonium/shuffle-in-place.js");

/**
 * Default options.
 */
var DEFAULTS = {
  attributes: {
    x: 'x',
    y: 'y'
  },
  center: 0,
  hierarchyAttributes: [],
  rng: Math.random,
  scale: 1
};

/**
 * Helpers.
 */
function CircleWrap(id, x, y, r, circleWrap) {
  this.wrappedCircle = circleWrap || null; //hacky d3 reference thing

  this.children = {};
  this.countChildren = 0;
  this.id = id || null;
  this.next = null;
  this.previous = null;

  this.x = x || null;
  this.y = y || null;
  if (circleWrap) this.r = 1010101;
  // for debugging purposes - should not be used in this case
  else this.r = r || 999;
}

CircleWrap.prototype.hasChildren = function () {
  return this.countChildren > 0;
};

CircleWrap.prototype.addChild = function (id, child) {
  this.children[id] = child;
  ++this.countChildren;
};

CircleWrap.prototype.getChild = function (id) {
  if (!this.children.hasOwnProperty(id)) {
    var circleWrap = new CircleWrap();
    this.children[id] = circleWrap;
    ++this.countChildren;
  }
  return this.children[id];
};

CircleWrap.prototype.applyPositionToChildren = function () {
  if (this.hasChildren()) {
    var root = this; // using 'this' in Object.keys.forEach seems a bad idea
    for (var key in root.children) {
      var child = root.children[key];
      child.x += root.x;
      child.y += root.y;
      child.applyPositionToChildren();
    }
  }
};

function setNode(/*Graph*/ graph, /*CircleWrap*/ parentCircle, /*Map*/ posMap) {
  for (var key in parentCircle.children) {
    var circle = parentCircle.children[key];
    if (circle.hasChildren()) {
      setNode(graph, circle, posMap);
    } else {
      posMap[circle.id] = {x: circle.x, y: circle.y};
    }
  }
}

function enclosesNot(/*CircleWrap*/ a, /*CircleWrap*/ b) {
  var dr = a.r - b.r;
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(/*CircleWrap*/ a, /*CircleWrap*/ b) {
  var dr = a.r - b.r + 1e-6;
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(/*CircleWrap*/ a, /*Array<CircleWrap>*/ B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis1(/*CircleWrap*/ a) {
  return new CircleWrap(null, a.x, a.y, a.r);
}

function encloseBasis2(/*CircleWrap*/ a, /*CircleWrap*/ b) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x21 = x2 - x1,
    y21 = y2 - y1,
    r21 = r2 - r1,
    l = Math.sqrt(x21 * x21 + y21 * y21);
  return new CircleWrap(
    null,
    (x1 + x2 + (x21 / l) * r21) / 2,
    (y1 + y2 + (y21 / l) * r21) / 2,
    (l + r1 + r2) / 2
  );
}

function encloseBasis3(/*CircleWrap*/ a, /*CircleWrap*/ b, /*CircleWrap*/ c) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x3 = c.x,
    y3 = c.y,
    r3 = c.r,
    a2 = x1 - x2,
    a3 = x1 - x3,
    b2 = y1 - y2,
    b3 = y1 - y3,
    c2 = r2 - r1,
    c3 = r3 - r1,
    d1 = x1 * x1 + y1 * y1 - r1 * r1,
    d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
    d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
    ab = a3 * b2 - a2 * b3,
    xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
    xb = (b3 * c2 - b2 * c3) / ab,
    ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
    yb = (a2 * c3 - a3 * c2) / ab,
    A = xb * xb + yb * yb - 1,
    B = 2 * (r1 + xa * xb + ya * yb),
    C = xa * xa + ya * ya - r1 * r1,
    r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return new CircleWrap(null, x1 + xa + xb * r, y1 + ya + yb * r, r);
}

function encloseBasis(/*Array<CircleWrap>*/ B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
    default:
      throw new Error(
        'graphology-layout/circlepack: Invalid basis length ' + B.length
      );
  }
}

function extendBasis(/*Array<CircleWrap>*/ B, /*CircleWrap*/ p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (
        enclosesNot(encloseBasis2(B[i], B[j]), p) &&
        enclosesNot(encloseBasis2(B[i], p), B[j]) &&
        enclosesNot(encloseBasis2(B[j], p), B[i]) &&
        enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)
      ) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error('graphology-layout/circlepack: extendBasis failure !');
}

function score(/*CircleWrap*/ node) {
  var a = node.wrappedCircle;
  var b = node.next.wrappedCircle;
  var ab = a.r + b.r;
  var dx = (a.x * b.r + b.x * a.r) / ab;
  var dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function enclose(circles, shuffleFunc) {
  var i = 0;
  var circlesLoc = circles.slice();

  var n = circles.length;
  var B = [];
  var p;
  var e;
  shuffleFunc(circlesLoc);
  while (i < n) {
    p = circlesLoc[i];
    if (e && enclosesWeak(e, p)) {
      ++i;
    } else {
      B = extendBasis(B, p);
      e = encloseBasis(B);
      i = 0;
    }
  }
  return e;
}

function place(/*CircleWrap*/ b, /*CircleWrap*/ a, /*CircleWrap*/ c) {
  var dx = b.x - a.x,
    x,
    a2,
    dy = b.y - a.y,
    y,
    b2,
    d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r;
    a2 *= a2;
    b2 = b.r + c.r;
    b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(/*CircleWrap*/ a, /*CircleWrap*/ b) {
  var dr = a.r + b.r - 1e-6,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function packEnclose(/*Array<CircleWrap>*/ circles, shuffleFunc) {
  var n = circles.length;
  if (n === 0) return 0;

  var a, b, c, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0];
  a.x = 0;
  a.y = 0;
  if (n <= 1) return a.r;

  // Place the second circle.
  b = circles[1];
  a.x = -b.r;
  b.x = a.r;
  b.y = 0;
  if (n <= 2) return a.r + b.r;

  // Place the third circle.
  c = circles[2];
  place(b, a, c);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new CircleWrap(null, null, null, null, a);
  b = new CircleWrap(null, null, null, null, b);
  c = new CircleWrap(null, null, null, null, c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    c = circles[i];
    place(a.wrappedCircle, b.wrappedCircle, c);
    c = new CircleWrap(null, null, null, null, c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next;
    k = a.previous;
    sj = b.wrappedCircle.r;
    sk = a.wrappedCircle.r;
    do {
      if (sj <= sk) {
        if (intersects(j.wrappedCircle, c.wrappedCircle)) {
          b = j;
          a.next = b;
          b.previous = a;
          --i;
          continue pack;
        }
        sj += j.wrappedCircle.r;
        j = j.next;
      } else {
        if (intersects(k.wrappedCircle, c.wrappedCircle)) {
          a = k;
          a.next = b;
          b.previous = a;
          --i;
          continue pack;
        }
        sk += k.wrappedCircle.r;
        k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a;
    c.next = b;
    a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c;
        aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b.wrappedCircle];
  c = b;
  var safety = 10000;
  while ((c = c.next) !== b) {
    if (--safety === 0) {
      break;
    }
    a.push(c.wrappedCircle);
  }
  c = enclose(a, shuffleFunc);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) {
    a = circles[i];
    a.x -= c.x;
    a.y -= c.y;
  }
  return c.r;
}

function packHierarchy(/*CircleWrap*/ parentCircle, shuffleFunc) {
  var r = 0;
  if (parentCircle.hasChildren()) {
    //pack the children first because the radius is determined by how the children get packed (recursive)
    for (var key in parentCircle.children) {
      var circle = parentCircle.children[key];
      if (circle.hasChildren()) {
        circle.r = packHierarchy(circle, shuffleFunc);
      }
    }
    //now that each circle has a radius set by its children, pack the circles at this level
    r = packEnclose(Object.values(parentCircle.children), shuffleFunc);
  }
  return r;
}

function packHierarchyAndShift(/*CircleWrap*/ parentCircle, shuffleFunc) {
  packHierarchy(parentCircle, shuffleFunc);
  for (var key in parentCircle.children) {
    var circle = parentCircle.children[key];
    circle.applyPositionToChildren();
  }
}

/**
 * Abstract function running the layout.
 *
 * @param  {Graph}    graph                   - Target  graph.
 * @param  {object}   [options]               - Options:
 * @param  {object}     [attributes]          - Attributes names to map.
 * @param  {number}     [center]              - Center of the layout.
 * @param  {string[]}   [hierarchyAttributes] - List of attributes used for the layout in decreasing order.
 * @param  {function}   [rng]                 - Custom RNG function to be used.
 * @param  {number}     [scale]               - Scale of the layout.
 * @return {object}                           - The positions by node.
 */
function genericCirclePackLayout(assign, graph, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/circlepack: the given graph is not a valid graphology instance.'
    );

  options = resolveDefaults(options, DEFAULTS);

  var posMap = {},
    positions = {},
    nodes = graph.nodes(),
    center = options.center,
    hierarchyAttributes = options.hierarchyAttributes,
    shuffleFunc = shuffle.createShuffleInPlace(options.rng),
    scale = options.scale;

  var container = new CircleWrap();

  graph.forEachNode(function (key, attributes) {
    var r = attributes.size ? attributes.size : 1;
    var newCircleWrap = new CircleWrap(key, null, null, r);
    var parentContainer = container;

    hierarchyAttributes.forEach(function (v) {
      var attr = attributes[v];
      parentContainer = parentContainer.getChild(attr);
    });

    parentContainer.addChild(key, newCircleWrap);
  });
  packHierarchyAndShift(container, shuffleFunc);
  setNode(graph, container, posMap);
  var l = nodes.length,
    x,
    y,
    i;
  for (i = 0; i < l; i++) {
    var node = nodes[i];

    x = center + scale * posMap[node].x;
    y = center + scale * posMap[node].y;

    positions[node] = {
      x: x,
      y: y
    };

    if (assign) {
      graph.setNodeAttribute(node, options.attributes.x, x);
      graph.setNodeAttribute(node, options.attributes.y, y);
    }
  }
  return positions;
}

var circlePackLayout = genericCirclePackLayout.bind(null, false);
circlePackLayout.assign = genericCirclePackLayout.bind(null, true);

module.exports = circlePackLayout;


/***/ }),

/***/ "./node_modules/graphology-layout/circular.js":
/*!****************************************************!*\
  !*** ./node_modules/graphology-layout/circular.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Circular Layout
 * ===========================
 *
 * Layout arranging the nodes in a circle.
 */
var resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ "./node_modules/graphology-utils/defaults.js");
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

/**
 * Default options.
 */
var DEFAULTS = {
  dimensions: ['x', 'y'],
  center: 0.5,
  scale: 1
};

/**
 * Abstract function running the layout.
 *
 * @param  {Graph}    graph          - Target  graph.
 * @param  {object}   [options]      - Options:
 * @param  {object}     [attributes] - Attributes names to map.
 * @param  {number}     [center]     - Center of the layout.
 * @param  {number}     [scale]      - Scale of the layout.
 * @return {object}                  - The positions by node.
 */
function genericCircularLayout(assign, graph, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/random: the given graph is not a valid graphology instance.'
    );

  options = resolveDefaults(options, DEFAULTS);

  var dimensions = options.dimensions;

  if (!Array.isArray(dimensions) || dimensions.length !== 2)
    throw new Error('graphology-layout/random: given dimensions are invalid.');

  var center = options.center;
  var scale = options.scale;
  var tau = Math.PI * 2;

  var offset = (center - 0.5) * scale;
  var l = graph.order;

  var x = dimensions[0];
  var y = dimensions[1];

  function assignPosition(i, target) {
    target[x] = scale * Math.cos((i * tau) / l) + offset;
    target[y] = scale * Math.sin((i * tau) / l) + offset;

    return target;
  }

  var i = 0;

  if (!assign) {
    var positions = {};

    graph.forEachNode(function (node) {
      positions[node] = assignPosition(i++, {});
    });

    return positions;
  }

  graph.updateEachNodeAttributes(
    function (_, attr) {
      assignPosition(i++, attr);
      return attr;
    },
    {
      attributes: dimensions
    }
  );
}

var circularLayout = genericCircularLayout.bind(null, false);
circularLayout.assign = genericCircularLayout.bind(null, true);

module.exports = circularLayout;


/***/ }),

/***/ "./node_modules/graphology-layout/index.js":
/*!*************************************************!*\
  !*** ./node_modules/graphology-layout/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Graphology Layout
 * ==================
 *
 * Library endpoint.
 */
exports.circlepack = __webpack_require__(/*! ./circlepack.js */ "./node_modules/graphology-layout/circlepack.js");
exports.circular = __webpack_require__(/*! ./circular.js */ "./node_modules/graphology-layout/circular.js");
exports.random = __webpack_require__(/*! ./random.js */ "./node_modules/graphology-layout/random.js");
exports.rotation = __webpack_require__(/*! ./rotation.js */ "./node_modules/graphology-layout/rotation.js");


/***/ }),

/***/ "./node_modules/graphology-layout/random.js":
/*!**************************************************!*\
  !*** ./node_modules/graphology-layout/random.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Random Layout
 * =========================
 *
 * Simple layout giving uniform random positions to the nodes.
 */
var resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ "./node_modules/graphology-utils/defaults.js");
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

/**
 * Default options.
 */
var DEFAULTS = {
  dimensions: ['x', 'y'],
  center: 0.5,
  rng: Math.random,
  scale: 1
};

/**
 * Abstract function running the layout.
 *
 * @param  {Graph}    graph          - Target  graph.
 * @param  {object}   [options]      - Options:
 * @param  {array}      [dimensions] - List of dimensions of the layout.
 * @param  {number}     [center]     - Center of the layout.
 * @param  {function}   [rng]        - Custom RNG function to be used.
 * @param  {number}     [scale]      - Scale of the layout.
 * @return {object}                  - The positions by node.
 */
function genericRandomLayout(assign, graph, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/random: the given graph is not a valid graphology instance.'
    );

  options = resolveDefaults(options, DEFAULTS);

  var dimensions = options.dimensions;

  if (!Array.isArray(dimensions) || dimensions.length < 1)
    throw new Error('graphology-layout/random: given dimensions are invalid.');

  var d = dimensions.length;
  var center = options.center;
  var rng = options.rng;
  var scale = options.scale;

  var offset = (center - 0.5) * scale;

  function assignPosition(target) {
    for (var i = 0; i < d; i++) {
      target[dimensions[i]] = rng() * scale + offset;
    }

    return target;
  }

  if (!assign) {
    var positions = {};

    graph.forEachNode(function (node) {
      positions[node] = assignPosition({});
    });

    return positions;
  }

  graph.updateEachNodeAttributes(
    function (_, attr) {
      assignPosition(attr);
      return attr;
    },
    {
      attributes: dimensions
    }
  );
}

var randomLayout = genericRandomLayout.bind(null, false);
randomLayout.assign = genericRandomLayout.bind(null, true);

module.exports = randomLayout;


/***/ }),

/***/ "./node_modules/graphology-layout/rotation.js":
/*!****************************************************!*\
  !*** ./node_modules/graphology-layout/rotation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Rotation Layout Helper
 * ==================================
 *
 * Function rotating the coordinates of the graph.
 */
var resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ "./node_modules/graphology-utils/defaults.js");
var isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");

/**
 * Constants.
 */
var RAD_CONVERSION = Math.PI / 180;

/**
 * Default options.
 */
var DEFAULTS = {
  dimensions: ['x', 'y'],
  centeredOnZero: false,
  degrees: false
};

/**
 * Abstract function for rotating a graph's coordinates.
 *
 * @param  {Graph}    graph          - Target  graph.
 * @param  {number}   angle          - Rotation angle.
 * @param  {object}   [options]      - Options.
 * @return {object}                  - The positions by node.
 */
function genericRotation(assign, graph, angle, options) {
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout/rotation: the given graph is not a valid graphology instance.'
    );

  options = resolveDefaults(options, DEFAULTS);

  if (options.degrees) angle *= RAD_CONVERSION;

  var dimensions = options.dimensions;

  if (!Array.isArray(dimensions) || dimensions.length !== 2)
    throw new Error('graphology-layout/random: given dimensions are invalid.');

  // Handling null graph
  if (graph.order === 0) {
    if (assign) return;

    return {};
  }

  var xd = dimensions[0];
  var yd = dimensions[1];

  var xCenter = 0;
  var yCenter = 0;

  if (!options.centeredOnZero) {
    // Finding bounds of the graph
    var xMin = Infinity;
    var xMax = -Infinity;
    var yMin = Infinity;
    var yMax = -Infinity;

    graph.forEachNode(function (node, attr) {
      var x = attr[xd];
      var y = attr[yd];

      if (x < xMin) xMin = x;
      if (x > xMax) xMax = x;
      if (y < yMin) yMin = y;
      if (y > yMax) yMax = y;
    });

    xCenter = (xMin + xMax) / 2;
    yCenter = (yMin + yMax) / 2;
  }

  var cos = Math.cos(angle);
  var sin = Math.sin(angle);

  function assignPosition(target) {
    var x = target[xd];
    var y = target[yd];

    target[xd] = xCenter + (x - xCenter) * cos - (y - yCenter) * sin;
    target[yd] = yCenter + (x - xCenter) * sin + (y - yCenter) * cos;

    return target;
  }

  if (!assign) {
    var positions = {};

    graph.forEachNode(function (node, attr) {
      var o = {};
      o[xd] = attr[xd];
      o[yd] = attr[yd];
      positions[node] = assignPosition(o);
    });

    return positions;
  }

  graph.updateEachNodeAttributes(
    function (_, attr) {
      assignPosition(attr);
      return attr;
    },
    {
      attributes: dimensions
    }
  );
}

var rotation = genericRotation.bind(null, false);
rotation.assign = genericRotation.bind(null, true);

module.exports = rotation;


/***/ }),

/***/ "./node_modules/graphology-utils/defaults.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/defaults.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Graphology Defaults
 * ====================
 *
 * Helper function used throughout the standard lib to resolve defaults.
 */
function isLeaf(o) {
  return (
    !o ||
    typeof o !== 'object' ||
    typeof o === 'function' ||
    Array.isArray(o) ||
    o instanceof Set ||
    o instanceof Map ||
    o instanceof RegExp ||
    o instanceof Date
  );
}

function resolveDefaults(target, defaults) {
  target = target || {};

  var output = {};

  for (var k in defaults) {
    var existing = target[k];
    var def = defaults[k];

    // Recursion
    if (!isLeaf(def)) {
      output[k] = resolveDefaults(existing, def);

      continue;
    }

    // Leaf
    if (existing === undefined) {
      output[k] = def;
    } else {
      output[k] = existing;
    }
  }

  return output;
}

module.exports = resolveDefaults;


/***/ }),

/***/ "./node_modules/graphology-utils/getters.js":
/*!**************************************************!*\
  !*** ./node_modules/graphology-utils/getters.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Weight Getter
 * =========================
 *
 * Function creating weight getters.
 */
function coerceWeight(value) {
  // Ensuring target value is a correct number
  if (typeof value !== 'number' || isNaN(value)) return 1;

  return value;
}

function createNodeValueGetter(nameOrFunction, defaultValue) {
  var getter = {};

  var coerceToDefault = function (v) {
    if (typeof v === 'undefined') return defaultValue;

    return v;
  };

  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;

  var get = function (attributes) {
    return coerceToDefault(attributes[nameOrFunction]);
  };

  var returnDefault = function () {
    return coerceToDefault(undefined);
  };

  if (typeof nameOrFunction === 'string') {
    getter.fromAttributes = get;
    getter.fromGraph = function (graph, node) {
      return get(graph.getNodeAttributes(node));
    };
    getter.fromEntry = function (node, attributes) {
      return get(attributes);
    };
  } else if (typeof nameOrFunction === 'function') {
    getter.fromAttributes = function () {
      throw new Error(
        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'
      );
    };
    getter.fromGraph = function (graph, node) {
      return coerceToDefault(
        nameOrFunction(node, graph.getNodeAttributes(node))
      );
    };
    getter.fromEntry = function (node, attributes) {
      return coerceToDefault(nameOrFunction(node, attributes));
    };
  } else {
    getter.fromAttributes = returnDefault;
    getter.fromGraph = returnDefault;
    getter.fromEntry = returnDefault;
  }

  return getter;
}

function createEdgeValueGetter(nameOrFunction, defaultValue) {
  var getter = {};

  var coerceToDefault = function (v) {
    if (typeof v === 'undefined') return defaultValue;

    return v;
  };

  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;

  var get = function (attributes) {
    return coerceToDefault(attributes[nameOrFunction]);
  };

  var returnDefault = function () {
    return coerceToDefault(undefined);
  };

  if (typeof nameOrFunction === 'string') {
    getter.fromAttributes = get;
    getter.fromGraph = function (graph, edge) {
      return get(graph.getEdgeAttributes(edge));
    };
    getter.fromEntry = function (edge, attributes) {
      return get(attributes);
    };
    getter.fromPartialEntry = getter.fromEntry;
    getter.fromMinimalEntry = getter.fromEntry;
  } else if (typeof nameOrFunction === 'function') {
    getter.fromAttributes = function () {
      throw new Error(
        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'
      );
    };
    getter.fromGraph = function (graph, edge) {
      // TODO: we can do better, check #310
      var extremities = graph.extremities(edge);
      return coerceToDefault(
        nameOrFunction(
          edge,
          graph.getEdgeAttributes(edge),
          extremities[0],
          extremities[1],
          graph.getNodeAttributes(extremities[0]),
          graph.getNodeAttributes(extremities[1]),
          graph.isUndirected(edge)
        )
      );
    };
    getter.fromEntry = function (e, a, s, t, sa, ta, u) {
      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
    };
    getter.fromPartialEntry = function (e, a, s, t) {
      return coerceToDefault(nameOrFunction(e, a, s, t));
    };
    getter.fromMinimalEntry = function (e, a) {
      return coerceToDefault(nameOrFunction(e, a));
    };
  } else {
    getter.fromAttributes = returnDefault;
    getter.fromGraph = returnDefault;
    getter.fromEntry = returnDefault;
    getter.fromMinimalEntry = returnDefault;
  }

  return getter;
}

exports.createNodeValueGetter = createNodeValueGetter;
exports.createEdgeValueGetter = createEdgeValueGetter;
exports.createEdgeWeightGetter = function (name) {
  return createEdgeValueGetter(name, coerceWeight);
};


/***/ }),

/***/ "./node_modules/graphology-utils/is-graph.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */

/**
 * Checking the value is a graphology instance.
 *
 * @param  {any}     value - Target value.
 * @return {boolean}
 */
module.exports = function isGraph(value) {
  return (
    value !== null &&
    typeof value === 'object' &&
    typeof value.addUndirectedEdgeWithKey === 'function' &&
    typeof value.dropNode === 'function' &&
    typeof value.multi === 'boolean'
  );
};


/***/ }),

/***/ "./node_modules/graphology/dist/graphology.umd.min.js":
/*!************************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.umd.min.js ***!
  \************************************************************/
/***/ (function(module) {

!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},t(e)}function e(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,r(t,e)}function n(t){return n=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},n(t)}function r(t,e){return r=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},r(t,e)}function i(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function o(t,e,n){return o=i()?Reflect.construct:function(t,e,n){var i=[null];i.push.apply(i,e);var o=new(Function.bind.apply(t,i));return n&&r(o,n.prototype),o},o.apply(null,arguments)}function a(t){var e="function"==typeof Map?new Map:void 0;return a=function(t){if(null===t||(i=t,-1===Function.toString.call(i).indexOf("[native code]")))return t;var i;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,a)}function a(){return o(t,arguments,n(this).constructor)}return a.prototype=Object.create(t.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),r(a,t)},a(t)}function u(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var c=function(){for(var t=arguments[0],e=1,n=arguments.length;e<n;e++)if(arguments[e])for(var r in arguments[e])t[r]=arguments[e][r];return t};function s(t,e,n,r){var i=t._nodes.get(e),o=null;return i?o="mixed"===r?i.out&&i.out[n]||i.undirected&&i.undirected[n]:"directed"===r?i.out&&i.out[n]:i.undirected&&i.undirected[n]:o}function d(e){return null!==e&&"object"===t(e)&&"function"==typeof e.addUndirectedEdgeWithKey&&"function"==typeof e.dropNode}function h(e){return"object"===t(e)&&null!==e&&e.constructor===Object}function p(t){var e;for(e in t)return!1;return!0}function f(t,e,n){Object.defineProperty(t,e,{enumerable:!1,configurable:!1,writable:!0,value:n})}function l(t,e,n){var r={enumerable:!0,configurable:!0};"function"==typeof n?r.get=n:(r.value=n,r.writable=!1),Object.defineProperty(t,e,r)}function g(t){return!!h(t)&&!(t.attributes&&!Array.isArray(t.attributes))}"function"==typeof Object.assign&&(c=Object.assign);var y,w={exports:{}},v="object"==typeof Reflect?Reflect:null,b=v&&"function"==typeof v.apply?v.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)};y=v&&"function"==typeof v.ownKeys?v.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var m=Number.isNaN||function(t){return t!=t};function k(){k.init.call(this)}w.exports=k,w.exports.once=function(t,e){return new Promise((function(n,r){function i(n){t.removeListener(e,o),r(n)}function o(){"function"==typeof t.removeListener&&t.removeListener("error",i),n([].slice.call(arguments))}N(t,e,o,{once:!0}),"error"!==e&&function(t,e,n){"function"==typeof t.on&&N(t,"error",e,n)}(t,i,{once:!0})}))},k.EventEmitter=k,k.prototype._events=void 0,k.prototype._eventsCount=0,k.prototype._maxListeners=void 0;var _=10;function G(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function x(t){return void 0===t._maxListeners?k.defaultMaxListeners:t._maxListeners}function E(t,e,n,r){var i,o,a,u;if(G(n),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,n.listener?n.listener:n),o=t._events),a=o[e]),void 0===a)a=o[e]=n,++t._eventsCount;else if("function"==typeof a?a=o[e]=r?[n,a]:[a,n]:r?a.unshift(n):a.push(n),(i=x(t))>0&&a.length>i&&!a.warned){a.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=t,c.type=e,c.count=a.length,u=c,console&&console.warn&&console.warn(u)}return t}function A(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function S(t,e,n){var r={fired:!1,wrapFn:void 0,target:t,type:e,listener:n},i=A.bind(r);return i.listener=n,r.wrapFn=i,i}function D(t,e,n){var r=t._events;if(void 0===r)return[];var i=r[e];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(t){for(var e=new Array(t.length),n=0;n<e.length;++n)e[n]=t[n].listener||t[n];return e}(i):U(i,i.length)}function L(t){var e=this._events;if(void 0!==e){var n=e[t];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function U(t,e){for(var n=new Array(e),r=0;r<e;++r)n[r]=t[r];return n}function N(t,e,n,r){if("function"==typeof t.on)r.once?t.once(e,n):t.on(e,n);else{if("function"!=typeof t.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof t);t.addEventListener(e,(function i(o){r.once&&t.removeEventListener(e,i),n(o)}))}}function j(t){if("function"!=typeof t)throw new Error("obliterator/iterator: expecting a function!");this.next=t}Object.defineProperty(k,"defaultMaxListeners",{enumerable:!0,get:function(){return _},set:function(t){if("number"!=typeof t||t<0||m(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");_=t}}),k.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},k.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||m(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},k.prototype.getMaxListeners=function(){return x(this)},k.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var r="error"===t,i=this._events;if(void 0!==i)r=r&&void 0===i.error;else if(!r)return!1;if(r){var o;if(e.length>0&&(o=e[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var u=i[t];if(void 0===u)return!1;if("function"==typeof u)b(u,this,e);else{var c=u.length,s=U(u,c);for(n=0;n<c;++n)b(s[n],this,e)}return!0},k.prototype.addListener=function(t,e){return E(this,t,e,!1)},k.prototype.on=k.prototype.addListener,k.prototype.prependListener=function(t,e){return E(this,t,e,!0)},k.prototype.once=function(t,e){return G(e),this.on(t,S(this,t,e)),this},k.prototype.prependOnceListener=function(t,e){return G(e),this.prependListener(t,S(this,t,e)),this},k.prototype.removeListener=function(t,e){var n,r,i,o,a;if(G(e),void 0===(r=this._events))return this;if(void 0===(n=r[t]))return this;if(n===e||n.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete r[t],r.removeListener&&this.emit("removeListener",t,n.listener||e));else if("function"!=typeof n){for(i=-1,o=n.length-1;o>=0;o--)if(n[o]===e||n[o].listener===e){a=n[o].listener,i=o;break}if(i<0)return this;0===i?n.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(n,i),1===n.length&&(r[t]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",t,a||e)}return this},k.prototype.off=k.prototype.removeListener,k.prototype.removeAllListeners=function(t){var e,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[t]),this;if(0===arguments.length){var i,o=Object.keys(n);for(r=0;r<o.length;++r)"removeListener"!==(i=o[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=n[t]))this.removeListener(t,e);else if(void 0!==e)for(r=e.length-1;r>=0;r--)this.removeListener(t,e[r]);return this},k.prototype.listeners=function(t){return D(this,t,!0)},k.prototype.rawListeners=function(t){return D(this,t,!1)},k.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):L.call(t,e)},k.prototype.listenerCount=L,k.prototype.eventNames=function(){return this._eventsCount>0?y(this._events):[]},"undefined"!=typeof Symbol&&(j.prototype[Symbol.iterator]=function(){return this}),j.of=function(){var t=arguments,e=t.length,n=0;return new j((function(){return n>=e?{done:!0}:{done:!1,value:t[n++]}}))},j.empty=function(){return new j((function(){return{done:!0}}))},j.fromSequence=function(t){var e=0,n=t.length;return new j((function(){return e>=n?{done:!0}:{done:!1,value:t[e++]}}))},j.is=function(t){return t instanceof j||"object"==typeof t&&null!==t&&"function"==typeof t.next};var O=j,C={};C.ARRAY_BUFFER_SUPPORT="undefined"!=typeof ArrayBuffer,C.SYMBOL_SUPPORT="undefined"!=typeof Symbol;var z=O,M=C,W=M.ARRAY_BUFFER_SUPPORT,P=M.SYMBOL_SUPPORT;var R=function(t){var e=function(t){return"string"==typeof t||Array.isArray(t)||W&&ArrayBuffer.isView(t)?z.fromSequence(t):"object"!=typeof t||null===t?null:P&&"function"==typeof t[Symbol.iterator]?t[Symbol.iterator]():"function"==typeof t.next?t:null}(t);if(!e)throw new Error("obliterator: target is not iterable nor a valid iterator.");return e},K=R,T=function(t,e){for(var n,r=arguments.length>1?e:1/0,i=r!==1/0?new Array(r):[],o=0,a=K(t);;){if(o===r)return i;if((n=a.next()).done)return o!==e&&(i.length=o),i;i[o++]=n.value}},B=function(t){function n(e){var n;return(n=t.call(this)||this).name="GraphError",n.message=e,n}return e(n,t),n}(a(Error)),F=function(t){function n(e){var r;return(r=t.call(this,e)||this).name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u(r),n.prototype.constructor),r}return e(n,t),n}(B),I=function(t){function n(e){var r;return(r=t.call(this,e)||this).name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u(r),n.prototype.constructor),r}return e(n,t),n}(B),Y=function(t){function n(e){var r;return(r=t.call(this,e)||this).name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(u(r),n.prototype.constructor),r}return e(n,t),n}(B);function q(t,e){this.key=t,this.attributes=e,this.clear()}function J(t,e){this.key=t,this.attributes=e,this.clear()}function V(t,e){this.key=t,this.attributes=e,this.clear()}function H(t,e,n,r,i){this.key=e,this.attributes=i,this.undirected=t,this.source=n,this.target=r}q.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}},J.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}},V.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}},H.prototype.attach=function(){var t="out",e="in";this.undirected&&(t=e="undirected");var n=this.source.key,r=this.target.key;this.source[t][r]=this,this.undirected&&n===r||(this.target[e][n]=this)},H.prototype.attachMulti=function(){var t="out",e="in",n=this.source.key,r=this.target.key;this.undirected&&(t=e="undirected");var i=this.source[t],o=i[r];if(void 0===o)return i[r]=this,void(this.undirected&&n===r||(this.target[e][n]=this));o.previous=this,this.next=o,i[r]=this,this.target[e][n]=this},H.prototype.detach=function(){var t=this.source.key,e=this.target.key,n="out",r="in";this.undirected&&(n=r="undirected"),delete this.source[n][e],delete this.target[r][t]},H.prototype.detachMulti=function(){var t=this.source.key,e=this.target.key,n="out",r="in";this.undirected&&(n=r="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[n][e],delete this.target[r][t]):(this.next.previous=void 0,this.source[n][e]=this.next,this.target[r][t]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};function Q(t,e,n,r,i,o,a){var u,c,s,d;if(r=""+r,0===n){if(!(u=t._nodes.get(r)))throw new I("Graph.".concat(e,': could not find the "').concat(r,'" node in the graph.'));s=i,d=o}else if(3===n){if(i=""+i,!(c=t._edges.get(i)))throw new I("Graph.".concat(e,': could not find the "').concat(i,'" edge in the graph.'));var h=c.source.key,p=c.target.key;if(r===h)u=c.target;else{if(r!==p)throw new I("Graph.".concat(e,': the "').concat(r,'" node is not attached to the "').concat(i,'" edge (').concat(h,", ").concat(p,")."));u=c.source}s=o,d=a}else{if(!(c=t._edges.get(r)))throw new I("Graph.".concat(e,': could not find the "').concat(r,'" edge in the graph.'));u=1===n?c.source:c.target,s=i,d=o}return[u,s,d]}var X=[{name:function(t){return"get".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];return a.attributes[u]}}},{name:function(t){return"get".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){return Q(this,e,n,t,r)[0].attributes}}},{name:function(t){return"has".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];return a.attributes.hasOwnProperty(u)}}},{name:function(t){return"set".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i,o){var a=Q(this,e,n,t,r,i,o),u=a[0],c=a[1],s=a[2];return u.attributes[c]=s,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:c}),this}}},{name:function(t){return"update".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i,o){var a=Q(this,e,n,t,r,i,o),u=a[0],c=a[1],s=a[2];if("function"!=typeof s)throw new F("Graph.".concat(e,": updater should be a function."));var d=u.attributes,h=s(d[c]);return d[c]=h,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:c}),this}}},{name:function(t){return"remove".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];return delete a.attributes[u],this.emit("nodeAttributesUpdated",{key:a.key,type:"remove",attributes:a.attributes,name:u}),this}}},{name:function(t){return"replace".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];if(!h(u))throw new F("Graph.".concat(e,": provided attributes are not a plain object."));return a.attributes=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"replace",attributes:a.attributes}),this}}},{name:function(t){return"merge".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];if(!h(u))throw new F("Graph.".concat(e,": provided attributes are not a plain object."));return c(a.attributes,u),this.emit("nodeAttributesUpdated",{key:a.key,type:"merge",attributes:a.attributes,data:u}),this}}},{name:function(t){return"update".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o=Q(this,e,n,t,r,i),a=o[0],u=o[1];if("function"!=typeof u)throw new F("Graph.".concat(e,": provided updater is not a function."));return a.attributes=u(a.attributes),this.emit("nodeAttributesUpdated",{key:a.key,type:"update",attributes:a.attributes}),this}}}];var Z=[{name:function(t){return"get".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return i.attributes[r]}}},{name:function(t){return"get".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t){var r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var i=""+t,o=""+arguments[1];if(!(r=s(this,i,o,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(i,'" - "').concat(o,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(r=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return r.attributes}}},{name:function(t){return"has".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return i.attributes.hasOwnProperty(r)}}},{name:function(t){return"set".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+t,u=""+r;if(r=arguments[2],i=arguments[3],!(o=s(this,a,u,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(o=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return o.attributes[r]=i,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:function(t){return"update".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r,i){var o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+t,u=""+r;if(r=arguments[2],i=arguments[3],!(o=s(this,a,u,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(o=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if("function"!=typeof i)throw new F("Graph.".concat(e,": updater should be a function."));return o.attributes[r]=i(o.attributes[r]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:r}),this}}},{name:function(t){return"remove".concat(t,"Attribute")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}return delete i.attributes[r],this.emit("edgeAttributesUpdated",{key:i.key,type:"remove",attributes:i.attributes,name:r}),this}}},{name:function(t){return"replace".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if(!h(r))throw new F("Graph.".concat(e,": provided attributes are not a plain object."));return i.attributes=r,this.emit("edgeAttributesUpdated",{key:i.key,type:"replace",attributes:i.attributes}),this}}},{name:function(t){return"merge".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if(!h(r))throw new F("Graph.".concat(e,": provided attributes are not a plain object."));return c(i.attributes,r),this.emit("edgeAttributesUpdated",{key:i.key,type:"merge",attributes:i.attributes,data:r}),this}}},{name:function(t){return"update".concat(t,"Attributes")},attacher:function(t,e,n){t.prototype[e]=function(t,r){var i;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new Y("Graph.".concat(e,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new Y("Graph.".concat(e,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var o=""+t,a=""+r;if(r=arguments[2],!(i=s(this,o,a,n)))throw new I("Graph.".concat(e,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new Y("Graph.".concat(e,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(t=""+t,!(i=this._edges.get(t)))throw new I("Graph.".concat(e,': could not find the "').concat(t,'" edge in the graph.'))}if("function"!=typeof r)throw new F("Graph.".concat(e,": provided updater is not a function."));return i.attributes=r(i.attributes),this.emit("edgeAttributesUpdated",{key:i.key,type:"update",attributes:i.attributes}),this}}}];var $=O,tt=R,et=function(){var t=arguments,e=null,n=-1;return new $((function(){for(var r=null;;){if(null===e){if(++n>=t.length)return{done:!0};e=tt(t[n])}if(!0!==(r=e.next()).done)break;e=null}return r}))},nt=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function rt(t,e,n,r){var i=!1;for(var o in e)if(o!==r){var a=e[o];if(i=n(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),t&&i)return a.key}}function it(t,e,n,r){var i,o,a,u=!1;for(var c in e)if(c!==r){i=e[c];do{if(o=i.source,a=i.target,u=n(i.key,i.attributes,o.key,a.key,o.attributes,a.attributes,i.undirected),t&&u)return i.key;i=i.next}while(void 0!==i)}}function ot(t,e){var n,r=Object.keys(t),i=r.length,o=0;return new O((function(){do{if(n)n=n.next;else{if(o>=i)return{done:!0};var a=r[o++];if(a===e){n=void 0;continue}n=t[a]}}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}}))}function at(t,e,n,r){var i=e[n];if(i){var o=i.source,a=i.target;return r(i.key,i.attributes,o.key,a.key,o.attributes,a.attributes,i.undirected)&&t?i.key:void 0}}function ut(t,e,n,r){var i=e[n];if(i){var o=!1;do{if(o=r(i.key,i.attributes,i.source.key,i.target.key,i.source.attributes,i.target.attributes,i.undirected),t&&o)return i.key;i=i.next}while(void 0!==i)}}function ct(t,e){var n=t[e];return void 0!==n.next?new O((function(){if(!n)return{done:!0};var t={edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected};return n=n.next,{done:!1,value:t}})):O.of({edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected})}function st(t,e){if(0===t.size)return[];if("mixed"===e||e===t.type)return"function"==typeof Array.from?Array.from(t._edges.keys()):T(t._edges.keys(),t._edges.size);for(var n,r,i="undirected"===e?t.undirectedSize:t.directedSize,o=new Array(i),a="undirected"===e,u=t._edges.values(),c=0;!0!==(n=u.next()).done;)(r=n.value).undirected===a&&(o[c++]=r.key);return o}function dt(t,e,n,r){if(0!==e.size)for(var i,o,a="mixed"!==n&&n!==e.type,u="undirected"===n,c=!1,s=e._edges.values();!0!==(i=s.next()).done;)if(o=i.value,!a||o.undirected===u){var d=o,h=d.key,p=d.attributes,f=d.source,l=d.target;if(c=r(h,p,f.key,l.key,f.attributes,l.attributes,o.undirected),t&&c)return h}}function ht(t,e){if(0===t.size)return O.empty();var n="mixed"!==e&&e!==t.type,r="undirected"===e,i=t._edges.values();return new O((function(){for(var t,e;;){if((t=i.next()).done)return t;if(e=t.value,!n||e.undirected===r)break}return{value:{edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected},done:!1}}))}function pt(t,e,n,r,i,o){var a,u=e?it:rt;if("undirected"!==n){if("out"!==r&&(a=u(t,i.in,o),t&&a))return a;if("in"!==r&&(a=u(t,i.out,o,r?void 0:i.key),t&&a))return a}if("directed"!==n&&(a=u(t,i.undirected,o),t&&a))return a}function ft(t,e,n,r){var i=[];return pt(!1,t,e,n,r,(function(t){i.push(t)})),i}function lt(t,e,n){var r=O.empty();return"undirected"!==t&&("out"!==e&&void 0!==n.in&&(r=et(r,ot(n.in))),"in"!==e&&void 0!==n.out&&(r=et(r,ot(n.out,e?void 0:n.key)))),"directed"!==t&&void 0!==n.undirected&&(r=et(r,ot(n.undirected))),r}function gt(t,e,n,r,i,o,a){var u,c=n?ut:at;if("undirected"!==e){if(void 0!==i.in&&"out"!==r&&(u=c(t,i.in,o,a),t&&u))return u;if(void 0!==i.out&&"in"!==r&&(r||i.key!==o)&&(u=c(t,i.out,o,a),t&&u))return u}if("directed"!==e&&void 0!==i.undirected&&(u=c(t,i.undirected,o,a),t&&u))return u}function yt(t,e,n,r,i){var o=[];return gt(!1,t,e,n,r,i,(function(t){o.push(t)})),o}function wt(t,e,n,r){var i=O.empty();return"undirected"!==t&&(void 0!==n.in&&"out"!==e&&r in n.in&&(i=et(i,ct(n.in,r))),void 0!==n.out&&"in"!==e&&r in n.out&&(e||n.key!==r)&&(i=et(i,ct(n.out,r)))),"directed"!==t&&void 0!==n.undirected&&r in n.undirected&&(i=et(i,ct(n.undirected,r))),i}var vt=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function bt(){this.A=null,this.B=null}function mt(t,e,n,r,i){for(var o in r){var a=r[o],u=a.source,c=a.target,s=u===n?c:u;if(!e||!e.has(s.key)){var d=i(s.key,s.attributes);if(t&&d)return s.key}}}function kt(t,e,n,r,i){if("mixed"!==e){if("undirected"===e)return mt(t,null,r,r.undirected,i);if("string"==typeof n)return mt(t,null,r,r[n],i)}var o,a=new bt;if("undirected"!==e){if("out"!==n){if(o=mt(t,null,r,r.in,i),t&&o)return o;a.wrap(r.in)}if("in"!==n){if(o=mt(t,a,r,r.out,i),t&&o)return o;a.wrap(r.out)}}if("directed"!==e&&(o=mt(t,a,r,r.undirected,i),t&&o))return o}function _t(t,e,n){var r=Object.keys(n),i=r.length,o=0;return new O((function(){var a=null;do{if(o>=i)return t&&t.wrap(n),{done:!0};var u=n[r[o++]],c=u.source,s=u.target;a=c===e?s:c,t&&t.has(a.key)&&(a=null)}while(null===a);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}}))}function Gt(t,e){var n=e.name,r=e.type,i=e.direction;t.prototype[n]=function(t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];t=""+t;var e=this._nodes.get(t);if(void 0===e)throw new I("Graph.".concat(n,': could not find the "').concat(t,'" node in the graph.'));return function(t,e,n){if("mixed"!==t){if("undirected"===t)return Object.keys(n.undirected);if("string"==typeof e)return Object.keys(n[e])}var r=[];return kt(!1,t,e,n,(function(t){r.push(t)})),r}("mixed"===r?this.type:r,i,e)}}function xt(t,e){var n=e.name,r=e.type,i=e.direction,o=n.slice(0,-1)+"Entries";t.prototype[o]=function(t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return O.empty();t=""+t;var e=this._nodes.get(t);if(void 0===e)throw new I("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return function(t,e,n){if("mixed"!==t){if("undirected"===t)return _t(null,n,n.undirected);if("string"==typeof e)return _t(null,n,n[e])}var r=O.empty(),i=new bt;return"undirected"!==t&&("out"!==e&&(r=et(r,_t(i,n,n.in))),"in"!==e&&(r=et(r,_t(i,n,n.out)))),"directed"!==t&&(r=et(r,_t(i,n,n.undirected))),r}("mixed"===r?this.type:r,i,e)}}function Et(t,e,n,r,i){for(var o,a,u,c,s,d,h,p=r._nodes.values(),f=r.type;!0!==(o=p.next()).done;){var l=!1;if(a=o.value,"undirected"!==f)for(u in c=a.out){s=c[u];do{if(d=s.target,l=!0,h=i(a.key,d.key,a.attributes,d.attributes,s.key,s.attributes,s.undirected),t&&h)return s;s=s.next}while(s)}if("directed"!==f)for(u in c=a.undirected)if(!(e&&a.key>u)){s=c[u];do{if((d=s.target).key!==u&&(d=s.source),l=!0,h=i(a.key,d.key,a.attributes,d.attributes,s.key,s.attributes,s.undirected),t&&h)return s;s=s.next}while(s)}if(n&&!l&&(h=i(a.key,null,a.attributes,null,null,null,null),t&&h))return null}}function At(t){if(!h(t))throw new F('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in t))throw new F("Graph.import: serialized node is missing its key.");if("attributes"in t&&(!h(t.attributes)||null===t.attributes))throw new F("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function St(t){if(!h(t))throw new F('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in t))throw new F("Graph.import: serialized edge is missing its source.");if(!("target"in t))throw new F("Graph.import: serialized edge is missing its target.");if("attributes"in t&&(!h(t.attributes)||null===t.attributes))throw new F("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in t&&"boolean"!=typeof t.undirected)throw new F("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}bt.prototype.wrap=function(t){null===this.A?this.A=t:null===this.B&&(this.B=t)},bt.prototype.has=function(t){return null!==this.A&&t in this.A||null!==this.B&&t in this.B};var Dt,Lt=(Dt=255&Math.floor(256*Math.random()),function(){return Dt++}),Ut=new Set(["directed","undirected","mixed"]),Nt=new Set(["domain","_events","_eventsCount","_maxListeners"]),jt={allowSelfLoops:!0,multi:!1,type:"mixed"};function Ot(t,e,n){var r=new t.NodeDataClass(e,n);return t._nodes.set(e,r),t.emit("nodeAdded",{key:e,attributes:n}),r}function Ct(t,e,n,r,i,o,a,u){if(!r&&"undirected"===t.type)throw new Y("Graph.".concat(e,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(r&&"directed"===t.type)throw new Y("Graph.".concat(e,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(u&&!h(u))throw new F("Graph.".concat(e,': invalid attributes. Expecting an object but got "').concat(u,'"'));if(o=""+o,a=""+a,u=u||{},!t.allowSelfLoops&&o===a)throw new Y("Graph.".concat(e,': source & target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var c=t._nodes.get(o),s=t._nodes.get(a);if(!c)throw new I("Graph.".concat(e,': source node "').concat(o,'" not found.'));if(!s)throw new I("Graph.".concat(e,': target node "').concat(a,'" not found.'));var d={key:null,undirected:r,source:o,target:a,attributes:u};if(n)i=t._edgeKeyGenerator();else if(i=""+i,t._edges.has(i))throw new Y("Graph.".concat(e,': the "').concat(i,'" edge already exists in the graph.'));if(!t.multi&&(r?void 0!==c.undirected[a]:void 0!==c.out[a]))throw new Y("Graph.".concat(e,': an edge linking "').concat(o,'" to "').concat(a,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));var p=new H(r,i,c,s,u);t._edges.set(i,p);var f=o===a;return r?(c.undirectedDegree++,s.undirectedDegree++,f&&t._undirectedSelfLoopCount++):(c.outDegree++,s.inDegree++,f&&t._directedSelfLoopCount++),t.multi?p.attachMulti():p.attach(),r?t._undirectedSize++:t._directedSize++,d.key=i,t.emit("edgeAdded",d),i}function zt(t,e,n,r,i,o,a,u,s){if(!r&&"undirected"===t.type)throw new Y("Graph.".concat(e,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(r&&"directed"===t.type)throw new Y("Graph.".concat(e,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(u)if(s){if("function"!=typeof u)throw new F("Graph.".concat(e,': invalid updater function. Expecting a function but got "').concat(u,'"'))}else if(!h(u))throw new F("Graph.".concat(e,': invalid attributes. Expecting an object but got "').concat(u,'"'));var d;if(o=""+o,a=""+a,s&&(d=u,u=void 0),!t.allowSelfLoops&&o===a)throw new Y("Graph.".concat(e,': source & target are the same ("').concat(o,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var p,f,l=t._nodes.get(o),g=t._nodes.get(a);if(!n&&(p=t._edges.get(i))){if(!(p.source.key===o&&p.target.key===a||r&&p.source.key===a&&p.target.key===o))throw new Y("Graph.".concat(e,': inconsistency detected when attempting to merge the "').concat(i,'" edge with "').concat(o,'" source & "').concat(a,'" target vs. ("').concat(p.source.key,'", "').concat(p.target.key,'").'));f=p}if(f||t.multi||!l||(f=r?l.undirected[a]:l.out[a]),f){var y=[f.key,!1,!1,!1];if(s?!d:!u)return y;if(s){var w=f.attributes;f.attributes=d(w),t.emit("edgeAttributesUpdated",{type:"replace",key:f.key,attributes:f.attributes})}else c(f.attributes,u),t.emit("edgeAttributesUpdated",{type:"merge",key:f.key,attributes:f.attributes,data:u});return y}u=u||{},s&&d&&(u=d(u));var v={key:null,undirected:r,source:o,target:a,attributes:u};if(n)i=t._edgeKeyGenerator();else if(i=""+i,t._edges.has(i))throw new Y("Graph.".concat(e,': the "').concat(i,'" edge already exists in the graph.'));var b=!1,m=!1;l||(l=Ot(t,o,{}),b=!0,o===a&&(g=l,m=!0)),g||(g=Ot(t,a,{}),m=!0),p=new H(r,i,l,g,u),t._edges.set(i,p);var k=o===a;return r?(l.undirectedDegree++,g.undirectedDegree++,k&&t._undirectedSelfLoopCount++):(l.outDegree++,g.inDegree++,k&&t._directedSelfLoopCount++),t.multi?p.attachMulti():p.attach(),r?t._undirectedSize++:t._directedSize++,v.key=i,t.emit("edgeAdded",v),[i,!0,b,m]}function Mt(t,e){t._edges.delete(e.key);var n=e.source,r=e.target,i=e.attributes,o=e.undirected,a=n===r;o?(n.undirectedDegree--,r.undirectedDegree--,a&&t._undirectedSelfLoopCount--):(n.outDegree--,r.inDegree--,a&&t._directedSelfLoopCount--),t.multi?e.detachMulti():e.detach(),o?t._undirectedSize--:t._directedSize--,t.emit("edgeDropped",{key:e.key,attributes:i,source:n.key,target:r.key,undirected:o})}var Wt=function(n){function r(t){var e;if(e=n.call(this)||this,"boolean"!=typeof(t=c({},jt,t)).multi)throw new F("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(t.multi,'".'));if(!Ut.has(t.type))throw new F('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(t.type,'".'));if("boolean"!=typeof t.allowSelfLoops)throw new F("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(t.allowSelfLoops,'".'));var r="mixed"===t.type?q:"directed"===t.type?J:V;f(u(e),"NodeDataClass",r);var i="geid_"+Lt()+"_",o=0;return f(u(e),"_attributes",{}),f(u(e),"_nodes",new Map),f(u(e),"_edges",new Map),f(u(e),"_directedSize",0),f(u(e),"_undirectedSize",0),f(u(e),"_directedSelfLoopCount",0),f(u(e),"_undirectedSelfLoopCount",0),f(u(e),"_edgeKeyGenerator",(function(){var t;do{t=i+o++}while(e._edges.has(t));return t})),f(u(e),"_options",t),Nt.forEach((function(t){return f(u(e),t,e[t])})),l(u(e),"order",(function(){return e._nodes.size})),l(u(e),"size",(function(){return e._edges.size})),l(u(e),"directedSize",(function(){return e._directedSize})),l(u(e),"undirectedSize",(function(){return e._undirectedSize})),l(u(e),"selfLoopCount",(function(){return e._directedSelfLoopCount+e._undirectedSelfLoopCount})),l(u(e),"directedSelfLoopCount",(function(){return e._directedSelfLoopCount})),l(u(e),"undirectedSelfLoopCount",(function(){return e._undirectedSelfLoopCount})),l(u(e),"multi",e._options.multi),l(u(e),"type",e._options.type),l(u(e),"allowSelfLoops",e._options.allowSelfLoops),l(u(e),"implementation",(function(){return"graphology"})),e}e(r,n);var i=r.prototype;return i._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},i.hasNode=function(t){return this._nodes.has(""+t)},i.hasDirectedEdge=function(t,e){if("undirected"===this.type)return!1;if(1===arguments.length){var n=""+t,r=this._edges.get(n);return!!r&&!r.undirected}if(2===arguments.length){t=""+t,e=""+e;var i=this._nodes.get(t);if(!i)return!1;var o=i.out[e];return!!o&&(!this.multi||!!o.size)}throw new F("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasUndirectedEdge=function(t,e){if("directed"===this.type)return!1;if(1===arguments.length){var n=""+t,r=this._edges.get(n);return!!r&&r.undirected}if(2===arguments.length){t=""+t,e=""+e;var i=this._nodes.get(t);if(!i)return!1;var o=i.undirected[e];return!!o&&(!this.multi||!!o.size)}throw new F("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasEdge=function(t,e){if(1===arguments.length){var n=""+t;return this._edges.has(n)}if(2===arguments.length){t=""+t,e=""+e;var r=this._nodes.get(t);if(!r)return!1;var i=void 0!==r.out&&r.out[e];return i||(i=void 0!==r.undirected&&r.undirected[e]),!!i&&(!this.multi||!!i.size)}throw new F("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.directedEdge=function(t,e){if("undirected"!==this.type){if(t=""+t,e=""+e,this.multi)throw new Y("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var n=this._nodes.get(t);if(!n)throw new I('Graph.directedEdge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I('Graph.directedEdge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.out&&n.out[e]||void 0;return r?r.key:void 0}},i.undirectedEdge=function(t,e){if("directed"!==this.type){if(t=""+t,e=""+e,this.multi)throw new Y("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var n=this._nodes.get(t);if(!n)throw new I('Graph.undirectedEdge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I('Graph.undirectedEdge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.undirected&&n.undirected[e]||void 0;return r?r.key:void 0}},i.edge=function(t,e){if(this.multi)throw new Y("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.edge: could not find the "'.concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I('Graph.edge: could not find the "'.concat(e,'" target node in the graph.'));var r=n.out&&n.out[e]||n.undirected&&n.undirected[e]||void 0;if(r)return r.key},i.areDirectedNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areDirectedNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&(e in n.in||e in n.out)},i.areOutNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areOutNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&e in n.out},i.areInNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areInNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&e in n.in},i.areUndirectedNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areUndirectedNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"directed"!==this.type&&e in n.undirected},i.areNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&(e in n.in||e in n.out)||"directed"!==this.type&&e in n.undirected},i.areInboundNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areInboundNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&e in n.in||"directed"!==this.type&&e in n.undirected},i.areOutboundNeighbors=function(t,e){t=""+t,e=""+e;var n=this._nodes.get(t);if(!n)throw new I('Graph.areOutboundNeighbors: could not find the "'.concat(t,'" node in the graph.'));return"undirected"!==this.type&&e in n.out||"directed"!==this.type&&e in n.undirected},i.inDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.inDegree: could not find the "'.concat(t,'" node in the graph.'));return"undirected"===this.type?0:e.inDegree},i.outDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.outDegree: could not find the "'.concat(t,'" node in the graph.'));return"undirected"===this.type?0:e.outDegree},i.directedDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.directedDegree: could not find the "'.concat(t,'" node in the graph.'));return"undirected"===this.type?0:e.inDegree+e.outDegree},i.undirectedDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.undirectedDegree: could not find the "'.concat(t,'" node in the graph.'));return"directed"===this.type?0:e.undirectedDegree},i.inboundDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.inboundDegree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return"directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.inDegree),n},i.outboundDegree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.outboundDegree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return"directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.outDegree),n},i.degree=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.degree: could not find the "'.concat(t,'" node in the graph.'));var n=0;return"directed"!==this.type&&(n+=e.undirectedDegree),"undirected"!==this.type&&(n+=e.inDegree+e.outDegree),n},i.inDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));if("undirected"===this.type)return 0;var n=e.in[t],r=n?this.multi?n.size:1:0;return e.inDegree-r},i.outDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));if("undirected"===this.type)return 0;var n=e.out[t],r=n?this.multi?n.size:1:0;return e.outDegree-r},i.directedDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));if("undirected"===this.type)return 0;var n=e.out[t],r=n?this.multi?n.size:1:0;return e.inDegree+e.outDegree-2*r},i.undirectedDegreeWithoutSelfLoops=function(t){t=""+t;var e=this._nodes.get(t);if(!e)throw new I('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));if("directed"===this.type)return 0;var n=e.undirected[t],r=n?this.multi?n.size:1:0;return e.undirectedDegree-2*r},i.inboundDegreeWithoutSelfLoops=function(t){t=""+t;var e,n=this._nodes.get(t);if(!n)throw new I('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var r=0,i=0;return"directed"!==this.type&&(r+=n.undirectedDegree,i+=2*((e=n.undirected[t])?this.multi?e.size:1:0)),"undirected"!==this.type&&(r+=n.inDegree,i+=(e=n.out[t])?this.multi?e.size:1:0),r-i},i.outboundDegreeWithoutSelfLoops=function(t){t=""+t;var e,n=this._nodes.get(t);if(!n)throw new I('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var r=0,i=0;return"directed"!==this.type&&(r+=n.undirectedDegree,i+=2*((e=n.undirected[t])?this.multi?e.size:1:0)),"undirected"!==this.type&&(r+=n.outDegree,i+=(e=n.in[t])?this.multi?e.size:1:0),r-i},i.degreeWithoutSelfLoops=function(t){t=""+t;var e,n=this._nodes.get(t);if(!n)throw new I('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t,'" node in the graph.'));var r=0,i=0;return"directed"!==this.type&&(r+=n.undirectedDegree,i+=2*((e=n.undirected[t])?this.multi?e.size:1:0)),"undirected"!==this.type&&(r+=n.inDegree+n.outDegree,i+=2*((e=n.out[t])?this.multi?e.size:1:0)),r-i},i.source=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.source: could not find the "'.concat(t,'" edge in the graph.'));return e.source.key},i.target=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.target: could not find the "'.concat(t,'" edge in the graph.'));return e.target.key},i.extremities=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.extremities: could not find the "'.concat(t,'" edge in the graph.'));return[e.source.key,e.target.key]},i.opposite=function(t,e){t=""+t,e=""+e;var n=this._edges.get(e);if(!n)throw new I('Graph.opposite: could not find the "'.concat(e,'" edge in the graph.'));var r=n.source.key,i=n.target.key;if(t===r)return i;if(t===i)return r;throw new I('Graph.opposite: the "'.concat(t,'" node is not attached to the "').concat(e,'" edge (').concat(r,", ").concat(i,")."))},i.hasExtremity=function(t,e){t=""+t,e=""+e;var n=this._edges.get(t);if(!n)throw new I('Graph.hasExtremity: could not find the "'.concat(t,'" edge in the graph.'));return n.source.key===e||n.target.key===e},i.isUndirected=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.isUndirected: could not find the "'.concat(t,'" edge in the graph.'));return e.undirected},i.isDirected=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.isDirected: could not find the "'.concat(t,'" edge in the graph.'));return!e.undirected},i.isSelfLoop=function(t){t=""+t;var e=this._edges.get(t);if(!e)throw new I('Graph.isSelfLoop: could not find the "'.concat(t,'" edge in the graph.'));return e.source===e.target},i.addNode=function(t,e){var n=function(t,e,n){if(n&&!h(n))throw new F('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n,'"'));if(e=""+e,n=n||{},t._nodes.has(e))throw new Y('Graph.addNode: the "'.concat(e,'" node already exist in the graph.'));var r=new t.NodeDataClass(e,n);return t._nodes.set(e,r),t.emit("nodeAdded",{key:e,attributes:n}),r}(this,t,e);return n.key},i.mergeNode=function(t,e){if(e&&!h(e))throw new F('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e,'"'));t=""+t,e=e||{};var n=this._nodes.get(t);return n?(e&&(c(n.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:n.attributes,data:e})),[t,!1]):(n=new this.NodeDataClass(t,e),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])},i.updateNode=function(t,e){if(e&&"function"!=typeof e)throw new F('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e,'"'));t=""+t;var n=this._nodes.get(t);if(n){if(e){var r=n.attributes;n.attributes=e(r),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:n.attributes})}return[t,!1]}var i=e?e({}):{};return n=new this.NodeDataClass(t,i),this._nodes.set(t,n),this.emit("nodeAdded",{key:t,attributes:i}),[t,!0]},i.dropNode=function(t){t=""+t;var e,n=this._nodes.get(t);if(!n)throw new I('Graph.dropNode: could not find the "'.concat(t,'" node in the graph.'));if("undirected"!==this.type){for(var r in n.out){e=n.out[r];do{Mt(this,e),e=e.next}while(e)}for(var i in n.in){e=n.in[i];do{Mt(this,e),e=e.next}while(e)}}if("directed"!==this.type)for(var o in n.undirected){e=n.undirected[o];do{Mt(this,e),e=e.next}while(e)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:n.attributes})},i.dropEdge=function(t){var e;if(arguments.length>1){var n=""+arguments[0],r=""+arguments[1];if(!(e=s(this,n,r,this.type)))throw new I('Graph.dropEdge: could not find the "'.concat(n,'" -> "').concat(r,'" edge in the graph.'))}else if(t=""+t,!(e=this._edges.get(t)))throw new I('Graph.dropEdge: could not find the "'.concat(t,'" edge in the graph.'));return Mt(this,e),this},i.dropDirectedEdge=function(t,e){if(arguments.length<2)throw new Y("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new Y("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var n=s(this,t=""+t,e=""+e,"directed");if(!n)throw new I('Graph.dropDirectedEdge: could not find a "'.concat(t,'" -> "').concat(e,'" edge in the graph.'));return Mt(this,n),this},i.dropUndirectedEdge=function(t,e){if(arguments.length<2)throw new Y("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new Y("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var n=s(this,t,e,"undirected");if(!n)throw new I('Graph.dropUndirectedEdge: could not find a "'.concat(t,'" -> "').concat(e,'" edge in the graph.'));return Mt(this,n),this},i.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},i.clearEdges=function(){for(var t,e=this._nodes.values();!0!==(t=e.next()).done;)t.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},i.getAttribute=function(t){return this._attributes[t]},i.getAttributes=function(){return this._attributes},i.hasAttribute=function(t){return this._attributes.hasOwnProperty(t)},i.setAttribute=function(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this},i.updateAttribute=function(t,e){if("function"!=typeof e)throw new F("Graph.updateAttribute: updater should be a function.");var n=this._attributes[t];return this._attributes[t]=e(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this},i.removeAttribute=function(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this},i.replaceAttributes=function(t){if(!h(t))throw new F("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},i.mergeAttributes=function(t){if(!h(t))throw new F("Graph.mergeAttributes: provided attributes are not a plain object.");return c(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this},i.updateAttributes=function(t){if("function"!=typeof t)throw new F("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},i.updateEachNodeAttributes=function(t,e){if("function"!=typeof t)throw new F("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!g(e))throw new F("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i=this._nodes.values();!0!==(n=i.next()).done;)(r=n.value).attributes=t(r.key,r.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})},i.updateEachEdgeAttributes=function(t,e){if("function"!=typeof t)throw new F("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!g(e))throw new F("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var n,r,i,o,a=this._edges.values();!0!==(n=a.next()).done;)i=(r=n.value).source,o=r.target,r.attributes=t(r.key,r.attributes,i.key,o.key,i.attributes,o.attributes,r.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})},i.forEachAdjacencyEntry=function(t){if("function"!=typeof t)throw new F("Graph.forEachAdjacencyEntry: expecting a callback.");Et(!1,!1,!1,this,t)},i.forEachAdjacencyEntryWithOrphans=function(t){if("function"!=typeof t)throw new F("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");Et(!1,!1,!0,this,t)},i.forEachAssymetricAdjacencyEntry=function(t){if("function"!=typeof t)throw new F("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");Et(!1,!0,!1,this,t)},i.forEachAssymetricAdjacencyEntryWithOrphans=function(t){if("function"!=typeof t)throw new F("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");Et(!1,!0,!0,this,t)},i.nodes=function(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):T(this._nodes.keys(),this._nodes.size)},i.forEachNode=function(t){if("function"!=typeof t)throw new F("Graph.forEachNode: expecting a callback.");for(var e,n,r=this._nodes.values();!0!==(e=r.next()).done;)t((n=e.value).key,n.attributes)},i.findNode=function(t){if("function"!=typeof t)throw new F("Graph.findNode: expecting a callback.");for(var e,n,r=this._nodes.values();!0!==(e=r.next()).done;)if(t((n=e.value).key,n.attributes))return n.key},i.mapNodes=function(t){if("function"!=typeof t)throw new F("Graph.mapNode: expecting a callback.");for(var e,n,r=this._nodes.values(),i=new Array(this.order),o=0;!0!==(e=r.next()).done;)n=e.value,i[o++]=t(n.key,n.attributes);return i},i.someNode=function(t){if("function"!=typeof t)throw new F("Graph.someNode: expecting a callback.");for(var e,n,r=this._nodes.values();!0!==(e=r.next()).done;)if(t((n=e.value).key,n.attributes))return!0;return!1},i.everyNode=function(t){if("function"!=typeof t)throw new F("Graph.everyNode: expecting a callback.");for(var e,n,r=this._nodes.values();!0!==(e=r.next()).done;)if(!t((n=e.value).key,n.attributes))return!1;return!0},i.filterNodes=function(t){if("function"!=typeof t)throw new F("Graph.filterNodes: expecting a callback.");for(var e,n,r=this._nodes.values(),i=[];!0!==(e=r.next()).done;)t((n=e.value).key,n.attributes)&&i.push(n.key);return i},i.reduceNodes=function(t,e){if("function"!=typeof t)throw new F("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new F("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var n,r,i=e,o=this._nodes.values();!0!==(n=o.next()).done;)i=t(i,(r=n.value).key,r.attributes);return i},i.nodeEntries=function(){var t=this._nodes.values();return new O((function(){var e=t.next();if(e.done)return e;var n=e.value;return{value:{node:n.key,attributes:n.attributes},done:!1}}))},i.export=function(){var t=new Array(this._nodes.size),e=0;this._nodes.forEach((function(n,r){t[e++]=function(t,e){var n={key:t};return p(e.attributes)||(n.attributes=c({},e.attributes)),n}(r,n)}));var n=new Array(this._edges.size);return e=0,this._edges.forEach((function(t,r){n[e++]=function(t,e){var n={key:t,source:e.source.key,target:e.target.key};return p(e.attributes)||(n.attributes=c({},e.attributes)),e.undirected&&(n.undirected=!0),n}(r,t)})),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:n}},i.import=function(t){var e,n,r,i,o,a=this,u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(d(t))return t.forEachNode((function(t,e){u?a.mergeNode(t,e):a.addNode(t,e)})),t.forEachEdge((function(t,e,n,r,i,o,c){u?c?a.mergeUndirectedEdgeWithKey(t,n,r,e):a.mergeDirectedEdgeWithKey(t,n,r,e):c?a.addUndirectedEdgeWithKey(t,n,r,e):a.addDirectedEdgeWithKey(t,n,r,e)})),this;if(!h(t))throw new F("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!h(t.attributes))throw new F("Graph.import: invalid attributes. Expecting a plain object.");u?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}if(t.nodes){if(r=t.nodes,!Array.isArray(r))throw new F("Graph.import: invalid nodes. Expecting an array.");for(e=0,n=r.length;e<n;e++){At(i=r[e]);var c=i,s=c.key,p=c.attributes;u?this.mergeNode(s,p):this.addNode(s,p)}}if(t.edges){if(r=t.edges,!Array.isArray(r))throw new F("Graph.import: invalid edges. Expecting an array.");for(e=0,n=r.length;e<n;e++){St(o=r[e]);var f=o,l=f.source,g=f.target,y=f.attributes,w=f.undirected,v=void 0!==w&&w;"key"in o?(u?v?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:v?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,o.key,l,g,y):(u?v?this.mergeUndirectedEdge:this.mergeDirectedEdge:v?this.addUndirectedEdge:this.addDirectedEdge).call(this,l,g,y)}}return this},i.nullCopy=function(t){var e=new r(c({},this._options,t));return e.replaceAttributes(c({},this.getAttributes())),e},i.emptyCopy=function(t){var e=this.nullCopy(t);return this._nodes.forEach((function(t,n){var r=c({},t.attributes);t=new e.NodeDataClass(n,r),e._nodes.set(n,t)})),e},i.copy=function(t){if("string"==typeof(t=t||{}).type&&t.type!==this.type&&"mixed"!==t.type)throw new Y('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(t.type,'" because this would mean losing information about the current graph.'));if("boolean"==typeof t.multi&&t.multi!==this.multi&&!0!==t.multi)throw new Y("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof t.allowSelfLoops&&t.allowSelfLoops!==this.allowSelfLoops&&!0!==t.allowSelfLoops)throw new Y("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var e,n,r=this.emptyCopy(t),i=this._edges.values();!0!==(e=i.next()).done;)Ct(r,"copy",!1,(n=e.value).undirected,n.key,n.source.key,n.target.key,c({},n.attributes));return r},i.toJSON=function(){return this.export()},i.toString=function(){return"[object Graph]"},i.inspect=function(){var e=this,n={};this._nodes.forEach((function(t,e){n[e]=t.attributes}));var r={},i={};this._edges.forEach((function(t,n){var o,a=t.undirected?"--":"->",u="",c=t.source.key,s=t.target.key;t.undirected&&c>s&&(o=c,c=s,s=o);var d="(".concat(c,")").concat(a,"(").concat(s,")");n.startsWith("geid_")?e.multi&&(void 0===i[d]?i[d]=0:i[d]++,u+="".concat(i[d],". ")):u+="[".concat(n,"]: "),r[u+=d]=t.attributes}));var o={};for(var a in this)this.hasOwnProperty(a)&&!Nt.has(a)&&"function"!=typeof this[a]&&"symbol"!==t(a)&&(o[a]=this[a]);return o.attributes=this._attributes,o.nodes=n,o.edges=r,f(o,"constructor",this.constructor),o},r}(w.exports.EventEmitter);"undefined"!=typeof Symbol&&(Wt.prototype[Symbol.for("nodejs.util.inspect.custom")]=Wt.prototype.inspect),[{name:function(t){return"".concat(t,"Edge")},generateKey:!0},{name:function(t){return"".concat(t,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(t){return"".concat(t,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(t){return"".concat(t,"EdgeWithKey")}},{name:function(t){return"".concat(t,"DirectedEdgeWithKey")},type:"directed"},{name:function(t){return"".concat(t,"UndirectedEdgeWithKey")},type:"undirected"}].forEach((function(t){["add","merge","update"].forEach((function(e){var n=t.name(e),r="add"===e?Ct:zt;t.generateKey?Wt.prototype[n]=function(i,o,a){return r(this,n,!0,"undirected"===(t.type||this.type),null,i,o,a,"update"===e)}:Wt.prototype[n]=function(i,o,a,u){return r(this,n,!1,"undirected"===(t.type||this.type),i,o,a,u,"update"===e)}}))})),function(t){X.forEach((function(e){var n=e.name,r=e.attacher;r(t,n("Node"),0),r(t,n("Source"),1),r(t,n("Target"),2),r(t,n("Opposite"),3)}))}(Wt),function(t){Z.forEach((function(e){var n=e.name,r=e.attacher;r(t,n("Edge"),"mixed"),r(t,n("DirectedEdge"),"directed"),r(t,n("UndirectedEdge"),"undirected")}))}(Wt),function(t){nt.forEach((function(e){!function(t,e){var n=e.name,r=e.type,i=e.direction;t.prototype[n]=function(t,e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return st(this,r);if(1===arguments.length){t=""+t;var o=this._nodes.get(t);if(void 0===o)throw new I("Graph.".concat(n,': could not find the "').concat(t,'" node in the graph.'));return ft(this.multi,"mixed"===r?this.type:r,i,o)}if(2===arguments.length){t=""+t,e=""+e;var a=this._nodes.get(t);if(!a)throw new I("Graph.".concat(n,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I("Graph.".concat(n,':  could not find the "').concat(e,'" target node in the graph.'));return yt(r,this.multi,i,a,e)}throw new F("Graph.".concat(n,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e,n){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return dt(!1,this,r,n=t);if(2===arguments.length){t=""+t,n=e;var a=this._nodes.get(t);if(void 0===a)throw new I("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return pt(!1,this.multi,"mixed"===r?this.type:r,i,a,n)}if(3===arguments.length){t=""+t,e=""+e;var u=this._nodes.get(t);if(!u)throw new I("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return gt(!1,r,this.multi,i,u,e,n)}throw new F("Graph.".concat(o,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var a="map"+n[0].toUpperCase()+n.slice(1);t.prototype[a]=function(){var t,e=Array.prototype.slice.call(arguments),n=e.pop();if(0===e.length){var i=0;"directed"!==r&&(i+=this.undirectedSize),"undirected"!==r&&(i+=this.directedSize),t=new Array(i);var a=0;e.push((function(e,r,i,o,u,c,s){t[a++]=n(e,r,i,o,u,c,s)}))}else t=[],e.push((function(e,r,i,o,a,u,c){t.push(n(e,r,i,o,a,u,c))}));return this[o].apply(this,e),t};var u="filter"+n[0].toUpperCase()+n.slice(1);t.prototype[u]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop(),n=[];return t.push((function(t,r,i,o,a,u,c){e(t,r,i,o,a,u,c)&&n.push(t)})),this[o].apply(this,t),n};var c="reduce"+n[0].toUpperCase()+n.slice(1);t.prototype[c]=function(){var t,e,n=Array.prototype.slice.call(arguments);if(n.length<2||n.length>4)throw new F("Graph.".concat(c,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n.length,")."));if("function"==typeof n[n.length-1]&&"function"!=typeof n[n.length-2])throw new F("Graph.".concat(c,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));2===n.length?(t=n[0],e=n[1],n=[]):3===n.length?(t=n[1],e=n[2],n=[n[0]]):4===n.length&&(t=n[2],e=n[3],n=[n[0],n[1]]);var r=e;return n.push((function(e,n,i,o,a,u,c){r=t(r,e,n,i,o,a,u,c)})),this[o].apply(this,n),r}}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="find"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e,n){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return!1;if(1===arguments.length)return dt(!0,this,r,n=t);if(2===arguments.length){t=""+t,n=e;var a=this._nodes.get(t);if(void 0===a)throw new I("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return pt(!0,this.multi,"mixed"===r?this.type:r,i,a,n)}if(3===arguments.length){t=""+t,e=""+e;var u=this._nodes.get(t);if(!u)throw new I("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return gt(!0,r,this.multi,i,u,e,n)}throw new F("Graph.".concat(o,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var a="some"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[a]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop();return t.push((function(t,n,r,i,o,a,u){return e(t,n,r,i,o,a,u)})),!!this[o].apply(this,t)};var u="every"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[u]=function(){var t=Array.prototype.slice.call(arguments),e=t.pop();return t.push((function(t,n,r,i,o,a,u){return!e(t,n,r,i,o,a,u)})),!this[o].apply(this,t)}}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o=n.slice(0,-1)+"Entries";t.prototype[o]=function(t,e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return O.empty();if(!arguments.length)return ht(this,r);if(1===arguments.length){t=""+t;var n=this._nodes.get(t);if(!n)throw new I("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));return lt(r,i,n)}if(2===arguments.length){t=""+t,e=""+e;var a=this._nodes.get(t);if(!a)throw new I("Graph.".concat(o,':  could not find the "').concat(t,'" source node in the graph.'));if(!this._nodes.has(e))throw new I("Graph.".concat(o,':  could not find the "').concat(e,'" target node in the graph.'));return wt(r,i,a,e)}throw new F("Graph.".concat(o,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(t,e)}))}(Wt),function(t){vt.forEach((function(e){Gt(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);t.prototype[o]=function(t,e){if("mixed"===r||"mixed"===this.type||r===this.type){t=""+t;var n=this._nodes.get(t);if(void 0===n)throw new I("Graph.".concat(o,': could not find the "').concat(t,'" node in the graph.'));kt(!1,"mixed"===r?this.type:r,i,n,e)}};var a="map"+n[0].toUpperCase()+n.slice(1);t.prototype[a]=function(t,e){var n=[];return this[o](t,(function(t,r){n.push(e(t,r))})),n};var u="filter"+n[0].toUpperCase()+n.slice(1);t.prototype[u]=function(t,e){var n=[];return this[o](t,(function(t,r){e(t,r)&&n.push(t)})),n};var c="reduce"+n[0].toUpperCase()+n.slice(1);t.prototype[c]=function(t,e,n){if(arguments.length<3)throw new F("Graph.".concat(c,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var r=n;return this[o](t,(function(t,n){r=e(r,t,n)})),r}}(t,e),function(t,e){var n=e.name,r=e.type,i=e.direction,o=n[0].toUpperCase()+n.slice(1,-1),a="find"+o;t.prototype[a]=function(t,e){if("mixed"===r||"mixed"===this.type||r===this.type){t=""+t;var n=this._nodes.get(t);if(void 0===n)throw new I("Graph.".concat(a,': could not find the "').concat(t,'" node in the graph.'));return kt(!0,"mixed"===r?this.type:r,i,n,e)}};var u="some"+o;t.prototype[u]=function(t,e){return!!this[a](t,e)};var c="every"+o;t.prototype[c]=function(t,e){return!this[a](t,(function(t,n){return!e(t,n)}))}}(t,e),xt(t,e)}))}(Wt);var Pt=function(t){function n(e){var n=c({type:"directed"},e);if("multi"in n&&!1!==n.multi)throw new F("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==n.type)throw new F('DirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(Wt),Rt=function(t){function n(e){var n=c({type:"undirected"},e);if("multi"in n&&!1!==n.multi)throw new F("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==n.type)throw new F('UndirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(Wt),Kt=function(t){function n(e){var n=c({multi:!0},e);if("multi"in n&&!0!==n.multi)throw new F("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return t.call(this,n)||this}return e(n,t),n}(Wt),Tt=function(t){function n(e){var n=c({type:"directed",multi:!0},e);if("multi"in n&&!0!==n.multi)throw new F("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==n.type)throw new F('MultiDirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(Wt),Bt=function(t){function n(e){var n=c({type:"undirected",multi:!0},e);if("multi"in n&&!0!==n.multi)throw new F("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==n.type)throw new F('MultiUndirectedGraph.from: inconsistent "'+n.type+'" type in given options!');return t.call(this,n)||this}return e(n,t),n}(Wt);function Ft(t){t.from=function(e,n){var r=c({},e.options,n),i=new t(r);return i.import(e),i}}return Ft(Wt),Ft(Pt),Ft(Rt),Ft(Kt),Ft(Tt),Ft(Bt),Wt.Graph=Wt,Wt.DirectedGraph=Pt,Wt.UndirectedGraph=Rt,Wt.MultiGraph=Kt,Wt.MultiDirectedGraph=Tt,Wt.MultiUndirectedGraph=Bt,Wt.InvalidArgumentsGraphError=F,Wt.NotFoundGraphError=I,Wt.UsageGraphError=Y,Wt}));
//# sourceMappingURL=graphology.umd.min.js.map


/***/ }),

/***/ "./node_modules/pandemonium/random.js":
/*!********************************************!*\
  !*** ./node_modules/pandemonium/random.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Pandemonium Random
 * ===================
 *
 * Random function.
 */

/**
 * Creating a function returning a random integer such as a <= N <= b.
 *
 * @param  {function} rng - RNG function returning uniform random.
 * @return {function}     - The created function.
 */
function createRandom(rng) {

  /**
   * Random function.
   *
   * @param  {number} a - From.
   * @param  {number} b - To.
   * @return {number}
   */
  return function(a, b) {
    return a + Math.floor(rng() * (b - a + 1));
  };
}

/**
 * Default random using `Math.random`.
 */
var random = createRandom(Math.random);

/**
 * Exporting.
 */
random.createRandom = createRandom;
module.exports = random;


/***/ }),

/***/ "./node_modules/pandemonium/shuffle-in-place.js":
/*!******************************************************!*\
  !*** ./node_modules/pandemonium/shuffle-in-place.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Pandemonium Shuffle In Place
 * =============================
 *
 * Shuffle function applying the Fisher-Yates algorithm to the provided array.
 */
var createRandom = (__webpack_require__(/*! ./random.js */ "./node_modules/pandemonium/random.js").createRandom);

/**
 * Creating a function returning the given array shuffled.
 *
 * @param  {function} rng - The RNG to use.
 * @return {function}     - The created function.
 */
function createShuffleInPlace(rng) {
  var customRandom = createRandom(rng);

  /**
   * Function returning the shuffled array.
   *
   * @param  {array}  sequence - Target sequence.
   * @return {array}           - The shuffled sequence.
   */
  return function(sequence) {
    var length = sequence.length,
        lastIndex = length - 1;

    var index = -1;

    while (++index < length) {
      var r = customRandom(index, lastIndex),
          value = sequence[r];

      sequence[r] = sequence[index];
      sequence[index] = value;
    }
  };
}

/**
 * Default shuffle in place using `Math.random`.
 */
var shuffleInPlace = createShuffleInPlace(Math.random);

/**
 * Exporting.
 */
shuffleInPlace.createShuffleInPlace = createShuffleInPlace;
module.exports = shuffleInPlace;


/***/ }),

/***/ "./node_modules/sigma/core/camera.js":
/*!*******************************************!*\
  !*** ./node_modules/sigma/core/camera.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sigma.js Camera Class
 * ======================
 *
 * Class designed to store camera information & used to update it.
 * @module
 */
var animate_1 = __webpack_require__(/*! ../utils/animate */ "./node_modules/sigma/utils/animate.js");
var easings_1 = __importDefault(__webpack_require__(/*! ../utils/easings */ "./node_modules/sigma/utils/easings.js"));
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/sigma/utils/index.js");
var types_1 = __webpack_require__(/*! ../types */ "./node_modules/sigma/types.js");
/**
 * Defaults.
 */
var DEFAULT_ZOOMING_RATIO = 1.5;
/**
 * Camera class
 *
 * @constructor
 */
var Camera = /** @class */ (function (_super) {
    __extends(Camera, _super);
    function Camera() {
        var _this = _super.call(this) || this;
        _this.x = 0.5;
        _this.y = 0.5;
        _this.angle = 0;
        _this.ratio = 1;
        _this.minRatio = null;
        _this.maxRatio = null;
        _this.nextFrame = null;
        _this.previousState = null;
        _this.enabled = true;
        // State
        _this.previousState = _this.getState();
        return _this;
    }
    /**
     * Static method used to create a Camera object with a given state.
     *
     * @param state
     * @return {Camera}
     */
    Camera.from = function (state) {
        var camera = new Camera();
        return camera.setState(state);
    };
    /**
     * Method used to enable the camera.
     *
     * @return {Camera}
     */
    Camera.prototype.enable = function () {
        this.enabled = true;
        return this;
    };
    /**
     * Method used to disable the camera.
     *
     * @return {Camera}
     */
    Camera.prototype.disable = function () {
        this.enabled = false;
        return this;
    };
    /**
     * Method used to retrieve the camera's current state.
     *
     * @return {object}
     */
    Camera.prototype.getState = function () {
        return {
            x: this.x,
            y: this.y,
            angle: this.angle,
            ratio: this.ratio,
        };
    };
    /**
     * Method used to check whether the camera has the given state.
     *
     * @return {object}
     */
    Camera.prototype.hasState = function (state) {
        return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;
    };
    /**
     * Method used to retrieve the camera's previous state.
     *
     * @return {object}
     */
    Camera.prototype.getPreviousState = function () {
        var state = this.previousState;
        if (!state)
            return null;
        return {
            x: state.x,
            y: state.y,
            angle: state.angle,
            ratio: state.ratio,
        };
    };
    /**
     * Method used to check minRatio and maxRatio values.
     *
     * @param ratio
     * @return {number}
     */
    Camera.prototype.getBoundedRatio = function (ratio) {
        var r = ratio;
        if (typeof this.minRatio === "number")
            r = Math.max(r, this.minRatio);
        if (typeof this.maxRatio === "number")
            r = Math.min(r, this.maxRatio);
        return r;
    };
    /**
     * Method used to check various things to return a legit state candidate.
     *
     * @param state
     * @return {object}
     */
    Camera.prototype.validateState = function (state) {
        var validatedState = {};
        if (typeof state.x === "number")
            validatedState.x = state.x;
        if (typeof state.y === "number")
            validatedState.y = state.y;
        if (typeof state.angle === "number")
            validatedState.angle = state.angle;
        if (typeof state.ratio === "number")
            validatedState.ratio = this.getBoundedRatio(state.ratio);
        return validatedState;
    };
    /**
     * Method used to check whether the camera is currently being animated.
     *
     * @return {boolean}
     */
    Camera.prototype.isAnimated = function () {
        return !!this.nextFrame;
    };
    /**
     * Method used to set the camera's state.
     *
     * @param  {object} state - New state.
     * @return {Camera}
     */
    Camera.prototype.setState = function (state) {
        if (!this.enabled)
            return this;
        // TODO: update by function
        // Keeping track of last state
        this.previousState = this.getState();
        var validState = this.validateState(state);
        if (typeof validState.x === "number")
            this.x = validState.x;
        if (typeof validState.y === "number")
            this.y = validState.y;
        if (typeof validState.angle === "number")
            this.angle = validState.angle;
        if (typeof validState.ratio === "number")
            this.ratio = validState.ratio;
        // Emitting
        if (!this.hasState(this.previousState))
            this.emit("updated", this.getState());
        return this;
    };
    /**
     * Method used to animate the camera.
     *
     * @param  {object}                    state      - State to reach eventually.
     * @param  {object}                    opts       - Options:
     * @param  {number}                      duration - Duration of the animation.
     * @param  {string | number => number}   easing   - Easing function or name of an existing one
     * @param  {function}                  callback   - Callback
     */
    Camera.prototype.animate = function (state, opts, callback) {
        var _this = this;
        if (!this.enabled)
            return;
        var options = Object.assign({}, animate_1.ANIMATE_DEFAULTS, opts);
        var validState = this.validateState(state);
        var easing = typeof options.easing === "function" ? options.easing : easings_1.default[options.easing];
        // State
        var start = Date.now(), initialState = this.getState();
        // Function performing the animation
        var fn = function () {
            var t = (Date.now() - start) / options.duration;
            // The animation is over:
            if (t >= 1) {
                _this.nextFrame = null;
                _this.setState(validState);
                if (_this.animationCallback) {
                    _this.animationCallback.call(null);
                    _this.animationCallback = undefined;
                }
                return;
            }
            var coefficient = easing(t);
            var newState = {};
            if (typeof validState.x === "number")
                newState.x = initialState.x + (validState.x - initialState.x) * coefficient;
            if (typeof validState.y === "number")
                newState.y = initialState.y + (validState.y - initialState.y) * coefficient;
            if (typeof validState.angle === "number")
                newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;
            if (typeof validState.ratio === "number")
                newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;
            _this.setState(newState);
            _this.nextFrame = (0, utils_1.requestFrame)(fn);
        };
        if (this.nextFrame) {
            (0, utils_1.cancelFrame)(this.nextFrame);
            if (this.animationCallback)
                this.animationCallback.call(null);
            this.nextFrame = (0, utils_1.requestFrame)(fn);
        }
        else {
            fn();
        }
        this.animationCallback = callback;
    };
    /**
     * Method used to zoom the camera.
     *
     * @param  {number|object} factorOrOptions - Factor or options.
     * @return {function}
     */
    Camera.prototype.animatedZoom = function (factorOrOptions) {
        if (!factorOrOptions) {
            this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });
        }
        else {
            if (typeof factorOrOptions === "number")
                return this.animate({ ratio: this.ratio / factorOrOptions });
            else
                this.animate({
                    ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),
                }, factorOrOptions);
        }
    };
    /**
     * Method used to unzoom the camera.
     *
     * @param  {number|object} factorOrOptions - Factor or options.
     */
    Camera.prototype.animatedUnzoom = function (factorOrOptions) {
        if (!factorOrOptions) {
            this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });
        }
        else {
            if (typeof factorOrOptions === "number")
                return this.animate({ ratio: this.ratio * factorOrOptions });
            else
                this.animate({
                    ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),
                }, factorOrOptions);
        }
    };
    /**
     * Method used to reset the camera.
     *
     * @param  {object} options - Options.
     */
    Camera.prototype.animatedReset = function (options) {
        this.animate({
            x: 0.5,
            y: 0.5,
            ratio: 1,
            angle: 0,
        }, options);
    };
    /**
     * Returns a new Camera instance, with the same state as the current camera.
     *
     * @return {Camera}
     */
    Camera.prototype.copy = function () {
        return Camera.from(this.getState());
    };
    return Camera;
}(types_1.TypedEventEmitter));
exports["default"] = Camera;


/***/ }),

/***/ "./node_modules/sigma/core/captors/captor.js":
/*!***************************************************!*\
  !*** ./node_modules/sigma/core/captors/captor.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWheelDelta = exports.getTouchCoords = exports.getTouchesArray = exports.getWheelCoords = exports.getMouseCoords = exports.getPosition = void 0;
/**
 * Sigma.js Captor Class
 * ======================
 * @module
 */
var types_1 = __webpack_require__(/*! ../../types */ "./node_modules/sigma/types.js");
/**
 * Captor utils functions
 * ======================
 */
/**
 * Extract the local X and Y coordinates from a mouse event or touch object. If
 * a DOM element is given, it uses this element's offset to compute the position
 * (this allows using events that are not bound to the container itself and
 * still have a proper position).
 *
 * @param  {event}       e - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {number}      The local Y value of the mouse.
 */
function getPosition(e, dom) {
    var bbox = dom.getBoundingClientRect();
    return {
        x: e.clientX - bbox.left,
        y: e.clientY - bbox.top,
    };
}
exports.getPosition = getPosition;
/**
 * Convert mouse coords to sigma coords.
 *
 * @param  {event}       e   - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getMouseCoords(e, dom) {
    var res = __assign(__assign({}, getPosition(e, dom)), { sigmaDefaultPrevented: false, preventSigmaDefault: function () {
            res.sigmaDefaultPrevented = true;
        }, original: e });
    return res;
}
exports.getMouseCoords = getMouseCoords;
/**
 * Convert mouse wheel event coords to sigma coords.
 *
 * @param  {event}       e   - A wheel mouse event.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getWheelCoords(e, dom) {
    return __assign(__assign({}, getMouseCoords(e, dom)), { delta: getWheelDelta(e) });
}
exports.getWheelCoords = getWheelCoords;
var MAX_TOUCHES = 2;
function getTouchesArray(touches) {
    var arr = [];
    for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++)
        arr.push(touches[i]);
    return arr;
}
exports.getTouchesArray = getTouchesArray;
/**
 * Convert touch coords to sigma coords.
 *
 * @param  {event}       e   - A touch event.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getTouchCoords(e, dom) {
    return {
        touches: getTouchesArray(e.touches).map(function (touch) { return getPosition(touch, dom); }),
        original: e,
    };
}
exports.getTouchCoords = getTouchCoords;
/**
 * Extract the wheel delta from a mouse event or touch object.
 *
 * @param  {event}  e - A mouse event or touch object.
 * @return {number}     The wheel delta of the mouse.
 */
function getWheelDelta(e) {
    // TODO: check those ratios again to ensure a clean Chrome/Firefox compat
    if (typeof e.deltaY !== "undefined")
        return (e.deltaY * -3) / 360;
    if (typeof e.detail !== "undefined")
        return e.detail / -9;
    throw new Error("Captor: could not extract delta from event.");
}
exports.getWheelDelta = getWheelDelta;
/**
 * Abstract class representing a captor like the user's mouse or touch controls.
 */
var Captor = /** @class */ (function (_super) {
    __extends(Captor, _super);
    function Captor(container, renderer) {
        var _this = _super.call(this) || this;
        // Properties
        _this.container = container;
        _this.renderer = renderer;
        return _this;
    }
    return Captor;
}(types_1.TypedEventEmitter));
exports["default"] = Captor;


/***/ }),

/***/ "./node_modules/sigma/core/captors/mouse.js":
/*!**************************************************!*\
  !*** ./node_modules/sigma/core/captors/mouse.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var captor_1 = __importStar(__webpack_require__(/*! ./captor */ "./node_modules/sigma/core/captors/captor.js"));
/**
 * Constants.
 */
var DRAG_TIMEOUT = 100;
var DRAGGED_EVENTS_TOLERANCE = 3;
var MOUSE_INERTIA_DURATION = 200;
var MOUSE_INERTIA_RATIO = 3;
var MOUSE_ZOOM_DURATION = 250;
var ZOOMING_RATIO = 1.7;
var DOUBLE_CLICK_TIMEOUT = 300;
var DOUBLE_CLICK_ZOOMING_RATIO = 2.2;
var DOUBLE_CLICK_ZOOMING_DURATION = 200;
/**
 * Mouse captor class.
 *
 * @constructor
 */
var MouseCaptor = /** @class */ (function (_super) {
    __extends(MouseCaptor, _super);
    function MouseCaptor(container, renderer) {
        var _this = _super.call(this, container, renderer) || this;
        // State
        _this.enabled = true;
        _this.draggedEvents = 0;
        _this.downStartTime = null;
        _this.lastMouseX = null;
        _this.lastMouseY = null;
        _this.isMouseDown = false;
        _this.isMoving = false;
        _this.movingTimeout = null;
        _this.startCameraState = null;
        _this.clicks = 0;
        _this.doubleClickTimeout = null;
        _this.currentWheelDirection = 0;
        // Binding methods
        _this.handleClick = _this.handleClick.bind(_this);
        _this.handleRightClick = _this.handleRightClick.bind(_this);
        _this.handleDown = _this.handleDown.bind(_this);
        _this.handleUp = _this.handleUp.bind(_this);
        _this.handleMove = _this.handleMove.bind(_this);
        _this.handleWheel = _this.handleWheel.bind(_this);
        _this.handleOut = _this.handleOut.bind(_this);
        // Binding events
        container.addEventListener("click", _this.handleClick, false);
        container.addEventListener("contextmenu", _this.handleRightClick, false);
        container.addEventListener("mousedown", _this.handleDown, false);
        container.addEventListener("wheel", _this.handleWheel, false);
        container.addEventListener("mouseout", _this.handleOut, false);
        document.addEventListener("mousemove", _this.handleMove, false);
        document.addEventListener("mouseup", _this.handleUp, false);
        return _this;
    }
    MouseCaptor.prototype.kill = function () {
        var container = this.container;
        container.removeEventListener("click", this.handleClick);
        container.removeEventListener("contextmenu", this.handleRightClick);
        container.removeEventListener("mousedown", this.handleDown);
        container.removeEventListener("wheel", this.handleWheel);
        container.removeEventListener("mouseout", this.handleOut);
        document.removeEventListener("mousemove", this.handleMove);
        document.removeEventListener("mouseup", this.handleUp);
    };
    MouseCaptor.prototype.handleClick = function (e) {
        var _this = this;
        if (!this.enabled)
            return;
        this.clicks++;
        if (this.clicks === 2) {
            this.clicks = 0;
            if (typeof this.doubleClickTimeout === "number") {
                clearTimeout(this.doubleClickTimeout);
                this.doubleClickTimeout = null;
            }
            return this.handleDoubleClick(e);
        }
        setTimeout(function () {
            _this.clicks = 0;
            _this.doubleClickTimeout = null;
        }, DOUBLE_CLICK_TIMEOUT);
        // NOTE: this is here to prevent click events on drag
        if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE)
            this.emit("click", (0, captor_1.getMouseCoords)(e, this.container));
    };
    MouseCaptor.prototype.handleRightClick = function (e) {
        if (!this.enabled)
            return;
        this.emit("rightClick", (0, captor_1.getMouseCoords)(e, this.container));
    };
    MouseCaptor.prototype.handleDoubleClick = function (e) {
        if (!this.enabled)
            return;
        e.preventDefault();
        e.stopPropagation();
        var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container);
        this.emit("doubleClick", mouseCoords);
        if (mouseCoords.sigmaDefaultPrevented)
            return;
        // default behavior
        var camera = this.renderer.getCamera();
        var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);
        camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {
            easing: "quadraticInOut",
            duration: DOUBLE_CLICK_ZOOMING_DURATION,
        });
    };
    MouseCaptor.prototype.handleDown = function (e) {
        if (!this.enabled)
            return;
        this.startCameraState = this.renderer.getCamera().getState();
        var _a = (0, captor_1.getPosition)(e, this.container), x = _a.x, y = _a.y;
        this.lastMouseX = x;
        this.lastMouseY = y;
        this.draggedEvents = 0;
        this.downStartTime = Date.now();
        // TODO: dispatch events
        // Left button pressed
        this.isMouseDown = true;
        this.emit("mousedown", (0, captor_1.getMouseCoords)(e, this.container));
    };
    MouseCaptor.prototype.handleUp = function (e) {
        var _this = this;
        if (!this.enabled || !this.isMouseDown)
            return;
        var camera = this.renderer.getCamera();
        this.isMouseDown = false;
        if (typeof this.movingTimeout === "number") {
            clearTimeout(this.movingTimeout);
            this.movingTimeout = null;
        }
        var _a = (0, captor_1.getPosition)(e, this.container), x = _a.x, y = _a.y;
        var cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };
        if (this.isMoving) {
            camera.animate({
                x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),
                y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y),
            }, {
                duration: MOUSE_INERTIA_DURATION,
                easing: "quadraticOut",
            });
        }
        else if (this.lastMouseX !== x || this.lastMouseY !== y) {
            camera.setState({
                x: cameraState.x,
                y: cameraState.y,
            });
        }
        this.isMoving = false;
        setTimeout(function () {
            _this.draggedEvents = 0;
            _this.renderer.refresh();
        }, 0);
        this.emit("mouseup", (0, captor_1.getMouseCoords)(e, this.container));
    };
    MouseCaptor.prototype.handleMove = function (e) {
        var _this = this;
        if (!this.enabled)
            return;
        var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container);
        // Always trigger a "mousemovebody" event, so that it is possible to develop
        // a drag-and-drop effect that works even when the mouse is out of the
        // container:
        this.emit("mousemovebody", mouseCoords);
        // Only trigger the "mousemove" event when the mouse is actually hovering
        // the container, to avoid weirdly hovering nodes and/or edges when the
        // mouse is not hover the container:
        if (e.target === this.container) {
            this.emit("mousemove", mouseCoords);
        }
        if (mouseCoords.sigmaDefaultPrevented)
            return;
        // Handle the case when "isMouseDown" all the time, to allow dragging the
        // stage while the mouse is not hover the container:
        if (this.isMouseDown) {
            this.isMoving = true;
            this.draggedEvents++;
            if (typeof this.movingTimeout === "number") {
                clearTimeout(this.movingTimeout);
            }
            this.movingTimeout = window.setTimeout(function () {
                _this.movingTimeout = null;
                _this.isMoving = false;
            }, DRAG_TIMEOUT);
            var camera = this.renderer.getCamera();
            var _a = (0, captor_1.getPosition)(e, this.container), eX = _a.x, eY = _a.y;
            var lastMouse = this.renderer.viewportToFramedGraph({
                x: this.lastMouseX,
                y: this.lastMouseY,
            });
            var mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });
            var offsetX = lastMouse.x - mouse.x, offsetY = lastMouse.y - mouse.y;
            var cameraState = camera.getState();
            var x = cameraState.x + offsetX, y = cameraState.y + offsetY;
            camera.setState({ x: x, y: y });
            this.lastMouseX = eX;
            this.lastMouseY = eY;
            e.preventDefault();
            e.stopPropagation();
        }
    };
    MouseCaptor.prototype.handleWheel = function (e) {
        var _this = this;
        if (!this.enabled)
            return;
        e.preventDefault();
        e.stopPropagation();
        var delta = (0, captor_1.getWheelDelta)(e);
        if (!delta)
            return;
        var wheelCoords = (0, captor_1.getWheelCoords)(e, this.container);
        this.emit("wheel", wheelCoords);
        if (wheelCoords.sigmaDefaultPrevented)
            return;
        // Default behavior
        var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;
        var camera = this.renderer.getCamera();
        var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);
        var wheelDirection = delta > 0 ? 1 : -1;
        var now = Date.now();
        // Cancel events that are too close too each other and in the same direction:
        if (this.currentWheelDirection === wheelDirection &&
            this.lastWheelTriggerTime &&
            now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {
            return;
        }
        camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {
            easing: "quadraticOut",
            duration: MOUSE_ZOOM_DURATION,
        }, function () {
            _this.currentWheelDirection = 0;
        });
        this.currentWheelDirection = wheelDirection;
        this.lastWheelTriggerTime = now;
    };
    MouseCaptor.prototype.handleOut = function () {
        // TODO: dispatch event
    };
    return MouseCaptor;
}(captor_1.default));
exports["default"] = MouseCaptor;


/***/ }),

/***/ "./node_modules/sigma/core/captors/touch.js":
/*!**************************************************!*\
  !*** ./node_modules/sigma/core/captors/touch.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var captor_1 = __importStar(__webpack_require__(/*! ./captor */ "./node_modules/sigma/core/captors/captor.js"));
var DRAG_TIMEOUT = 200;
var TOUCH_INERTIA_RATIO = 3;
var TOUCH_INERTIA_DURATION = 200;
/**
 * Touch captor class.
 *
 * @constructor
 */
var TouchCaptor = /** @class */ (function (_super) {
    __extends(TouchCaptor, _super);
    function TouchCaptor(container, renderer) {
        var _this = _super.call(this, container, renderer) || this;
        _this.enabled = true;
        _this.isMoving = false;
        _this.touchMode = 0; // number of touches down
        // Binding methods:
        _this.handleStart = _this.handleStart.bind(_this);
        _this.handleLeave = _this.handleLeave.bind(_this);
        _this.handleMove = _this.handleMove.bind(_this);
        // Binding events
        container.addEventListener("touchstart", _this.handleStart, false);
        container.addEventListener("touchend", _this.handleLeave, false);
        container.addEventListener("touchcancel", _this.handleLeave, false);
        container.addEventListener("touchmove", _this.handleMove, false);
        return _this;
    }
    TouchCaptor.prototype.kill = function () {
        var container = this.container;
        container.removeEventListener("touchstart", this.handleStart);
        container.removeEventListener("touchend", this.handleLeave);
        container.removeEventListener("touchcancel", this.handleLeave);
        container.removeEventListener("touchmove", this.handleMove);
    };
    TouchCaptor.prototype.getDimensions = function () {
        return {
            width: this.container.offsetWidth,
            height: this.container.offsetHeight,
        };
    };
    TouchCaptor.prototype.dispatchRelatedMouseEvent = function (type, e, position, emitter) {
        var mousePosition = position || (0, captor_1.getPosition)(e.touches[0], this.container);
        var mouseEvent = new MouseEvent(type, {
            clientX: mousePosition.x,
            clientY: mousePosition.y,
            altKey: e.altKey,
            ctrlKey: e.ctrlKey,
        });
        mouseEvent.isFakeSigmaMouseEvent = true;
        (emitter || this.container).dispatchEvent(mouseEvent);
    };
    TouchCaptor.prototype.handleStart = function (e) {
        var _this = this;
        if (!this.enabled)
            return;
        // Prevent default to avoid default browser behaviors...
        e.preventDefault();
        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:
        if (e.touches.length === 1)
            this.dispatchRelatedMouseEvent("mousedown", e);
        var touches = (0, captor_1.getTouchesArray)(e.touches);
        this.isMoving = true;
        this.touchMode = touches.length;
        this.startCameraState = this.renderer.getCamera().getState();
        this.startTouchesPositions = touches.map(function (touch) { return (0, captor_1.getPosition)(touch, _this.container); });
        this.lastTouchesPositions = this.startTouchesPositions;
        // When there are two touches down, let's record distance and angle as well:
        if (this.touchMode === 2) {
            var _a = __read(this.startTouchesPositions, 2), _b = _a[0], x0 = _b.x, y0 = _b.y, _c = _a[1], x1 = _c.x, y1 = _c.y;
            this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);
            this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
        }
        this.emit("touchdown", (0, captor_1.getTouchCoords)(e, this.container));
    };
    TouchCaptor.prototype.handleLeave = function (e) {
        if (!this.enabled)
            return;
        // Prevent default to avoid default browser behaviors...
        e.preventDefault();
        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:
        if (e.touches.length === 0 && this.lastTouchesPositions && this.lastTouchesPositions.length) {
            this.dispatchRelatedMouseEvent("mouseup", e, this.lastTouchesPositions[0], document);
            this.dispatchRelatedMouseEvent("click", e, this.lastTouchesPositions[0]);
        }
        if (this.movingTimeout) {
            this.isMoving = false;
            clearTimeout(this.movingTimeout);
        }
        switch (this.touchMode) {
            case 2:
                if (e.touches.length === 1) {
                    this.handleStart(e);
                    e.preventDefault();
                    break;
                }
            /* falls through */
            case 1:
                // TODO
                // Dispatch event
                if (this.isMoving) {
                    var camera = this.renderer.getCamera();
                    var cameraState = camera.getState(), previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };
                    camera.animate({
                        x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),
                        y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y),
                    }, {
                        duration: TOUCH_INERTIA_DURATION,
                        easing: "quadraticOut",
                    });
                }
                this.isMoving = false;
                this.touchMode = 0;
                break;
        }
        this.emit("touchup", (0, captor_1.getTouchCoords)(e, this.container));
    };
    TouchCaptor.prototype.handleMove = function (e) {
        var _a;
        var _this = this;
        if (!this.enabled)
            return;
        // Prevent default to avoid default browser behaviors...
        e.preventDefault();
        // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:
        if (e.touches.length === 1)
            this.dispatchRelatedMouseEvent("mousemove", e);
        var camera = this.renderer.getCamera();
        var startCameraState = this.startCameraState;
        var touches = (0, captor_1.getTouchesArray)(e.touches);
        var touchesPositions = touches.map(function (touch) { return (0, captor_1.getPosition)(touch, _this.container); });
        this.lastTouchesPositions = touchesPositions;
        this.isMoving = true;
        if (this.movingTimeout)
            clearTimeout(this.movingTimeout);
        this.movingTimeout = window.setTimeout(function () {
            _this.isMoving = false;
        }, DRAG_TIMEOUT);
        switch (this.touchMode) {
            case 1: {
                var _b = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]), xStart = _b.x, yStart = _b.y;
                var _c = this.renderer.viewportToFramedGraph(touchesPositions[0]), x = _c.x, y = _c.y;
                camera.setState({
                    x: startCameraState.x + xStart - x,
                    y: startCameraState.y + yStart - y,
                });
                break;
            }
            case 2: {
                /**
                 * Here is the thinking here:
                 *
                 * 1. We can find the new angle and ratio, by comparing the vector from "touch one" to "touch two" at the start
                 *    of the d'n'd and now
                 *
                 * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph
                 *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport
                 *    position of this same touch now
                 */
                var newCameraState = {};
                var _d = touchesPositions[0], x0 = _d.x, y0 = _d.y;
                var _e = touchesPositions[1], x1 = _e.x, y1 = _e.y;
                var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;
                var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;
                // 1.
                var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);
                newCameraState.ratio = newRatio;
                newCameraState.angle = startCameraState.angle + angleDiff;
                // 2.
                var dimensions = this.getDimensions();
                var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], { cameraState: startCameraState });
                var smallestDimension = Math.min(dimensions.width, dimensions.height);
                var dx = smallestDimension / dimensions.width;
                var dy = smallestDimension / dimensions.height;
                var ratio = newRatio / smallestDimension;
                // Align with center of the graph:
                var x = x0 - smallestDimension / 2 / dx;
                var y = y0 - smallestDimension / 2 / dy;
                // Rotate:
                _a = __read([
                    x * Math.cos(-newCameraState.angle) - y * Math.sin(-newCameraState.angle),
                    y * Math.cos(-newCameraState.angle) + x * Math.sin(-newCameraState.angle),
                ], 2), x = _a[0], y = _a[1];
                newCameraState.x = touchGraphPosition.x - x * ratio;
                newCameraState.y = touchGraphPosition.y + y * ratio;
                camera.setState(newCameraState);
                break;
            }
        }
        this.emit("touchmove", (0, captor_1.getTouchCoords)(e, this.container));
    };
    return TouchCaptor;
}(captor_1.default));
exports["default"] = TouchCaptor;


/***/ }),

/***/ "./node_modules/sigma/core/labels.js":
/*!*******************************************!*\
  !*** ./node_modules/sigma/core/labels.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;
/**
 * Class representing a single candidate for the label grid selection.
 *
 * It also describes a deterministic way to compare two candidates to assess
 * which one is better.
 */
var LabelCandidate = /** @class */ (function () {
    function LabelCandidate(key, size) {
        this.key = key;
        this.size = size;
    }
    LabelCandidate.compare = function (first, second) {
        // First we compare by size
        if (first.size > second.size)
            return -1;
        if (first.size < second.size)
            return 1;
        // Then since no two nodes can have the same key, we use it to
        // deterministically tie-break by key
        if (first.key > second.key)
            return 1;
        // NOTE: this comparator cannot return 0
        return -1;
    };
    return LabelCandidate;
}());
/**
 * Class representing a 2D spatial grid divided into constant-size cells.
 */
var LabelGrid = /** @class */ (function () {
    function LabelGrid() {
        this.width = 0;
        this.height = 0;
        this.cellSize = 0;
        this.columns = 0;
        this.rows = 0;
        this.cells = {};
    }
    LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {
        this.width = dimensions.width;
        this.height = dimensions.height;
        this.cellSize = cellSize;
        this.columns = Math.ceil(dimensions.width / cellSize);
        this.rows = Math.ceil(dimensions.height / cellSize);
        this.cells = {};
    };
    LabelGrid.prototype.getIndex = function (pos) {
        var xIndex = Math.floor(pos.x / this.cellSize);
        var yIndex = Math.floor(pos.y / this.cellSize);
        return yIndex * this.columns + xIndex;
    };
    LabelGrid.prototype.add = function (key, size, pos) {
        var candidate = new LabelCandidate(key, size);
        var index = this.getIndex(pos);
        var cell = this.cells[index];
        if (!cell) {
            cell = [];
            this.cells[index] = cell;
        }
        cell.push(candidate);
    };
    LabelGrid.prototype.organize = function () {
        for (var k in this.cells) {
            var cell = this.cells[k];
            cell.sort(LabelCandidate.compare);
        }
    };
    LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {
        // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?
        // TODO: adjust threshold lower, but increase cells a bit?
        // TODO: hunt for geom issue in disguise
        // TODO: memoize while ratio does not move. method to force recompute
        var cellArea = this.cellSize * this.cellSize;
        var scaledCellArea = cellArea / ratio / ratio;
        var scaledDensity = (scaledCellArea * density) / cellArea;
        var labelsToDisplayPerCell = Math.ceil(scaledDensity);
        var labels = [];
        for (var k in this.cells) {
            var cell = this.cells[k];
            for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {
                labels.push(cell[i].key);
            }
        }
        return labels;
    };
    return LabelGrid;
}());
exports.LabelGrid = LabelGrid;
/**
 * Label heuristic selecting edge labels to display, based on displayed node
 * labels
 *
 * @param  {object} params                 - Parameters:
 * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.
 * @param  {Set}      highlightedNodes     - Highlighted nodes.
 * @param  {Graph}    graph                - The rendered graph.
 * @param  {string}   hoveredNode          - Hovered node (optional)
 * @return {Array}                         - The selected labels.
 */
function edgeLabelsToDisplayFromNodes(params) {
    var graph = params.graph, hoveredNode = params.hoveredNode, highlightedNodes = params.highlightedNodes, displayedNodeLabels = params.displayedNodeLabels;
    var worthyEdges = [];
    // TODO: the code below can be optimized using #.forEach and batching the code per adj
    // We should display an edge's label if:
    //   - Any of its extremities is highlighted or hovered
    //   - Both of its extremities has its label shown
    graph.forEachEdge(function (edge, _, source, target) {
        if (source === hoveredNode ||
            target === hoveredNode ||
            highlightedNodes.has(source) ||
            highlightedNodes.has(target) ||
            (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))) {
            worthyEdges.push(edge);
        }
    });
    return worthyEdges;
}
exports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;


/***/ }),

/***/ "./node_modules/sigma/core/quadtree.js":
/*!*********************************************!*\
  !*** ./node_modules/sigma/core/quadtree.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;
/**
 * Sigma.js Quad Tree Class
 * =========================
 *
 * Class implementing the quad tree data structure used to solve hovers and
 * determine which elements are currently in the scope of the camera so that
 * we don't waste time rendering things the user cannot see anyway.
 * @module
 */
/* eslint no-nested-ternary: 0 */
/* eslint no-constant-condition: 0 */
var extend_1 = __importDefault(__webpack_require__(/*! @yomguithereal/helpers/extend */ "./node_modules/@yomguithereal/helpers/extend.js"));
// TODO: should not ask the quadtree when the camera has the whole graph in
// sight.
// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)
// TODO: jsdoc
// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size
// TODO: filtering unwanted labels beforehand through the filter function
// NOTE: this is basically a MX-CIF Quadtree at this point
// NOTE: need to explore R-Trees for edges
// NOTE: need to explore 2d segment tree for edges
// NOTE: probably can do faster using spatial hashing
/**
 * Constants.
 *
 * Note that since we are representing a static 4-ary tree, the indices of the
 * quadrants are the following:
 *   - TOP_LEFT:     4i + b
 *   - TOP_RIGHT:    4i + 2b
 *   - BOTTOM_LEFT:  4i + 3b
 *   - BOTTOM_RIGHT: 4i + 4b
 */
var BLOCKS = 4, MAX_LEVEL = 5;
var OUTSIDE_BLOCK = "outside";
var X_OFFSET = 0, Y_OFFSET = 1, WIDTH_OFFSET = 2, HEIGHT_OFFSET = 3;
var TOP_LEFT = 1, TOP_RIGHT = 2, BOTTOM_LEFT = 3, BOTTOM_RIGHT = 4;
var hasWarnedTooMuchOutside = false;
/**
 * Geometry helpers.
 */
/**
 * Function returning whether the given rectangle is axis-aligned.
 *
 * @param  {Rectangle} rect
 * @return {boolean}
 */
function isRectangleAligned(rect) {
    return rect.x1 === rect.x2 || rect.y1 === rect.y2;
}
exports.isRectangleAligned = isRectangleAligned;
/**
 * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.
 *
 * @param {Rectangle} rect
 * @return {Rectangle}
 */
function getCircumscribedAlignedRectangle(rect) {
    var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));
    var heightVector = {
        x: ((rect.y1 - rect.y2) * rect.height) / width,
        y: ((rect.x2 - rect.x1) * rect.height) / width,
    };
    // Compute all corners:
    var tl = { x: rect.x1, y: rect.y1 };
    var tr = { x: rect.x2, y: rect.y2 };
    var bl = {
        x: rect.x1 + heightVector.x,
        y: rect.y1 + heightVector.y,
    };
    var br = {
        x: rect.x2 + heightVector.x,
        y: rect.y2 + heightVector.y,
    };
    var xL = Math.min(tl.x, tr.x, bl.x, br.x);
    var xR = Math.max(tl.x, tr.x, bl.x, br.x);
    var yT = Math.min(tl.y, tr.y, bl.y, br.y);
    var yB = Math.max(tl.y, tr.y, bl.y, br.y);
    return {
        x1: xL,
        y1: yT,
        x2: xR,
        y2: yT,
        height: yB - yT,
    };
}
exports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;
/**
 *
 * @param x1
 * @param y1
 * @param w
 * @param qx
 * @param qy
 * @param qw
 * @param qh
 */
function squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {
    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;
}
exports.squareCollidesWithQuad = squareCollidesWithQuad;
function rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {
    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;
}
exports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;
function pointIsInQuad(x, y, qx, qy, qw, qh) {
    var xmp = qx + qw / 2, ymp = qy + qh / 2, top = y < ymp, left = x < xmp;
    return top ? (left ? TOP_LEFT : TOP_RIGHT) : left ? BOTTOM_LEFT : BOTTOM_RIGHT;
}
/**
 * Helper functions that are not bound to the class so an external user
 * cannot mess with them.
 */
function buildQuadrants(maxLevel, data) {
    // [block, level]
    var stack = [0, 0];
    while (stack.length) {
        var level = stack.pop(), block = stack.pop();
        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;
        var x = data[block + X_OFFSET], y = data[block + Y_OFFSET], width = data[block + WIDTH_OFFSET], height = data[block + HEIGHT_OFFSET], hw = width / 2, hh = height / 2;
        data[topLeftBlock + X_OFFSET] = x;
        data[topLeftBlock + Y_OFFSET] = y;
        data[topLeftBlock + WIDTH_OFFSET] = hw;
        data[topLeftBlock + HEIGHT_OFFSET] = hh;
        data[topRightBlock + X_OFFSET] = x + hw;
        data[topRightBlock + Y_OFFSET] = y;
        data[topRightBlock + WIDTH_OFFSET] = hw;
        data[topRightBlock + HEIGHT_OFFSET] = hh;
        data[bottomLeftBlock + X_OFFSET] = x;
        data[bottomLeftBlock + Y_OFFSET] = y + hh;
        data[bottomLeftBlock + WIDTH_OFFSET] = hw;
        data[bottomLeftBlock + HEIGHT_OFFSET] = hh;
        data[bottomRightBlock + X_OFFSET] = x + hw;
        data[bottomRightBlock + Y_OFFSET] = y + hh;
        data[bottomRightBlock + WIDTH_OFFSET] = hw;
        data[bottomRightBlock + HEIGHT_OFFSET] = hh;
        if (level < maxLevel - 1) {
            stack.push(bottomRightBlock, level + 1);
            stack.push(bottomLeftBlock, level + 1);
            stack.push(topRightBlock, level + 1);
            stack.push(topLeftBlock, level + 1);
        }
    }
}
function insertNode(maxLevel, data, containers, key, x, y, size) {
    var x1 = x - size, y1 = y - size, w = size * 2;
    var level = 0, block = 0;
    while (true) {
        // If we reached max level
        if (level >= maxLevel) {
            containers[block] = containers[block] || [];
            containers[block].push(key);
            return;
        }
        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;
        var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);
        var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);
        var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);
        var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);
        var collisions = [
            collidingWithTopLeft,
            collidingWithTopRight,
            collidingWithBottomLeft,
            collidingWithBottomRight,
        ].reduce(function (acc, current) {
            if (current)
                return acc + 1;
            else
                return acc;
        }, 0);
        // If we have no collision at root level, inject node in the outside block
        if (collisions === 0 && level === 0) {
            containers[OUTSIDE_BLOCK].push(key);
            if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {
                hasWarnedTooMuchOutside = true;
                console.warn("sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. " +
                    "You might have a problem with the normalization function or the custom bounding box.");
            }
            return;
        }
        // If we don't have at least a collision but deeper, there is an issue
        if (collisions === 0)
            throw new Error("sigma/quadtree.insertNode: no collision (level: ".concat(level, ", key: ").concat(key, ", x: ").concat(x, ", y: ").concat(y, ", size: ").concat(size, ")."));
        // If we have 3 collisions, we have a geometry problem obviously
        if (collisions === 3)
            throw new Error("sigma/quadtree.insertNode: 3 impossible collisions (level: ".concat(level, ", key: ").concat(key, ", x: ").concat(x, ", y: ").concat(y, ", size: ").concat(size, ")."));
        // If we have more that one collision, we stop here and store the node
        // in the relevant containers
        if (collisions > 1) {
            containers[block] = containers[block] || [];
            containers[block].push(key);
            return;
        }
        else {
            level++;
        }
        // Else we recurse into the correct quads
        if (collidingWithTopLeft)
            block = topLeftBlock;
        if (collidingWithTopRight)
            block = topRightBlock;
        if (collidingWithBottomLeft)
            block = bottomLeftBlock;
        if (collidingWithBottomRight)
            block = bottomRightBlock;
    }
}
function getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {
    // [block, level]
    var stack = [0, 0];
    var collectedNodes = [];
    var container;
    while (stack.length) {
        var level = stack.pop(), block = stack.pop();
        // Collecting nodes
        container = containers[block];
        if (container)
            (0, extend_1.default)(collectedNodes, container);
        // If we reached max level
        if (level >= maxLevel)
            continue;
        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;
        var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);
        var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);
        var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);
        var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);
        if (collidingWithTopLeft)
            stack.push(topLeftBlock, level + 1);
        if (collidingWithTopRight)
            stack.push(topRightBlock, level + 1);
        if (collidingWithBottomLeft)
            stack.push(bottomLeftBlock, level + 1);
        if (collidingWithBottomRight)
            stack.push(bottomRightBlock, level + 1);
    }
    return collectedNodes;
}
/**
 * QuadTree class.
 *
 * @constructor
 * @param {object} boundaries - The graph boundaries.
 */
var QuadTree = /** @class */ (function () {
    function QuadTree(params) {
        var _a;
        if (params === void 0) { params = {}; }
        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);
        this.cache = null;
        this.lastRectangle = null;
        // Allocating the underlying byte array
        var L = Math.pow(4, MAX_LEVEL);
        this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));
        if (params.boundaries)
            this.resize(params.boundaries);
        else
            this.resize({
                x: 0,
                y: 0,
                width: 1,
                height: 1,
            });
    }
    QuadTree.prototype.add = function (key, x, y, size) {
        insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);
        return this;
    };
    QuadTree.prototype.resize = function (boundaries) {
        this.clear();
        // Building the quadrants
        this.data[X_OFFSET] = boundaries.x;
        this.data[Y_OFFSET] = boundaries.y;
        this.data[WIDTH_OFFSET] = boundaries.width;
        this.data[HEIGHT_OFFSET] = boundaries.height;
        buildQuadrants(MAX_LEVEL, this.data);
    };
    QuadTree.prototype.clear = function () {
        var _a;
        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);
        return this;
    };
    QuadTree.prototype.point = function (x, y) {
        var nodes = this.containers[OUTSIDE_BLOCK];
        var block = 0, level = 0;
        do {
            if (this.containers[block])
                nodes.push.apply(nodes, __spreadArray([], __read(this.containers[block]), false));
            var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);
            block = 4 * block + quad * BLOCKS;
            level++;
        } while (level <= MAX_LEVEL);
        return nodes;
    };
    QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {
        var _a;
        var lr = this.lastRectangle;
        if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {
            return this.cache;
        }
        this.lastRectangle = {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            height: height,
        };
        // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:
        if (!isRectangleAligned(this.lastRectangle))
            this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);
        this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);
        // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:
        (_a = this.cache).push.apply(_a, __spreadArray([], __read(this.containers[OUTSIDE_BLOCK]), false));
        return this.cache;
    };
    return QuadTree;
}());
exports["default"] = QuadTree;


/***/ }),

/***/ "./node_modules/sigma/index.js":
/*!*************************************!*\
  !*** ./node_modules/sigma/index.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sigma = exports.MouseCaptor = exports.QuadTree = exports.Camera = void 0;
/**
 * Sigma.js Library Endpoint
 * =========================
 *
 * The library endpoint.
 * @module
 */
var sigma_1 = __importDefault(__webpack_require__(/*! ./sigma */ "./node_modules/sigma/sigma.js"));
exports.Sigma = sigma_1.default;
var camera_1 = __importDefault(__webpack_require__(/*! ./core/camera */ "./node_modules/sigma/core/camera.js"));
exports.Camera = camera_1.default;
var quadtree_1 = __importDefault(__webpack_require__(/*! ./core/quadtree */ "./node_modules/sigma/core/quadtree.js"));
exports.QuadTree = quadtree_1.default;
var mouse_1 = __importDefault(__webpack_require__(/*! ./core/captors/mouse */ "./node_modules/sigma/core/captors/mouse.js"));
exports.MouseCaptor = mouse_1.default;
exports["default"] = sigma_1.default;


/***/ }),

/***/ "./node_modules/sigma/rendering/canvas/edge-label.js":
/*!***********************************************************!*\
  !*** ./node_modules/sigma/rendering/canvas/edge-label.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {
    var size = settings.edgeLabelSize, font = settings.edgeLabelFont, weight = settings.edgeLabelWeight, color = settings.edgeLabelColor.attribute
        ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || "#000"
        : settings.edgeLabelColor.color;
    var label = edgeData.label;
    if (!label)
        return;
    context.fillStyle = color;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
    // Computing positions without considering nodes sizes:
    var sSize = sourceData.size;
    var tSize = targetData.size;
    var sx = sourceData.x;
    var sy = sourceData.y;
    var tx = targetData.x;
    var ty = targetData.y;
    var cx = (sx + tx) / 2;
    var cy = (sy + ty) / 2;
    var dx = tx - sx;
    var dy = ty - sy;
    var d = Math.sqrt(dx * dx + dy * dy);
    if (d < sSize + tSize)
        return;
    // Adding nodes sizes:
    sx += (dx * sSize) / d;
    sy += (dy * sSize) / d;
    tx -= (dx * tSize) / d;
    ty -= (dy * tSize) / d;
    cx = (sx + tx) / 2;
    cy = (sy + ty) / 2;
    dx = tx - sx;
    dy = ty - sy;
    d = Math.sqrt(dx * dx + dy * dy);
    // Handling ellipsis
    var textLength = context.measureText(label).width;
    if (textLength > d) {
        var ellipsis = "…";
        label = label + ellipsis;
        textLength = context.measureText(label).width;
        while (textLength > d && label.length > 1) {
            label = label.slice(0, -2) + ellipsis;
            textLength = context.measureText(label).width;
        }
        if (label.length < 4)
            return;
    }
    var angle;
    if (dx > 0) {
        if (dy > 0)
            angle = Math.acos(dx / d);
        else
            angle = Math.asin(dy / d);
    }
    else {
        if (dy > 0)
            angle = Math.acos(dx / d) + Math.PI;
        else
            angle = Math.asin(dx / d) + Math.PI / 2;
    }
    context.save();
    context.translate(cx, cy);
    context.rotate(angle);
    context.fillText(label, -textLength / 2, edgeData.size / 2 + size);
    context.restore();
}
exports["default"] = drawEdgeLabel;


/***/ }),

/***/ "./node_modules/sigma/rendering/canvas/hover.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/rendering/canvas/hover.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var label_1 = __importDefault(__webpack_require__(/*! ./label */ "./node_modules/sigma/rendering/canvas/label.js"));
/**
 * Draw an hovered node.
 * - if there is no label => display a shadow on the node
 * - if the label box is bigger than node size => display a label box that contains the node with a shadow
 * - else node with shadow and the label box
 */
function drawHover(context, data, settings) {
    var size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
    // Then we draw the label background
    context.fillStyle = "#FFF";
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 8;
    context.shadowColor = "#000";
    var PADDING = 2;
    if (typeof data.label === "string") {
        var textWidth = context.measureText(data.label).width, boxWidth = Math.round(textWidth + 5), boxHeight = Math.round(size + 2 * PADDING), radius = Math.max(data.size, size / 2) + PADDING;
        var angleRadian = Math.asin(boxHeight / 2 / radius);
        var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));
        context.beginPath();
        context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);
        context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);
        context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);
        context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);
        context.arc(data.x, data.y, radius, angleRadian, -angleRadian);
        context.closePath();
        context.fill();
    }
    else {
        context.beginPath();
        context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);
        context.closePath();
        context.fill();
    }
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 0;
    // And finally we draw the label
    (0, label_1.default)(context, data, settings);
}
exports["default"] = drawHover;


/***/ }),

/***/ "./node_modules/sigma/rendering/canvas/label.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/rendering/canvas/label.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function drawLabel(context, data, settings) {
    if (!data.label)
        return;
    var size = settings.labelSize, font = settings.labelFont, weight = settings.labelWeight, color = settings.labelColor.attribute
        ? data[settings.labelColor.attribute] || settings.labelColor.color || "#000"
        : settings.labelColor.color;
    context.fillStyle = color;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
    context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);
}
exports["default"] = drawLabel;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/common/edge.js":
/*!********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/common/edge.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createEdgeCompoundProgram = exports.AbstractEdgeProgram = void 0;
/**
 * Sigma.js WebGL Abstract Edge Program
 * =====================================
 *
 * @module
 */
var program_1 = __webpack_require__(/*! ./program */ "./node_modules/sigma/rendering/webgl/programs/common/program.js");
/**
 * Edge Program class.
 *
 * @constructor
 */
var AbstractEdgeProgram = /** @class */ (function (_super) {
    __extends(AbstractEdgeProgram, _super);
    function AbstractEdgeProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {
        return _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;
    }
    return AbstractEdgeProgram;
}(program_1.AbstractProgram));
exports.AbstractEdgeProgram = AbstractEdgeProgram;
function createEdgeCompoundProgram(programClasses) {
    return /** @class */ (function () {
        function EdgeCompoundProgram(gl, renderer) {
            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl, renderer); });
        }
        EdgeCompoundProgram.prototype.bufferData = function () {
            this.programs.forEach(function (program) { return program.bufferData(); });
        };
        EdgeCompoundProgram.prototype.allocate = function (capacity) {
            this.programs.forEach(function (program) { return program.allocate(capacity); });
        };
        EdgeCompoundProgram.prototype.bind = function () {
            // nothing todo, it's already done in each program constructor
        };
        EdgeCompoundProgram.prototype.computeIndices = function () {
            this.programs.forEach(function (program) { return program.computeIndices(); });
        };
        EdgeCompoundProgram.prototype.render = function (params) {
            this.programs.forEach(function (program) {
                program.bind();
                program.bufferData();
                program.render(params);
            });
        };
        EdgeCompoundProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {
            this.programs.forEach(function (program) { return program.process(sourceData, targetData, data, hidden, offset); });
        };
        return EdgeCompoundProgram;
    }());
}
exports.createEdgeCompoundProgram = createEdgeCompoundProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/common/node.js":
/*!********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/common/node.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNodeCompoundProgram = exports.AbstractNodeProgram = void 0;
/**
 * Sigma.js WebGL Abstract Node Program
 * =====================================
 *
 * @module
 */
var program_1 = __webpack_require__(/*! ./program */ "./node_modules/sigma/rendering/webgl/programs/common/program.js");
/**
 * Node Program class.
 *
 * @constructor
 */
var AbstractNodeProgram = /** @class */ (function (_super) {
    __extends(AbstractNodeProgram, _super);
    function AbstractNodeProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {
        var _this = _super.call(this, gl, vertexShaderSource, fragmentShaderSource, points, attributes) || this;
        // Locations
        _this.positionLocation = gl.getAttribLocation(_this.program, "a_position");
        _this.sizeLocation = gl.getAttribLocation(_this.program, "a_size");
        _this.colorLocation = gl.getAttribLocation(_this.program, "a_color");
        // Uniform Location
        var matrixLocation = gl.getUniformLocation(_this.program, "u_matrix");
        if (matrixLocation === null)
            throw new Error("AbstractNodeProgram: error while getting matrixLocation");
        _this.matrixLocation = matrixLocation;
        var ratioLocation = gl.getUniformLocation(_this.program, "u_ratio");
        if (ratioLocation === null)
            throw new Error("AbstractNodeProgram: error while getting ratioLocation");
        _this.ratioLocation = ratioLocation;
        var scaleLocation = gl.getUniformLocation(_this.program, "u_scale");
        if (scaleLocation === null)
            throw new Error("AbstractNodeProgram: error while getting scaleLocation");
        _this.scaleLocation = scaleLocation;
        return _this;
    }
    AbstractNodeProgram.prototype.bind = function () {
        var gl = this.gl;
        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.sizeLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.sizeLocation, 1, gl.FLOAT, false, this.attributes * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, this.attributes * Float32Array.BYTES_PER_ELEMENT, 12);
    };
    return AbstractNodeProgram;
}(program_1.AbstractProgram));
exports.AbstractNodeProgram = AbstractNodeProgram;
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @return {function}
 */
function createNodeCompoundProgram(programClasses) {
    return /** @class */ (function () {
        function NodeCompoundProgram(gl, renderer) {
            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl, renderer); });
        }
        NodeCompoundProgram.prototype.bufferData = function () {
            this.programs.forEach(function (program) { return program.bufferData(); });
        };
        NodeCompoundProgram.prototype.allocate = function (capacity) {
            this.programs.forEach(function (program) { return program.allocate(capacity); });
        };
        NodeCompoundProgram.prototype.bind = function () {
            // nothing todo, it's already done in each program constructor
        };
        NodeCompoundProgram.prototype.render = function (params) {
            this.programs.forEach(function (program) {
                program.bind();
                program.bufferData();
                program.render(params);
            });
        };
        NodeCompoundProgram.prototype.process = function (data, hidden, offset) {
            this.programs.forEach(function (program) { return program.process(data, hidden, offset); });
        };
        return NodeCompoundProgram;
    }());
}
exports.createNodeCompoundProgram = createNodeCompoundProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/common/program.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/common/program.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractProgram = void 0;
/**
 * Sigma.js WebGL Renderer Program
 * ================================
 *
 * Class representing a single WebGL program used by sigma's WebGL renderer.
 * @module
 */
var utils_1 = __webpack_require__(/*! ../../shaders/utils */ "./node_modules/sigma/rendering/webgl/shaders/utils.js");
/**
 * Abstract Program class.
 *
 * @constructor
 */
var AbstractProgram = /** @class */ (function () {
    function AbstractProgram(gl, vertexShaderSource, fragmentShaderSource, points, attributes) {
        this.array = new Float32Array();
        this.points = points;
        this.attributes = attributes;
        this.gl = gl;
        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;
        var buffer = gl.createBuffer();
        if (buffer === null)
            throw new Error("AbstractProgram: error while creating the buffer");
        this.buffer = buffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        this.vertexShader = (0, utils_1.loadVertexShader)(gl, this.vertexShaderSource);
        this.fragmentShader = (0, utils_1.loadFragmentShader)(gl, this.fragmentShaderSource);
        this.program = (0, utils_1.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);
    }
    AbstractProgram.prototype.bufferData = function () {
        var gl = this.gl;
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
    };
    AbstractProgram.prototype.allocate = function (capacity) {
        this.array = new Float32Array(this.points * this.attributes * capacity);
    };
    AbstractProgram.prototype.hasNothingToRender = function () {
        return this.array.length === 0;
    };
    return AbstractProgram;
}());
exports.AbstractProgram = AbstractProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.arrow.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.arrow.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sigma.js WebGL Renderer Edge Arrow Program
 * ===========================================
 *
 * Compound program rendering edges as an arrow from the source to the target.
 * @module
 */
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var edge_arrowHead_1 = __importDefault(__webpack_require__(/*! ./edge.arrowHead */ "./node_modules/sigma/rendering/webgl/programs/edge.arrowHead.js"));
var edge_clamped_1 = __importDefault(__webpack_require__(/*! ./edge.clamped */ "./node_modules/sigma/rendering/webgl/programs/edge.clamped.js"));
var EdgeArrowProgram = (0, edge_1.createEdgeCompoundProgram)([edge_clamped_1.default, edge_arrowHead_1.default]);
exports["default"] = EdgeArrowProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.arrowHead.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.arrowHead.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var edge_arrowHead_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.arrowHead.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.vert.glsl.js"));
var edge_arrowHead_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.arrowHead.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.frag.glsl.js"));
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var POINTS = 3, ATTRIBUTES = 9, STRIDE = POINTS * ATTRIBUTES;
var EdgeArrowHeadProgram = /** @class */ (function (_super) {
    __extends(EdgeArrowHeadProgram, _super);
    function EdgeArrowHeadProgram(gl) {
        var _this = _super.call(this, gl, edge_arrowHead_vert_glsl_1.default, edge_arrowHead_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
        // Locations
        _this.positionLocation = gl.getAttribLocation(_this.program, "a_position");
        _this.colorLocation = gl.getAttribLocation(_this.program, "a_color");
        _this.normalLocation = gl.getAttribLocation(_this.program, "a_normal");
        _this.radiusLocation = gl.getAttribLocation(_this.program, "a_radius");
        _this.barycentricLocation = gl.getAttribLocation(_this.program, "a_barycentric");
        // Uniform locations
        var matrixLocation = gl.getUniformLocation(_this.program, "u_matrix");
        if (matrixLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting matrixLocation");
        _this.matrixLocation = matrixLocation;
        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, "u_sqrtZoomRatio");
        if (sqrtZoomRatioLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting sqrtZoomRatioLocation");
        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;
        var correctionRatioLocation = gl.getUniformLocation(_this.program, "u_correctionRatio");
        if (correctionRatioLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting correctionRatioLocation");
        _this.correctionRatioLocation = correctionRatioLocation;
        _this.bind();
        return _this;
    }
    EdgeArrowHeadProgram.prototype.bind = function () {
        var gl = this.gl;
        // Bindings
        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.radiusLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.enableVertexAttribArray(this.barycentricLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
        // TODO: maybe we can optimize here by packing this in a bit mask
        gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);
    };
    EdgeArrowHeadProgram.prototype.computeIndices = function () {
        // nothing to do
    };
    EdgeArrowHeadProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {
        if (hidden) {
            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)
                this.array[i_1] = 0;
            return;
        }
        var thickness = data.size || 1, radius = targetData.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, color = (0, utils_1.floatColor)(data.color);
        // Computing normals
        var dx = x2 - x1, dy = y2 - y1;
        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;
        if (len) {
            len = 1 / Math.sqrt(len);
            n1 = -dy * len * thickness;
            n2 = dx * len * thickness;
        }
        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array;
        // First point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = 0;
        array[i++] = 0;
        // Second point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 1;
        array[i++] = 0;
        // Third point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 0;
        array[i] = 1;
    };
    EdgeArrowHeadProgram.prototype.render = function (params) {
        if (this.hasNothingToRender())
            return;
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program);
        // Binding uniforms
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));
        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);
        // Drawing:
        gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);
    };
    return EdgeArrowHeadProgram;
}(edge_1.AbstractEdgeProgram));
exports["default"] = EdgeArrowHeadProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.clamped.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.clamped.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var edge_clamped_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.clamped.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.clamped.vert.glsl.js"));
var edge_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.frag.glsl.js"));
var POINTS = 4, ATTRIBUTES = 6, STRIDE = POINTS * ATTRIBUTES;
var EdgeClampedProgram = /** @class */ (function (_super) {
    __extends(EdgeClampedProgram, _super);
    function EdgeClampedProgram(gl) {
        var _this = _super.call(this, gl, edge_clamped_vert_glsl_1.default, edge_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
        // Initializing indices buffer
        var indicesBuffer = gl.createBuffer();
        if (indicesBuffer === null)
            throw new Error("EdgeClampedProgram: error while getting resolutionLocation");
        _this.indicesBuffer = indicesBuffer;
        // Locations:
        _this.positionLocation = gl.getAttribLocation(_this.program, "a_position");
        _this.colorLocation = gl.getAttribLocation(_this.program, "a_color");
        _this.normalLocation = gl.getAttribLocation(_this.program, "a_normal");
        _this.radiusLocation = gl.getAttribLocation(_this.program, "a_radius");
        // Uniform locations
        var matrixLocation = gl.getUniformLocation(_this.program, "u_matrix");
        if (matrixLocation === null)
            throw new Error("EdgeClampedProgram: error while getting matrixLocation");
        _this.matrixLocation = matrixLocation;
        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, "u_sqrtZoomRatio");
        if (sqrtZoomRatioLocation === null)
            throw new Error("EdgeClampedProgram: error while getting cameraRatioLocation");
        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;
        var correctionRatioLocation = gl.getUniformLocation(_this.program, "u_correctionRatio");
        if (correctionRatioLocation === null)
            throw new Error("EdgeClampedProgram: error while getting viewportRatioLocation");
        _this.correctionRatioLocation = correctionRatioLocation;
        // Enabling the OES_element_index_uint extension
        // NOTE: on older GPUs, this means that really large graphs won't
        // have all their edges rendered. But it seems that the
        // `OES_element_index_uint` is quite everywhere so we'll handle
        // the potential issue if it really arises.
        // NOTE: when using webgl2, the extension is enabled by default
        _this.canUse32BitsIndices = (0, utils_1.canUse32BitsIndices)(gl);
        _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;
        _this.indicesArray = new _this.IndicesArray();
        _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
        _this.bind();
        return _this;
    }
    EdgeClampedProgram.prototype.bind = function () {
        var gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
        // Bindings
        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.enableVertexAttribArray(this.radiusLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
    };
    EdgeClampedProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {
        if (hidden) {
            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)
                this.array[i_1] = 0;
            return;
        }
        var thickness = data.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, radius = targetData.size || 1, color = (0, utils_1.floatColor)(data.color);
        // Computing normals
        var dx = x2 - x1, dy = y2 - y1;
        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;
        if (len) {
            len = 1 / Math.sqrt(len);
            n1 = -dy * len * thickness;
            n2 = dx * len * thickness;
        }
        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array;
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = color;
        array[i++] = 0;
        // First point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = color;
        array[i++] = 0;
        // Second point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = color;
        array[i++] = radius;
        // Second point flipped
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = color;
        array[i] = -radius;
    };
    EdgeClampedProgram.prototype.computeIndices = function () {
        var l = this.array.length / ATTRIBUTES;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);
        for (var i = 0, c = 0; i < l; i += 4) {
            indices[c++] = i;
            indices[c++] = i + 1;
            indices[c++] = i + 2;
            indices[c++] = i + 2;
            indices[c++] = i + 1;
            indices[c++] = i + 3;
        }
        this.indicesArray = indices;
    };
    EdgeClampedProgram.prototype.bufferData = function () {
        _super.prototype.bufferData.call(this);
        // Indices data
        var gl = this.gl;
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);
    };
    EdgeClampedProgram.prototype.render = function (params) {
        if (this.hasNothingToRender())
            return;
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program);
        // Binding uniforms
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));
        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);
        // Drawing:
        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
    };
    return EdgeClampedProgram;
}(edge_1.AbstractEdgeProgram));
exports["default"] = EdgeClampedProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/edge.js":
/*!*************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/edge.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sigma.js WebGL Renderer Edge Program
 * =====================================
 *
 * Program rendering edges as thick lines using four points translated
 * orthogonally from the source & target's centers by half thickness.
 *
 * Rendering two triangles by using only four points is made possible through
 * the use of indices.
 *
 * This method should be faster than the 6 points / 2 triangles approach and
 * should handle thickness better than with gl.LINES.
 *
 * This version of the shader balances geometry computation evenly between
 * the CPU & GPU (normals are computed on the CPU side).
 * @module
 */
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var edge_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.vert.glsl.js"));
var edge_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/edge.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/edge.frag.glsl.js"));
var edge_1 = __webpack_require__(/*! ./common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
var POINTS = 4, ATTRIBUTES = 5, STRIDE = POINTS * ATTRIBUTES;
var EdgeProgram = /** @class */ (function (_super) {
    __extends(EdgeProgram, _super);
    function EdgeProgram(gl) {
        var _this = _super.call(this, gl, edge_vert_glsl_1.default, edge_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
        // Initializing indices buffer
        var indicesBuffer = gl.createBuffer();
        if (indicesBuffer === null)
            throw new Error("EdgeProgram: error while creating indicesBuffer");
        _this.indicesBuffer = indicesBuffer;
        // Locations
        _this.positionLocation = gl.getAttribLocation(_this.program, "a_position");
        _this.colorLocation = gl.getAttribLocation(_this.program, "a_color");
        _this.normalLocation = gl.getAttribLocation(_this.program, "a_normal");
        var matrixLocation = gl.getUniformLocation(_this.program, "u_matrix");
        if (matrixLocation === null)
            throw new Error("EdgeProgram: error while getting matrixLocation");
        _this.matrixLocation = matrixLocation;
        var correctionRatioLocation = gl.getUniformLocation(_this.program, "u_correctionRatio");
        if (correctionRatioLocation === null)
            throw new Error("EdgeProgram: error while getting correctionRatioLocation");
        _this.correctionRatioLocation = correctionRatioLocation;
        var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, "u_sqrtZoomRatio");
        if (sqrtZoomRatioLocation === null)
            throw new Error("EdgeProgram: error while getting sqrtZoomRatioLocation");
        _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;
        // Enabling the OES_element_index_uint extension
        // NOTE: on older GPUs, this means that really large graphs won't
        // have all their edges rendered. But it seems that the
        // `OES_element_index_uint` is quite everywhere so we'll handle
        // the potential issue if it really arises.
        // NOTE: when using webgl2, the extension is enabled by default
        _this.canUse32BitsIndices = (0, utils_1.canUse32BitsIndices)(gl);
        _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;
        _this.indicesArray = new _this.IndicesArray();
        _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
        _this.bind();
        return _this;
    }
    EdgeProgram.prototype.bind = function () {
        var gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
        // Bindings
        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
    };
    EdgeProgram.prototype.computeIndices = function () {
        var l = this.array.length / ATTRIBUTES;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);
        for (var i = 0, c = 0; i < l; i += 4) {
            indices[c++] = i;
            indices[c++] = i + 1;
            indices[c++] = i + 2;
            indices[c++] = i + 2;
            indices[c++] = i + 1;
            indices[c++] = i + 3;
        }
        this.indicesArray = indices;
    };
    EdgeProgram.prototype.bufferData = function () {
        _super.prototype.bufferData.call(this);
        // Indices data
        var gl = this.gl;
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);
    };
    EdgeProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {
        if (hidden) {
            for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++)
                this.array[i_1] = 0;
            return;
        }
        var thickness = data.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, color = (0, utils_1.floatColor)(data.color);
        // Computing normals
        var dx = x2 - x1, dy = y2 - y1;
        var len = dx * dx + dy * dy, n1 = 0, n2 = 0;
        if (len) {
            len = 1 / Math.sqrt(len);
            n1 = -dy * len * thickness;
            n2 = dx * len * thickness;
        }
        var i = POINTS * ATTRIBUTES * offset;
        var array = this.array;
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = color;
        // First point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = color;
        // Second point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = n1;
        array[i++] = n2;
        array[i++] = color;
        // Second point flipped
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i] = color;
    };
    EdgeProgram.prototype.render = function (params) {
        if (this.hasNothingToRender())
            return;
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));
        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);
        // Drawing:
        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
    };
    return EdgeProgram;
}(edge_1.AbstractEdgeProgram));
exports["default"] = EdgeProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/programs/node.fast.js":
/*!******************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/programs/node.fast.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var utils_1 = __webpack_require__(/*! ../../../utils */ "./node_modules/sigma/utils/index.js");
var node_fast_vert_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/node.fast.vert.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/node.fast.vert.glsl.js"));
var node_fast_frag_glsl_1 = __importDefault(__webpack_require__(/*! ../shaders/node.fast.frag.glsl.js */ "./node_modules/sigma/rendering/webgl/shaders/node.fast.frag.glsl.js"));
var node_1 = __webpack_require__(/*! ./common/node */ "./node_modules/sigma/rendering/webgl/programs/common/node.js");
var POINTS = 1, ATTRIBUTES = 4;
var NodeFastProgram = /** @class */ (function (_super) {
    __extends(NodeFastProgram, _super);
    function NodeFastProgram(gl) {
        var _this = _super.call(this, gl, node_fast_vert_glsl_1.default, node_fast_frag_glsl_1.default, POINTS, ATTRIBUTES) || this;
        _this.bind();
        return _this;
    }
    NodeFastProgram.prototype.process = function (data, hidden, offset) {
        var array = this.array;
        var i = offset * POINTS * ATTRIBUTES;
        if (hidden) {
            array[i++] = 0;
            array[i++] = 0;
            array[i++] = 0;
            array[i++] = 0;
            return;
        }
        var color = (0, utils_1.floatColor)(data.color);
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = data.size;
        array[i] = color;
    };
    NodeFastProgram.prototype.render = function (params) {
        if (this.hasNothingToRender())
            return;
        var gl = this.gl;
        var program = this.program;
        gl.useProgram(program);
        gl.uniform1f(this.ratioLocation, 1 / Math.sqrt(params.ratio));
        gl.uniform1f(this.scaleLocation, params.scalingRatio);
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);
    };
    return NodeFastProgram;
}(node_1.AbstractNodeProgram));
exports["default"] = NodeFastProgram;


/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.frag.glsl.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.frag.glsl.js ***!
  \********************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(o,r)=>{for(var t in r)e.o(r,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:r[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>r});const r="precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";module.exports=o})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.vert.glsl.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.arrowHead.vert.glsl.js ***!
  \********************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var a={d:(e,t)=>{for(var o in t)a.o(t,o)&&!a.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(a,e)=>Object.prototype.hasOwnProperty.call(a,e),r:a=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})}},e={};a.r(e),a.d(e,{default:()=>t});const t="attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec4 a_color;\nattribute vec3 a_barycentric;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadWidthLengthRatio = 0.66;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\n\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=e})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.clamped.vert.glsl.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.clamped.vert.glsl.js ***!
  \******************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(o,n)=>{for(var t in n)e.o(n,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:n[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},o={};e.r(o),e.d(o,{default:()=>n});const n="attribute vec4 a_color;\nattribute vec2 a_normal;\nattribute vec2 a_position;\nattribute float a_radius;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(a_radius);\n  float adaptedWebGLNodeRadius = direction * a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\n\n  v_normal = unitNormal;\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=o})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.frag.glsl.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.frag.glsl.js ***!
  \**********************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(n,t)=>{for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>t});const t="precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float feather = 0.001;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n}\n";module.exports=n})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/edge.vert.glsl.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/edge.vert.glsl.js ***!
  \**********************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>o});const o='attribute vec4 a_color;\nattribute vec2 a_normal;\nattribute vec2 a_position;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // We require edges to be at least `minThickness` pixels thick *on screen*\n  // (so we need to compensate the SQRT zoom ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our "magic" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n\n  // Finally, we adapt the edge thickness to the "SQRT rule" in sigma (so that\n  // items are not too big when zoomed in, and not too small when zoomed out).\n  // The exact computation should be `adapted = value * zoom / sqrt(zoom)`, but\n  // it\'s simpler like this:\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(a_position + unitNormal * adaptedWebGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the "magic"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasint effect does not depend on the zoom level. So here\'s yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_sqrtZoomRatio;\n\n  v_normal = unitNormal;\n  v_color = a_color;\n  v_color.a *= bias;\n}\n';module.exports=n})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/node.fast.frag.glsl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/node.fast.frag.glsl.js ***!
  \***************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>o});const o="precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n}\n";module.exports=n})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/node.fast.vert.glsl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/node.fast.vert.glsl.js ***!
  \***************************************************************************/
/***/ ((module) => {

(()=>{"use strict";var o={d:(t,e)=>{for(var n in e)o.o(e,n)&&!o.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(o,t)=>Object.prototype.hasOwnProperty.call(o,t),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},t={};o.r(t),o.d(t,{default:()=>e});const e="attribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\n\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\n\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=t})();

/***/ }),

/***/ "./node_modules/sigma/rendering/webgl/shaders/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/sigma/rendering/webgl/shaders/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Sigma.js Shader Utils
 * ======================
 *
 * Code used to load sigma's shaders.
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadProgram = exports.loadFragmentShader = exports.loadVertexShader = void 0;
/**
 * Function used to load a shader.
 */
function loadShader(type, gl, source) {
    var glType = type === "VERTEX" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
    // Creating the shader
    var shader = gl.createShader(glType);
    if (shader === null) {
        throw new Error("loadShader: error while creating the shader");
    }
    // Loading source
    gl.shaderSource(shader, source);
    // Compiling the shader
    gl.compileShader(shader);
    // Retrieving compilation status
    var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    // Throwing if something went awry
    if (!successfullyCompiled) {
        var infoLog = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error("loadShader: error while compiling the shader:\n".concat(infoLog, "\n").concat(source));
    }
    return shader;
}
function loadVertexShader(gl, source) {
    return loadShader("VERTEX", gl, source);
}
exports.loadVertexShader = loadVertexShader;
function loadFragmentShader(gl, source) {
    return loadShader("FRAGMENT", gl, source);
}
exports.loadFragmentShader = loadFragmentShader;
/**
 * Function used to load a program.
 */
function loadProgram(gl, shaders) {
    var program = gl.createProgram();
    if (program === null) {
        throw new Error("loadProgram: error while creating the program.");
    }
    var i, l;
    // Attaching the shaders
    for (i = 0, l = shaders.length; i < l; i++)
        gl.attachShader(program, shaders[i]);
    gl.linkProgram(program);
    // Checking status
    var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!successfullyLinked) {
        gl.deleteProgram(program);
        throw new Error("loadProgram: error while linking the program.");
    }
    return program;
}
exports.loadProgram = loadProgram;


/***/ }),

/***/ "./node_modules/sigma/settings.js":
/*!****************************************!*\
  !*** ./node_modules/sigma/settings.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Sigma.js Settings
 * =================================
 *
 * The list of settings and some handy functions.
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_SETTINGS = exports.validateSettings = void 0;
var label_1 = __importDefault(__webpack_require__(/*! ./rendering/canvas/label */ "./node_modules/sigma/rendering/canvas/label.js"));
var hover_1 = __importDefault(__webpack_require__(/*! ./rendering/canvas/hover */ "./node_modules/sigma/rendering/canvas/hover.js"));
var edge_label_1 = __importDefault(__webpack_require__(/*! ./rendering/canvas/edge-label */ "./node_modules/sigma/rendering/canvas/edge-label.js"));
var node_fast_1 = __importDefault(__webpack_require__(/*! ./rendering/webgl/programs/node.fast */ "./node_modules/sigma/rendering/webgl/programs/node.fast.js"));
var edge_1 = __importDefault(__webpack_require__(/*! ./rendering/webgl/programs/edge */ "./node_modules/sigma/rendering/webgl/programs/edge.js"));
var edge_arrow_1 = __importDefault(__webpack_require__(/*! ./rendering/webgl/programs/edge.arrow */ "./node_modules/sigma/rendering/webgl/programs/edge.arrow.js"));
function validateSettings(settings) {
    if (typeof settings.labelDensity !== "number" || settings.labelDensity < 0) {
        throw new Error("Settings: invalid `labelDensity`. Expecting a positive number.");
    }
    var minCameraRatio = settings.minCameraRatio, maxCameraRatio = settings.maxCameraRatio;
    if (typeof minCameraRatio === "number" && typeof maxCameraRatio === "number" && maxCameraRatio < minCameraRatio) {
        throw new Error("Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.");
    }
}
exports.validateSettings = validateSettings;
exports.DEFAULT_SETTINGS = {
    // Performance
    hideEdgesOnMove: false,
    hideLabelsOnMove: false,
    renderLabels: true,
    renderEdgeLabels: false,
    enableEdgeClickEvents: false,
    enableEdgeWheelEvents: false,
    enableEdgeHoverEvents: false,
    // Component rendering
    defaultNodeColor: "#999",
    defaultNodeType: "circle",
    defaultEdgeColor: "#ccc",
    defaultEdgeType: "line",
    labelFont: "Arial",
    labelSize: 14,
    labelWeight: "normal",
    labelColor: { color: "#000" },
    edgeLabelFont: "Arial",
    edgeLabelSize: 14,
    edgeLabelWeight: "normal",
    edgeLabelColor: { attribute: "color" },
    stagePadding: 30,
    // Labels
    labelDensity: 1,
    labelGridCellSize: 100,
    labelRenderedSizeThreshold: 6,
    // Reducers
    nodeReducer: null,
    edgeReducer: null,
    // Features
    zIndex: false,
    minCameraRatio: null,
    maxCameraRatio: null,
    // Renderers
    labelRenderer: label_1.default,
    hoverRenderer: hover_1.default,
    edgeLabelRenderer: edge_label_1.default,
    // Lifecycle
    allowInvalidContainer: false,
    // Program classes
    nodeProgramClasses: {
        circle: node_fast_1.default,
    },
    edgeProgramClasses: {
        arrow: edge_arrow_1.default,
        line: edge_1.default,
    },
};


/***/ }),

/***/ "./node_modules/sigma/sigma.js":
/*!*************************************!*\
  !*** ./node_modules/sigma/sigma.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var camera_1 = __importDefault(__webpack_require__(/*! ./core/camera */ "./node_modules/sigma/core/camera.js"));
var mouse_1 = __importDefault(__webpack_require__(/*! ./core/captors/mouse */ "./node_modules/sigma/core/captors/mouse.js"));
var quadtree_1 = __importDefault(__webpack_require__(/*! ./core/quadtree */ "./node_modules/sigma/core/quadtree.js"));
var types_1 = __webpack_require__(/*! ./types */ "./node_modules/sigma/types.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sigma/utils/index.js");
var labels_1 = __webpack_require__(/*! ./core/labels */ "./node_modules/sigma/core/labels.js");
var settings_1 = __webpack_require__(/*! ./settings */ "./node_modules/sigma/settings.js");
var touch_1 = __importDefault(__webpack_require__(/*! ./core/captors/touch */ "./node_modules/sigma/core/captors/touch.js"));
var matrices_1 = __webpack_require__(/*! ./utils/matrices */ "./node_modules/sigma/utils/matrices.js");
var edge_collisions_1 = __webpack_require__(/*! ./utils/edge-collisions */ "./node_modules/sigma/utils/edge-collisions.js");
/**
 * Important functions.
 */
function applyNodeDefaults(settings, key, data) {
    if (!data.hasOwnProperty("x") || !data.hasOwnProperty("y"))
        throw new Error("Sigma: could not find a valid position (x, y) for node \"".concat(key, "\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?"));
    if (!data.color)
        data.color = settings.defaultNodeColor;
    if (!data.label && data.label !== "")
        data.label = null;
    if (data.label !== undefined && data.label !== null)
        data.label = "" + data.label;
    else
        data.label = null;
    if (!data.size)
        data.size = 2;
    if (!data.hasOwnProperty("hidden"))
        data.hidden = false;
    if (!data.hasOwnProperty("highlighted"))
        data.highlighted = false;
    if (!data.hasOwnProperty("forceLabel"))
        data.forceLabel = false;
    if (!data.type || data.type === "")
        data.type = settings.defaultNodeType;
    if (!data.zIndex)
        data.zIndex = 0;
    return data;
}
function applyEdgeDefaults(settings, key, data) {
    if (!data.color)
        data.color = settings.defaultEdgeColor;
    if (!data.label)
        data.label = "";
    if (!data.size)
        data.size = 0.5;
    if (!data.hasOwnProperty("hidden"))
        data.hidden = false;
    if (!data.hasOwnProperty("forceLabel"))
        data.forceLabel = false;
    if (!data.type || data.type === "")
        data.type = settings.defaultEdgeType;
    if (!data.zIndex)
        data.zIndex = 0;
    return data;
}
/**
 * Main class.
 *
 * @constructor
 * @param {Graph}       graph     - Graph to render.
 * @param {HTMLElement} container - DOM container in which to render.
 * @param {object}      settings  - Optional settings.
 */
var Sigma = /** @class */ (function (_super) {
    __extends(Sigma, _super);
    function Sigma(graph, container, settings) {
        if (settings === void 0) { settings = {}; }
        var _this = _super.call(this) || this;
        _this.elements = {};
        _this.canvasContexts = {};
        _this.webGLContexts = {};
        _this.activeListeners = {};
        _this.quadtree = new quadtree_1.default();
        _this.labelGrid = new labels_1.LabelGrid();
        _this.nodeDataCache = {};
        _this.edgeDataCache = {};
        _this.nodesWithForcedLabels = [];
        _this.edgesWithForcedLabels = [];
        _this.nodeExtent = { x: [0, 1], y: [0, 1] };
        _this.matrix = (0, matrices_1.identity)();
        _this.invMatrix = (0, matrices_1.identity)();
        _this.correctionRatio = 1;
        _this.customBBox = null;
        _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({
            x: [0, 1],
            y: [0, 1],
        });
        // Cache:
        _this.cameraSizeRatio = 1;
        // Starting dimensions and pixel ratio
        _this.width = 0;
        _this.height = 0;
        _this.pixelRatio = (0, utils_1.getPixelRatio)();
        // State
        _this.displayedLabels = new Set();
        _this.highlightedNodes = new Set();
        _this.hoveredNode = null;
        _this.hoveredEdge = null;
        _this.renderFrame = null;
        _this.renderHighlightedNodesFrame = null;
        _this.needToProcess = false;
        _this.needToSoftProcess = false;
        _this.checkEdgesEventsFrame = null;
        // Programs
        _this.nodePrograms = {};
        _this.hoverNodePrograms = {};
        _this.edgePrograms = {};
        _this.settings = (0, utils_1.assign)({}, settings_1.DEFAULT_SETTINGS, settings);
        // Validating
        (0, settings_1.validateSettings)(_this.settings);
        (0, utils_1.validateGraph)(graph);
        if (!(container instanceof HTMLElement))
            throw new Error("Sigma: container should be an html element.");
        // Properties
        _this.graph = graph;
        _this.container = container;
        // Initializing contexts
        _this.createWebGLContext("edges", { preserveDrawingBuffer: true });
        _this.createCanvasContext("edgeLabels");
        _this.createWebGLContext("nodes");
        _this.createCanvasContext("labels");
        _this.createCanvasContext("hovers");
        _this.createWebGLContext("hoverNodes");
        _this.createCanvasContext("mouse");
        // Blending
        for (var key in _this.webGLContexts) {
            var gl = _this.webGLContexts[key];
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
        }
        // Loading programs
        for (var type in _this.settings.nodeProgramClasses) {
            var NodeProgramClass = _this.settings.nodeProgramClasses[type];
            _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);
            _this.hoverNodePrograms[type] = new NodeProgramClass(_this.webGLContexts.hoverNodes, _this);
        }
        for (var type in _this.settings.edgeProgramClasses) {
            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];
            _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);
        }
        // Initial resize
        _this.resize();
        // Initializing the camera
        _this.camera = new camera_1.default();
        // Binding camera events
        _this.bindCameraHandlers();
        // Initializing captors
        _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);
        _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);
        // Binding event handlers
        _this.bindEventHandlers();
        // Binding graph handlers
        _this.bindGraphHandlers();
        // Trigger eventual settings-related things
        _this.handleSettingsUpdate();
        // Processing data for the first time & render
        _this.process();
        _this.render();
        return _this;
    }
    /**---------------------------------------------------------------------------
     * Internal methods.
     **---------------------------------------------------------------------------
     */
    /**
     * Internal function used to create a canvas element.
     * @param  {string} id - Context's id.
     * @return {Sigma}
     */
    Sigma.prototype.createCanvas = function (id) {
        var canvas = (0, utils_1.createElement)("canvas", {
            position: "absolute",
        }, {
            class: "sigma-".concat(id),
        });
        this.elements[id] = canvas;
        this.container.appendChild(canvas);
        return canvas;
    };
    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string} id - Context's id.
     * @return {Sigma}
     */
    Sigma.prototype.createCanvasContext = function (id) {
        var canvas = this.createCanvas(id);
        var contextOptions = {
            preserveDrawingBuffer: false,
            antialias: false,
        };
        this.canvasContexts[id] = canvas.getContext("2d", contextOptions);
        return this;
    };
    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string}  id      - Context's id.
     * @param  {object?} options - #getContext params to override (optional)
     * @return {Sigma}
     */
    Sigma.prototype.createWebGLContext = function (id, options) {
        var canvas = this.createCanvas(id);
        var contextOptions = __assign({ preserveDrawingBuffer: false, antialias: false }, (options || {}));
        var context;
        // First we try webgl2 for an easy performance boost
        context = canvas.getContext("webgl2", contextOptions);
        // Else we fall back to webgl
        if (!context)
            context = canvas.getContext("webgl", contextOptions);
        // Edge, I am looking right at you...
        if (!context)
            context = canvas.getContext("experimental-webgl", contextOptions);
        this.webGLContexts[id] = context;
        return this;
    };
    /**
     * Method binding camera handlers.
     *
     * @return {Sigma}
     */
    Sigma.prototype.bindCameraHandlers = function () {
        var _this = this;
        this.activeListeners.camera = function () {
            _this._scheduleRefresh();
        };
        this.camera.on("updated", this.activeListeners.camera);
        return this;
    };
    /**
     * Method that checks whether or not a node collides with a given position.
     */
    Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {
        var x = _a.x, y = _a.y;
        var nodeX = _b.x, nodeY = _b.y;
        return (x > nodeX - size &&
            x < nodeX + size &&
            y > nodeY - size &&
            y < nodeY + size &&
            Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size);
    };
    /**
     * Method that returns all nodes in quad at a given position.
     */
    Sigma.prototype.getQuadNodes = function (position) {
        var mouseGraphPosition = this.viewportToFramedGraph(position);
        return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);
    };
    /**
     * Method that returns the closest node to a given position.
     */
    Sigma.prototype.getNodeAtPosition = function (position) {
        var x = position.x, y = position.y;
        var quadNodes = this.getQuadNodes(position);
        // We will hover the node whose center is closest to mouse
        var minDistance = Infinity, nodeAtPosition = null;
        for (var i = 0, l = quadNodes.length; i < l; i++) {
            var node = quadNodes[i];
            var data = this.nodeDataCache[node];
            var nodePosition = this.framedGraphToViewport(data);
            var size = this.scaleSize(data.size);
            if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {
                var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));
                // TODO: sort by min size also for cases where center is the same
                if (distance < minDistance) {
                    minDistance = distance;
                    nodeAtPosition = node;
                }
            }
        }
        return nodeAtPosition;
    };
    /**
     * Method binding event handlers.
     *
     * @return {Sigma}
     */
    Sigma.prototype.bindEventHandlers = function () {
        var _this = this;
        // Handling window resize
        this.activeListeners.handleResize = function () {
            _this.needToSoftProcess = true;
            _this._scheduleRefresh();
        };
        window.addEventListener("resize", this.activeListeners.handleResize);
        // Handling mouse move
        this.activeListeners.handleMove = function (e) {
            var baseEvent = {
                event: e,
                preventSigmaDefault: function () {
                    e.preventSigmaDefault();
                },
            };
            var nodeToHover = _this.getNodeAtPosition(e);
            if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {
                // Handling passing from one node to the other directly
                if (_this.hoveredNode)
                    _this.emit("leaveNode", __assign(__assign({}, baseEvent), { node: _this.hoveredNode }));
                _this.hoveredNode = nodeToHover;
                _this.emit("enterNode", __assign(__assign({}, baseEvent), { node: nodeToHover }));
                _this.scheduleHighlightedNodesRender();
                return;
            }
            // Checking if the hovered node is still hovered
            if (_this.hoveredNode) {
                var data = _this.nodeDataCache[_this.hoveredNode];
                var pos = _this.framedGraphToViewport(data);
                var size = _this.scaleSize(data.size);
                if (!_this.mouseIsOnNode(e, pos, size)) {
                    var node = _this.hoveredNode;
                    _this.hoveredNode = null;
                    _this.emit("leaveNode", __assign(__assign({}, baseEvent), { node: node }));
                    _this.scheduleHighlightedNodesRender();
                    return;
                }
            }
            if (_this.settings.enableEdgeHoverEvents === true) {
                _this.checkEdgeHoverEvents(baseEvent);
            }
            else if (_this.settings.enableEdgeHoverEvents === "debounce") {
                if (!_this.checkEdgesEventsFrame)
                    _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {
                        _this.checkEdgeHoverEvents(baseEvent);
                        _this.checkEdgesEventsFrame = null;
                    });
            }
        };
        // Handling click
        var createMouseListener = function (eventType) {
            return function (e) {
                var baseEvent = {
                    event: e,
                    preventSigmaDefault: function () {
                        e.preventSigmaDefault();
                    },
                };
                var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;
                var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;
                if (nodeAtPosition)
                    return _this.emit("".concat(eventType, "Node"), __assign(__assign({}, baseEvent), { node: nodeAtPosition }));
                if (eventType === "wheel" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {
                    var edge = _this.getEdgeAtPoint(e.x, e.y);
                    if (edge)
                        return _this.emit("".concat(eventType, "Edge"), __assign(__assign({}, baseEvent), { edge: edge }));
                }
                return _this.emit("".concat(eventType, "Stage"), baseEvent);
            };
        };
        this.activeListeners.handleClick = createMouseListener("click");
        this.activeListeners.handleRightClick = createMouseListener("rightClick");
        this.activeListeners.handleDoubleClick = createMouseListener("doubleClick");
        this.activeListeners.handleWheel = createMouseListener("wheel");
        this.activeListeners.handleDown = createMouseListener("down");
        this.mouseCaptor.on("mousemove", this.activeListeners.handleMove);
        this.mouseCaptor.on("click", this.activeListeners.handleClick);
        this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick);
        this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick);
        this.mouseCaptor.on("wheel", this.activeListeners.handleWheel);
        this.mouseCaptor.on("mousedown", this.activeListeners.handleDown);
        // TODO
        // Deal with Touch captor events
        return this;
    };
    /**
     * Method binding graph handlers
     *
     * @return {Sigma}
     */
    Sigma.prototype.bindGraphHandlers = function () {
        var _this = this;
        var graph = this.graph;
        this.activeListeners.graphUpdate = function () {
            _this.needToProcess = true;
            _this._scheduleRefresh();
        };
        this.activeListeners.softGraphUpdate = function () {
            _this.needToSoftProcess = true;
            _this._scheduleRefresh();
        };
        this.activeListeners.dropNodeGraphUpdate = function (e) {
            delete _this.nodeDataCache[e.key];
            if (_this.hoveredNode === e.key)
                _this.hoveredNode = null;
            _this.activeListeners.graphUpdate();
        };
        this.activeListeners.dropEdgeGraphUpdate = function (e) {
            delete _this.edgeDataCache[e.key];
            if (_this.hoveredEdge === e.key)
                _this.hoveredEdge = null;
            _this.activeListeners.graphUpdate();
        };
        this.activeListeners.clearEdgesGraphUpdate = function () {
            _this.edgeDataCache = {};
            _this.hoveredEdge = null;
            _this.activeListeners.graphUpdate();
        };
        this.activeListeners.clearGraphUpdate = function () {
            _this.nodeDataCache = {};
            _this.hoveredNode = null;
            _this.activeListeners.clearEdgesGraphUpdate();
        };
        graph.on("nodeAdded", this.activeListeners.graphUpdate);
        graph.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
        graph.on("nodeAttributesUpdated", this.activeListeners.softGraphUpdate);
        graph.on("eachNodeAttributesUpdated", this.activeListeners.graphUpdate);
        graph.on("edgeAdded", this.activeListeners.graphUpdate);
        graph.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
        graph.on("edgeAttributesUpdated", this.activeListeners.softGraphUpdate);
        graph.on("eachEdgeAttributesUpdated", this.activeListeners.graphUpdate);
        graph.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
        graph.on("cleared", this.activeListeners.clearGraphUpdate);
        return this;
    };
    /**
     * Method dealing with "leaveEdge" and "enterEdge" events.
     *
     * @return {Sigma}
     */
    Sigma.prototype.checkEdgeHoverEvents = function (payload) {
        var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);
        if (edgeToHover !== this.hoveredEdge) {
            if (this.hoveredEdge)
                this.emit("leaveEdge", __assign(__assign({}, payload), { edge: this.hoveredEdge }));
            if (edgeToHover)
                this.emit("enterEdge", __assign(__assign({}, payload), { edge: edgeToHover }));
            this.hoveredEdge = edgeToHover;
        }
        return this;
    };
    /**
     * Method looking for an edge colliding with a given point at (x, y). Returns
     * the key of the edge if any, or null else.
     */
    Sigma.prototype.getEdgeAtPoint = function (x, y) {
        var e_1, _a;
        var _this = this;
        var _b = this, edgeDataCache = _b.edgeDataCache, nodeDataCache = _b.nodeDataCache;
        // Check first that pixel is colored:
        // Note that mouse positions must be corrected by pixel ratio to correctly
        // index the drawing buffer.
        if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio))
            return null;
        // Check for each edge if it collides with the point:
        var _c = this.viewportToGraph({ x: x, y: y }), graphX = _c.x, graphY = _c.y;
        // To translate edge thicknesses to the graph system, we observe by how much
        // the length of a non-null edge is transformed to between the graph system
        // and the viewport system:
        var transformationRatio = 0;
        this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {
            var xs = _a.x, ys = _a.y;
            var xt = _b.x, yt = _b.y;
            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)
                return false;
            if (xs !== xt || ys !== yt) {
                var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));
                var _c = _this.graphToViewport({ x: xs, y: ys }), vp_xs = _c.x, vp_ys = _c.y;
                var _d = _this.graphToViewport({ x: xt, y: yt }), vp_xt = _d.x, vp_yt = _d.y;
                var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));
                transformationRatio = graphLength / viewportLength;
                return true;
            }
        });
        // If no non-null edge has been found, return null:
        if (!transformationRatio)
            return null;
        // Now we can look for matching edges:
        var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {
            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)
                return false;
            if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, 
            // Adapt the edge size to the zoom ratio:
            (edgeDataCache[key].size * transformationRatio) / _this.cameraSizeRatio)) {
                return true;
            }
        });
        if (edges.length === 0)
            return null; // no edges found
        // if none of the edges have a zIndex, selected the most recently created one to match the rendering order
        var selectedEdge = edges[edges.length - 1];
        // otherwise select edge with highest zIndex
        var highestZIndex = -Infinity;
        try {
            for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {
                var edge = edges_1_1.value;
                var zIndex = this.graph.getEdgeAttribute(edge, "zIndex");
                if (zIndex >= highestZIndex) {
                    selectedEdge = edge;
                    highestZIndex = zIndex;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return selectedEdge;
    };
    /**
     * Method used to process the whole graph's data.
     *
     * @return {Sigma}
     */
    Sigma.prototype.process = function (keepArrays) {
        var _this = this;
        if (keepArrays === void 0) { keepArrays = false; }
        var graph = this.graph;
        var settings = this.settings;
        var dimensions = this.getDimensions();
        var nodeZExtent = [Infinity, -Infinity];
        var edgeZExtent = [Infinity, -Infinity];
        // Clearing the quad
        this.quadtree.clear();
        // Resetting the label grid
        // TODO: it's probably better to do this explicitly or on resizes for layout and anims
        this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);
        // Clear the highlightedNodes
        this.highlightedNodes = new Set();
        // Computing extents
        this.nodeExtent = (0, utils_1.graphExtent)(graph);
        // Resetting `forceLabel` indices
        this.nodesWithForcedLabels = [];
        this.edgesWithForcedLabels = [];
        // NOTE: it is important to compute this matrix after computing the node's extent
        // because #.getGraphDimensions relies on it
        var nullCamera = new camera_1.default();
        var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting("stagePadding") || 0);
        // Rescaling function
        this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);
        var nodesPerPrograms = {};
        var nodes = graph.nodes();
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            // Node display data resolution:
            //   1. First we get the node's attributes
            //   2. We optionally reduce them using the function provided by the user
            //      Note that this function must return a total object and won't be merged
            //   3. We apply our defaults, while running some vital checks
            //   4. We apply the normalization function
            // We shallow copy node data to avoid dangerous behaviors from reducers
            var attr = Object.assign({}, graph.getNodeAttributes(node));
            if (settings.nodeReducer)
                attr = settings.nodeReducer(node, attr);
            var data = applyNodeDefaults(this.settings, node, attr);
            nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;
            this.nodeDataCache[node] = data;
            this.normalizationFunction.applyTo(data);
            if (data.forceLabel)
                this.nodesWithForcedLabels.push(node);
            if (this.settings.zIndex) {
                if (data.zIndex < nodeZExtent[0])
                    nodeZExtent[0] = data.zIndex;
                if (data.zIndex > nodeZExtent[1])
                    nodeZExtent[1] = data.zIndex;
            }
        }
        for (var type in this.nodePrograms) {
            if (!this.nodePrograms.hasOwnProperty(type)) {
                throw new Error("Sigma: could not find a suitable program for node type \"".concat(type, "\"!"));
            }
            if (!keepArrays)
                this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);
            // We reset that count here, so that we can reuse it while calling the Program#process methods:
            nodesPerPrograms[type] = 0;
        }
        // Handling node z-index
        // TODO: z-index needs us to compute display data before hand
        if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1])
            nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) { return _this.nodeDataCache[node].zIndex; }, nodes);
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            var data = this.nodeDataCache[node];
            this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);
            if (typeof data.label === "string" && !data.hidden)
                this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));
            var nodeProgram = this.nodePrograms[data.type];
            if (!nodeProgram)
                throw new Error("Sigma: could not find a suitable program for node type \"".concat(data.type, "\"!"));
            nodeProgram.process(data, data.hidden, nodesPerPrograms[data.type]++);
            // Save the node in the highlighted set if needed
            if (data.highlighted && !data.hidden)
                this.highlightedNodes.add(node);
        }
        this.labelGrid.organize();
        var edgesPerPrograms = {};
        var edges = graph.edges();
        for (var i = 0, l = edges.length; i < l; i++) {
            var edge = edges[i];
            // Edge display data resolution:
            //   1. First we get the edge's attributes
            //   2. We optionally reduce them using the function provided by the user
            //      Note that this function must return a total object and won't be merged
            //   3. We apply our defaults, while running some vital checks
            // We shallow copy edge data to avoid dangerous behaviors from reducers
            var attr = Object.assign({}, graph.getEdgeAttributes(edge));
            if (settings.edgeReducer)
                attr = settings.edgeReducer(edge, attr);
            var data = applyEdgeDefaults(this.settings, edge, attr);
            edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;
            this.edgeDataCache[edge] = data;
            if (data.forceLabel && !data.hidden)
                this.edgesWithForcedLabels.push(edge);
            if (this.settings.zIndex) {
                if (data.zIndex < edgeZExtent[0])
                    edgeZExtent[0] = data.zIndex;
                if (data.zIndex > edgeZExtent[1])
                    edgeZExtent[1] = data.zIndex;
            }
        }
        for (var type in this.edgePrograms) {
            if (!this.edgePrograms.hasOwnProperty(type)) {
                throw new Error("Sigma: could not find a suitable program for edge type \"".concat(type, "\"!"));
            }
            if (!keepArrays)
                this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);
            // We reset that count here, so that we can reuse it while calling the Program#process methods:
            edgesPerPrograms[type] = 0;
        }
        // Handling edge z-index
        if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1])
            edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) { return _this.edgeDataCache[edge].zIndex; }, edges);
        for (var i = 0, l = edges.length; i < l; i++) {
            var edge = edges[i];
            var data = this.edgeDataCache[edge];
            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];
            var hidden = data.hidden || sourceData.hidden || targetData.hidden;
            this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);
        }
        for (var type in this.edgePrograms) {
            var program = this.edgePrograms[type];
            if (!keepArrays && typeof program.computeIndices === "function")
                program.computeIndices();
        }
        return this;
    };
    /**
     * Method that backports potential settings updates where it's needed.
     * @private
     */
    Sigma.prototype.handleSettingsUpdate = function () {
        this.camera.minRatio = this.settings.minCameraRatio;
        this.camera.maxRatio = this.settings.maxCameraRatio;
        this.camera.setState(this.camera.validateState(this.camera.getState()));
        return this;
    };
    /**
     * Method that decides whether to reprocess graph or not, and then render the
     * graph.
     *
     * @return {Sigma}
     */
    Sigma.prototype._refresh = function () {
        // Do we need to process data?
        if (this.needToProcess) {
            this.process();
        }
        else if (this.needToSoftProcess) {
            this.process(true);
        }
        // Resetting state
        this.needToProcess = false;
        this.needToSoftProcess = false;
        // Rendering
        this.render();
        return this;
    };
    /**
     * Method that schedules a `_refresh` call if none has been scheduled yet. It
     * will then be processed next available frame.
     *
     * @return {Sigma}
     */
    Sigma.prototype._scheduleRefresh = function () {
        var _this = this;
        if (!this.renderFrame) {
            this.renderFrame = (0, utils_1.requestFrame)(function () {
                _this._refresh();
                _this.renderFrame = null;
            });
        }
        return this;
    };
    /**
     * Method used to render labels.
     *
     * @return {Sigma}
     */
    Sigma.prototype.renderLabels = function () {
        if (!this.settings.renderLabels)
            return this;
        var cameraState = this.camera.getState();
        // Finding visible nodes to display their labels
        var visibleNodes;
        if (cameraState.ratio >= 1) {
            // Camera is unzoomed so no need to ask the quadtree for visible nodes
            visibleNodes = new Set(this.graph.nodes());
        }
        else {
            // Let's ask the quadtree
            var viewRectangle = this.viewRectangle();
            visibleNodes = new Set(this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height));
        }
        // Selecting labels to draw
        // TODO: drop gridsettings likewise
        // TODO: optimize through visible nodes
        var labelsToDisplay = this.labelGrid
            .getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity)
            .concat(this.nodesWithForcedLabels);
        this.displayedLabels = new Set();
        // Drawing labels
        var context = this.canvasContexts.labels;
        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {
            var node = labelsToDisplay[i];
            var data = this.nodeDataCache[node];
            // If the node was already drawn (like if it is eligible AND has
            // `forceLabel`), we don't want to draw it again
            if (this.displayedLabels.has(node))
                continue;
            // If the node is hidden, we don't need to display its label obviously
            if (data.hidden)
                continue;
            var _a = this.framedGraphToViewport(data), x = _a.x, y = _a.y;
            // TODO: we can cache the labels we need to render until the camera's ratio changes
            // TODO: this should be computed in the canvas components?
            var size = this.scaleSize(data.size);
            if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold)
                continue;
            if (!visibleNodes.has(node))
                continue;
            // TODO:
            // Because displayed edge labels depend directly on actually rendered node
            // labels, we need to only add to this.displayedLabels nodes whose label
            // is rendered.
            // This makes this.displayedLabels depend on viewport, which might become
            // an issue once we start memoizing getLabelsToDisplay.
            this.displayedLabels.add(node);
            this.settings.labelRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), this.settings);
        }
        return this;
    };
    /**
     * Method used to render edge labels, based on which node labels were
     * rendered.
     *
     * @return {Sigma}
     */
    Sigma.prototype.renderEdgeLabels = function () {
        if (!this.settings.renderEdgeLabels)
            return this;
        var context = this.canvasContexts.edgeLabels;
        // Clearing
        context.clearRect(0, 0, this.width, this.height);
        var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({
            graph: this.graph,
            hoveredNode: this.hoveredNode,
            displayedNodeLabels: this.displayedLabels,
            highlightedNodes: this.highlightedNodes,
        }).concat(this.edgesWithForcedLabels);
        var displayedLabels = new Set();
        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {
            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];
            // If the edge was already drawn (like if it is eligible AND has
            // `forceLabel`), we don't want to draw it again
            if (displayedLabels.has(edge))
                continue;
            // If the edge is hidden we don't need to display its label
            // NOTE: the test on sourceData & targetData is probably paranoid at this point?
            if (edgeData.hidden || sourceData.hidden || targetData.hidden) {
                continue;
            }
            this.settings.edgeLabelRenderer(context, __assign(__assign({ key: edge }, edgeData), { size: this.scaleSize(edgeData.size) }), __assign(__assign(__assign({ key: extremities[0] }, sourceData), this.framedGraphToViewport(sourceData)), { size: this.scaleSize(sourceData.size) }), __assign(__assign(__assign({ key: extremities[1] }, targetData), this.framedGraphToViewport(targetData)), { size: this.scaleSize(targetData.size) }), this.settings);
            displayedLabels.add(edge);
        }
        return this;
    };
    /**
     * Method used to render the highlighted nodes.
     *
     * @return {Sigma}
     */
    Sigma.prototype.renderHighlightedNodes = function () {
        var _this = this;
        var context = this.canvasContexts.hovers;
        // Clearing
        context.clearRect(0, 0, this.width, this.height);
        // Rendering
        var render = function (node) {
            var data = _this.nodeDataCache[node];
            var _a = _this.framedGraphToViewport(data), x = _a.x, y = _a.y;
            var size = _this.scaleSize(data.size);
            _this.settings.hoverRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), _this.settings);
        };
        var nodesToRender = [];
        if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {
            nodesToRender.push(this.hoveredNode);
        }
        this.highlightedNodes.forEach(function (node) {
            // The hovered node has already been highlighted
            if (node !== _this.hoveredNode)
                nodesToRender.push(node);
        });
        // Draw labels:
        nodesToRender.forEach(function (node) { return render(node); });
        // Draw WebGL nodes on top of the labels:
        var nodesPerPrograms = {};
        // 1. Count nodes per type:
        nodesToRender.forEach(function (node) {
            var type = _this.nodeDataCache[node].type;
            nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;
        });
        // 2. Allocate for each type for the proper number of nodes
        for (var type in this.hoverNodePrograms) {
            this.hoverNodePrograms[type].allocate(nodesPerPrograms[type] || 0);
            // Also reset count, to use when rendering:
            nodesPerPrograms[type] = 0;
        }
        // 3. Process all nodes to render:
        nodesToRender.forEach(function (node) {
            var data = _this.nodeDataCache[node];
            _this.hoverNodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);
        });
        // 4. Clear hovered nodes layer:
        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
        // 5. Render:
        for (var type in this.hoverNodePrograms) {
            var program = this.hoverNodePrograms[type];
            program.bind();
            program.bufferData();
            program.render({
                matrix: this.matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                correctionRatio: this.correctionRatio / this.camera.ratio,
                scalingRatio: this.pixelRatio,
            });
        }
    };
    /**
     * Method used to schedule a hover render.
     *
     */
    Sigma.prototype.scheduleHighlightedNodesRender = function () {
        var _this = this;
        if (this.renderHighlightedNodesFrame || this.renderFrame)
            return;
        this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {
            // Resetting state
            _this.renderHighlightedNodesFrame = null;
            // Rendering
            _this.renderHighlightedNodes();
            _this.renderEdgeLabels();
        });
    };
    /**
     * Method used to render.
     *
     * @return {Sigma}
     */
    Sigma.prototype.render = function () {
        var _this = this;
        this.emit("beforeRender");
        var handleEscape = function () {
            _this.emit("afterRender");
            return _this;
        };
        // If a render was scheduled, we cancel it
        if (this.renderFrame) {
            (0, utils_1.cancelFrame)(this.renderFrame);
            this.renderFrame = null;
            this.needToProcess = false;
            this.needToSoftProcess = false;
        }
        // First we need to resize
        this.resize();
        // Clearing the canvases
        this.clear();
        // Recomputing useful camera-related values:
        this.updateCachedValues();
        // If we have no nodes we can stop right there
        if (!this.graph.order)
            return handleEscape();
        // TODO: improve this heuristic or move to the captor itself?
        // TODO: deal with the touch captor here as well
        var mouseCaptor = this.mouseCaptor;
        var moving = this.camera.isAnimated() ||
            mouseCaptor.isMoving ||
            mouseCaptor.draggedEvents ||
            mouseCaptor.currentWheelDirection;
        // Then we need to extract a matrix from the camera
        var cameraState = this.camera.getState();
        var viewportDimensions = this.getDimensions();
        var graphDimensions = this.getGraphDimensions();
        var padding = this.getSetting("stagePadding") || 0;
        this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);
        this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);
        this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);
        // Drawing nodes
        for (var type in this.nodePrograms) {
            var program = this.nodePrograms[type];
            program.bind();
            program.bufferData();
            program.render({
                matrix: this.matrix,
                width: this.width,
                height: this.height,
                ratio: cameraState.ratio,
                correctionRatio: this.correctionRatio / cameraState.ratio,
                scalingRatio: this.pixelRatio,
            });
        }
        // Drawing edges
        if (!this.settings.hideEdgesOnMove || !moving) {
            for (var type in this.edgePrograms) {
                var program = this.edgePrograms[type];
                program.bind();
                program.bufferData();
                program.render({
                    matrix: this.matrix,
                    width: this.width,
                    height: this.height,
                    ratio: cameraState.ratio,
                    correctionRatio: this.correctionRatio / cameraState.ratio,
                    scalingRatio: this.pixelRatio,
                });
            }
        }
        // Do not display labels on move per setting
        if (this.settings.hideLabelsOnMove && moving)
            return handleEscape();
        this.renderLabels();
        this.renderEdgeLabels();
        this.renderHighlightedNodes();
        return handleEscape();
    };
    /**
     * Internal method used to update expensive and therefore cached values
     * each time the camera state is updated.
     */
    Sigma.prototype.updateCachedValues = function () {
        var ratio = this.camera.getState().ratio;
        this.cameraSizeRatio = Math.sqrt(ratio);
    };
    /**---------------------------------------------------------------------------
     * Public API.
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning the renderer's camera.
     *
     * @return {Camera}
     */
    Sigma.prototype.getCamera = function () {
        return this.camera;
    };
    /**
     * Method returning the container DOM element.
     *
     * @return {HTMLElement}
     */
    Sigma.prototype.getContainer = function () {
        return this.container;
    };
    /**
     * Method returning the renderer's graph.
     *
     * @return {Graph}
     */
    Sigma.prototype.getGraph = function () {
        return this.graph;
    };
    /**
     * Method returning the mouse captor.
     *
     * @return {MouseCaptor}
     */
    Sigma.prototype.getMouseCaptor = function () {
        return this.mouseCaptor;
    };
    /**
     * Method returning the touch captor.
     *
     * @return {TouchCaptor}
     */
    Sigma.prototype.getTouchCaptor = function () {
        return this.touchCaptor;
    };
    /**
     * Method returning the current renderer's dimensions.
     *
     * @return {Dimensions}
     */
    Sigma.prototype.getDimensions = function () {
        return { width: this.width, height: this.height };
    };
    /**
     * Method returning the current graph's dimensions.
     *
     * @return {Dimensions}
     */
    Sigma.prototype.getGraphDimensions = function () {
        var extent = this.customBBox || this.nodeExtent;
        return {
            width: extent.x[1] - extent.x[0] || 1,
            height: extent.y[1] - extent.y[0] || 1,
        };
    };
    /**
     * Method used to get all the sigma node attributes.
     * It's usefull for example to get the position of a node
     * and to get values that are set by the nodeReducer
     *
     * @param  {string} key - The node's key.
     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
     */
    Sigma.prototype.getNodeDisplayData = function (key) {
        var node = this.nodeDataCache[key];
        return node ? Object.assign({}, node) : undefined;
    };
    /**
     * Method used to get all the sigma edge attributes.
     * It's usefull for example to get values that are set by the edgeReducer.
     *
     * @param  {string} key - The edge's key.
     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
     */
    Sigma.prototype.getEdgeDisplayData = function (key) {
        var edge = this.edgeDataCache[key];
        return edge ? Object.assign({}, edge) : undefined;
    };
    /**
     * Method returning a copy of the settings collection.
     *
     * @return {Settings} A copy of the settings collection.
     */
    Sigma.prototype.getSettings = function () {
        return __assign({}, this.settings);
    };
    /**
     * Method returning the current value for a given setting key.
     *
     * @param  {string} key - The setting key to get.
     * @return {any} The value attached to this setting key or undefined if not found
     */
    Sigma.prototype.getSetting = function (key) {
        return this.settings[key];
    };
    /**
     * Method setting the value of a given setting key. Note that this will schedule
     * a new render next frame.
     *
     * @param  {string} key - The setting key to set.
     * @param  {any}    value - The value to set.
     * @return {Sigma}
     */
    Sigma.prototype.setSetting = function (key, value) {
        this.settings[key] = value;
        (0, settings_1.validateSettings)(this.settings);
        this.handleSettingsUpdate();
        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing
        this._scheduleRefresh();
        return this;
    };
    /**
     * Method updating the value of a given setting key using the provided function.
     * Note that this will schedule a new render next frame.
     *
     * @param  {string}   key     - The setting key to set.
     * @param  {function} updater - The update function.
     * @return {Sigma}
     */
    Sigma.prototype.updateSetting = function (key, updater) {
        this.settings[key] = updater(this.settings[key]);
        (0, settings_1.validateSettings)(this.settings);
        this.handleSettingsUpdate();
        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing
        this._scheduleRefresh();
        return this;
    };
    /**
     * Method used to resize the renderer.
     *
     * @return {Sigma}
     */
    Sigma.prototype.resize = function () {
        var previousWidth = this.width, previousHeight = this.height;
        this.width = this.container.offsetWidth;
        this.height = this.container.offsetHeight;
        this.pixelRatio = (0, utils_1.getPixelRatio)();
        if (this.width === 0) {
            if (this.settings.allowInvalidContainer)
                this.width = 1;
            else
                throw new Error("Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.");
        }
        if (this.height === 0) {
            if (this.settings.allowInvalidContainer)
                this.height = 1;
            else
                throw new Error("Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.");
        }
        // If nothing has changed, we can stop right here
        if (previousWidth === this.width && previousHeight === this.height)
            return this;
        this.emit("resize");
        // Sizing dom elements
        for (var id in this.elements) {
            var element = this.elements[id];
            element.style.width = this.width + "px";
            element.style.height = this.height + "px";
        }
        // Sizing canvas contexts
        for (var id in this.canvasContexts) {
            this.elements[id].setAttribute("width", this.width * this.pixelRatio + "px");
            this.elements[id].setAttribute("height", this.height * this.pixelRatio + "px");
            if (this.pixelRatio !== 1)
                this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);
        }
        // Sizing WebGL contexts
        for (var id in this.webGLContexts) {
            this.elements[id].setAttribute("width", this.width * this.pixelRatio + "px");
            this.elements[id].setAttribute("height", this.height * this.pixelRatio + "px");
            this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);
        }
        return this;
    };
    /**
     * Method used to clear all the canvases.
     *
     * @return {Sigma}
     */
    Sigma.prototype.clear = function () {
        this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);
        this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);
        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
        this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);
        this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);
        this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);
        return this;
    };
    /**
     * Method used to refresh all computed data.
     *
     * @return {Sigma}
     */
    Sigma.prototype.refresh = function () {
        this.needToProcess = true;
        this._refresh();
        return this;
    };
    /**
     * Method used to refresh all computed data, at the next available frame.
     * If this method has already been called this frame, then it will only render once at the next available frame.
     *
     * @return {Sigma}
     */
    Sigma.prototype.scheduleRefresh = function () {
        this.needToProcess = true;
        this._scheduleRefresh();
        return this;
    };
    /**
     * Method used to (un)zoom, while preserving the position of a viewport point.
     * Used for instance to zoom "on the mouse cursor".
     *
     * @param viewportTarget
     * @param newRatio
     * @return {CameraState}
     */
    Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {
        var _a = this.camera.getState(), ratio = _a.ratio, angle = _a.angle, x = _a.x, y = _a.y;
        // TODO: handle max zoom
        var ratioDiff = newRatio / ratio;
        var center = {
            x: this.width / 2,
            y: this.height / 2,
        };
        var graphMousePosition = this.viewportToFramedGraph(viewportTarget);
        var graphCenterPosition = this.viewportToFramedGraph(center);
        return {
            angle: angle,
            x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,
            y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,
            ratio: newRatio,
        };
    };
    /**
     * Method returning the abstract rectangle containing the graph according
     * to the camera's state.
     *
     * @return {object} - The view's rectangle.
     */
    Sigma.prototype.viewRectangle = function () {
        // TODO: reduce relative margin?
        var marginX = (0 * this.width) / 8, marginY = (0 * this.height) / 8;
        var p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }), p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }), h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });
        return {
            x1: p1.x,
            y1: p1.y,
            x2: p2.x,
            y2: p2.y,
            height: p2.y - h.y,
        };
    };
    /**
     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
    Sigma.prototype.framedGraphToViewport = function (coordinates, override) {
        if (override === void 0) { override = {}; }
        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;
        var matrix = override.matrix
            ? override.matrix
            : recomputeMatrix
                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting("stagePadding") || 0)
                : this.matrix;
        var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);
        return {
            x: ((1 + viewportPos.x) * this.width) / 2,
            y: ((1 - viewportPos.y) * this.height) / 2,
        };
    };
    /**
     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
    Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {
        if (override === void 0) { override = {}; }
        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;
        var invMatrix = override.matrix
            ? override.matrix
            : recomputeMatrix
                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting("stagePadding") || 0, true)
                : this.invMatrix;
        var res = (0, matrices_1.multiplyVec2)(invMatrix, {
            x: (coordinates.x / this.width) * 2 - 1,
            y: 1 - (coordinates.y / this.height) * 2,
        });
        if (isNaN(res.x))
            res.x = 0;
        if (isNaN(res.y))
            res.y = 0;
        return res;
    };
    /**
     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
     * stage) to the graph system (the reference system of data as they are in the given graph instance).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  viewportPoint
     * @param {CoordinateConversionOverride} override
     */
    Sigma.prototype.viewportToGraph = function (viewportPoint, override) {
        if (override === void 0) { override = {}; }
        return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));
    };
    /**
     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  graphPoint
     * @param {CoordinateConversionOverride} override
     */
    Sigma.prototype.graphToViewport = function (graphPoint, override) {
        if (override === void 0) { override = {}; }
        return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);
    };
    /**
     * Method returning the graph's bounding box.
     *
     * @return {{ x: Extent, y: Extent }}
     */
    Sigma.prototype.getBBox = function () {
        return (0, utils_1.graphExtent)(this.graph);
    };
    /**
     * Method returning the graph's custom bounding box, if any.
     *
     * @return {{ x: Extent, y: Extent } | null}
     */
    Sigma.prototype.getCustomBBox = function () {
        return this.customBBox;
    };
    /**
     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
     *
     * @return {Sigma}
     */
    Sigma.prototype.setCustomBBox = function (customBBox) {
        this.customBBox = customBBox;
        this._scheduleRefresh();
        return this;
    };
    /**
     * Method used to shut the container & release event listeners.
     *
     * @return {undefined}
     */
    Sigma.prototype.kill = function () {
        var graph = this.graph;
        // Emitting "kill" events so that plugins and such can cleanup
        this.emit("kill");
        // Releasing events
        this.removeAllListeners();
        // Releasing camera handlers
        this.camera.removeListener("updated", this.activeListeners.camera);
        // Releasing DOM events & captors
        window.removeEventListener("resize", this.activeListeners.handleResize);
        this.mouseCaptor.kill();
        this.touchCaptor.kill();
        // Releasing graph handlers
        graph.removeListener("nodeAdded", this.activeListeners.dropNodeGraphUpdate);
        graph.removeListener("nodeDropped", this.activeListeners.graphUpdate);
        graph.removeListener("nodeAttributesUpdated", this.activeListeners.softGraphUpdate);
        graph.removeListener("eachNodeAttributesUpdated", this.activeListeners.graphUpdate);
        graph.removeListener("edgeAdded", this.activeListeners.graphUpdate);
        graph.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
        graph.removeListener("edgeAttributesUpdated", this.activeListeners.softGraphUpdate);
        graph.removeListener("eachEdgeAttributesUpdated", this.activeListeners.graphUpdate);
        graph.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
        graph.removeListener("cleared", this.activeListeners.clearGraphUpdate);
        // Releasing cache & state
        this.quadtree = new quadtree_1.default();
        this.nodeDataCache = {};
        this.edgeDataCache = {};
        this.nodesWithForcedLabels = [];
        this.edgesWithForcedLabels = [];
        this.highlightedNodes.clear();
        // Clearing frames
        if (this.renderFrame) {
            (0, utils_1.cancelFrame)(this.renderFrame);
            this.renderFrame = null;
        }
        if (this.renderHighlightedNodesFrame) {
            (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);
            this.renderHighlightedNodesFrame = null;
        }
        // Destroying canvases
        var container = this.container;
        while (container.firstChild)
            container.removeChild(container.firstChild);
    };
    /**
     * Method used to scale the given size according to the camera's ratio, i.e.
     * zooming state.
     *
     * @param  {number} size - The size to scale (node size, edge thickness etc.).
     * @return {number}      - The scaled size.
     */
    Sigma.prototype.scaleSize = function (size) {
        return size / this.cameraSizeRatio;
    };
    /**
     * Method that returns the collection of all used canvases.
     * At the moment, the instantiated canvases are the following, and in the
     * following order in the DOM:
     * - `edges`
     * - `nodes`
     * - `edgeLabels`
     * - `labels`
     * - `hovers`
     * - `hoverNodes`
     * - `mouse`
     *
     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.
     */
    Sigma.prototype.getCanvases = function () {
        return __assign({}, this.elements);
    };
    return Sigma;
}(types_1.TypedEventEmitter));
exports["default"] = Sigma;


/***/ }),

/***/ "./node_modules/sigma/types.js":
/*!*************************************!*\
  !*** ./node_modules/sigma/types.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypedEventEmitter = void 0;
/**
 * Sigma.js Types
 * ===============
 *
 * Various type declarations used throughout the library.
 * @module
 */
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var TypedEventEmitter = /** @class */ (function (_super) {
    __extends(TypedEventEmitter, _super);
    function TypedEventEmitter() {
        var _this = _super.call(this) || this;
        _this.rawEmitter = _this;
        return _this;
    }
    return TypedEventEmitter;
}(events_1.EventEmitter));
exports.TypedEventEmitter = TypedEventEmitter;


/***/ }),

/***/ "./node_modules/sigma/utils/animate.js":
/*!*********************************************!*\
  !*** ./node_modules/sigma/utils/animate.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.animateNodes = exports.ANIMATE_DEFAULTS = void 0;
var index_1 = __webpack_require__(/*! ./index */ "./node_modules/sigma/utils/index.js");
var easings_1 = __importDefault(__webpack_require__(/*! ./easings */ "./node_modules/sigma/utils/easings.js"));
exports.ANIMATE_DEFAULTS = {
    easing: "quadraticInOut",
    duration: 150,
};
/**
 * Function used to animate the nodes.
 */
function animateNodes(graph, targets, opts, callback) {
    var options = Object.assign({}, exports.ANIMATE_DEFAULTS, opts);
    var easing = typeof options.easing === "function" ? options.easing : easings_1.default[options.easing];
    var start = Date.now();
    var startPositions = {};
    for (var node in targets) {
        var attrs = targets[node];
        startPositions[node] = {};
        for (var k in attrs)
            startPositions[node][k] = graph.getNodeAttribute(node, k);
    }
    var frame = null;
    var step = function () {
        frame = null;
        var p = (Date.now() - start) / options.duration;
        if (p >= 1) {
            // Animation is done
            for (var node in targets) {
                var attrs = targets[node];
                // We use given values to avoid precision issues and for convenience
                for (var k in attrs)
                    graph.setNodeAttribute(node, k, attrs[k]);
            }
            if (typeof callback === "function")
                callback();
            return;
        }
        p = easing(p);
        for (var node in targets) {
            var attrs = targets[node];
            var s = startPositions[node];
            for (var k in attrs)
                graph.setNodeAttribute(node, k, attrs[k] * p + s[k] * (1 - p));
        }
        frame = (0, index_1.requestFrame)(step);
    };
    step();
    return function () {
        if (frame)
            (0, index_1.cancelFrame)(frame);
    };
}
exports.animateNodes = animateNodes;


/***/ }),

/***/ "./node_modules/sigma/utils/data.js":
/*!******************************************!*\
  !*** ./node_modules/sigma/utils/data.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTML_COLORS = void 0;
exports.HTML_COLORS = {
    black: "#000000",
    silver: "#C0C0C0",
    gray: "#808080",
    grey: "#808080",
    white: "#FFFFFF",
    maroon: "#800000",
    red: "#FF0000",
    purple: "#800080",
    fuchsia: "#FF00FF",
    green: "#008000",
    lime: "#00FF00",
    olive: "#808000",
    yellow: "#FFFF00",
    navy: "#000080",
    blue: "#0000FF",
    teal: "#008080",
    aqua: "#00FFFF",
    darkblue: "#00008B",
    mediumblue: "#0000CD",
    darkgreen: "#006400",
    darkcyan: "#008B8B",
    deepskyblue: "#00BFFF",
    darkturquoise: "#00CED1",
    mediumspringgreen: "#00FA9A",
    springgreen: "#00FF7F",
    cyan: "#00FFFF",
    midnightblue: "#191970",
    dodgerblue: "#1E90FF",
    lightseagreen: "#20B2AA",
    forestgreen: "#228B22",
    seagreen: "#2E8B57",
    darkslategray: "#2F4F4F",
    darkslategrey: "#2F4F4F",
    limegreen: "#32CD32",
    mediumseagreen: "#3CB371",
    turquoise: "#40E0D0",
    royalblue: "#4169E1",
    steelblue: "#4682B4",
    darkslateblue: "#483D8B",
    mediumturquoise: "#48D1CC",
    indigo: "#4B0082",
    darkolivegreen: "#556B2F",
    cadetblue: "#5F9EA0",
    cornflowerblue: "#6495ED",
    rebeccapurple: "#663399",
    mediumaquamarine: "#66CDAA",
    dimgray: "#696969",
    dimgrey: "#696969",
    slateblue: "#6A5ACD",
    olivedrab: "#6B8E23",
    slategray: "#708090",
    slategrey: "#708090",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    mediumslateblue: "#7B68EE",
    lawngreen: "#7CFC00",
    chartreuse: "#7FFF00",
    aquamarine: "#7FFFD4",
    skyblue: "#87CEEB",
    lightskyblue: "#87CEFA",
    blueviolet: "#8A2BE2",
    darkred: "#8B0000",
    darkmagenta: "#8B008B",
    saddlebrown: "#8B4513",
    darkseagreen: "#8FBC8F",
    lightgreen: "#90EE90",
    mediumpurple: "#9370DB",
    darkviolet: "#9400D3",
    palegreen: "#98FB98",
    darkorchid: "#9932CC",
    yellowgreen: "#9ACD32",
    sienna: "#A0522D",
    brown: "#A52A2A",
    darkgray: "#A9A9A9",
    darkgrey: "#A9A9A9",
    lightblue: "#ADD8E6",
    greenyellow: "#ADFF2F",
    paleturquoise: "#AFEEEE",
    lightsteelblue: "#B0C4DE",
    powderblue: "#B0E0E6",
    firebrick: "#B22222",
    darkgoldenrod: "#B8860B",
    mediumorchid: "#BA55D3",
    rosybrown: "#BC8F8F",
    darkkhaki: "#BDB76B",
    mediumvioletred: "#C71585",
    indianred: "#CD5C5C",
    peru: "#CD853F",
    chocolate: "#D2691E",
    tan: "#D2B48C",
    lightgray: "#D3D3D3",
    lightgrey: "#D3D3D3",
    thistle: "#D8BFD8",
    orchid: "#DA70D6",
    goldenrod: "#DAA520",
    palevioletred: "#DB7093",
    crimson: "#DC143C",
    gainsboro: "#DCDCDC",
    plum: "#DDA0DD",
    burlywood: "#DEB887",
    lightcyan: "#E0FFFF",
    lavender: "#E6E6FA",
    darksalmon: "#E9967A",
    violet: "#EE82EE",
    palegoldenrod: "#EEE8AA",
    lightcoral: "#F08080",
    khaki: "#F0E68C",
    aliceblue: "#F0F8FF",
    honeydew: "#F0FFF0",
    azure: "#F0FFFF",
    sandybrown: "#F4A460",
    wheat: "#F5DEB3",
    beige: "#F5F5DC",
    whitesmoke: "#F5F5F5",
    mintcream: "#F5FFFA",
    ghostwhite: "#F8F8FF",
    salmon: "#FA8072",
    antiquewhite: "#FAEBD7",
    linen: "#FAF0E6",
    lightgoldenrodyellow: "#FAFAD2",
    oldlace: "#FDF5E6",
    magenta: "#FF00FF",
    deeppink: "#FF1493",
    orangered: "#FF4500",
    tomato: "#FF6347",
    hotpink: "#FF69B4",
    coral: "#FF7F50",
    darkorange: "#FF8C00",
    lightsalmon: "#FFA07A",
    orange: "#FFA500",
    lightpink: "#FFB6C1",
    pink: "#FFC0CB",
    gold: "#FFD700",
    peachpuff: "#FFDAB9",
    navajowhite: "#FFDEAD",
    moccasin: "#FFE4B5",
    bisque: "#FFE4C4",
    mistyrose: "#FFE4E1",
    blanchedalmond: "#FFEBCD",
    papayawhip: "#FFEFD5",
    lavenderblush: "#FFF0F5",
    seashell: "#FFF5EE",
    cornsilk: "#FFF8DC",
    lemonchiffon: "#FFFACD",
    floralwhite: "#FFFAF0",
    snow: "#FFFAFA",
    lightyellow: "#FFFFE0",
    ivory: "#FFFFF0",
};


/***/ }),

/***/ "./node_modules/sigma/utils/easings.js":
/*!*********************************************!*\
  !*** ./node_modules/sigma/utils/easings.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cubicInOut = exports.cubicOut = exports.cubicIn = exports.quadraticInOut = exports.quadraticOut = exports.quadraticIn = exports.linear = void 0;
/**
 * Sigma.js Easings
 * =================
 *
 * Handy collection of easing functions.
 * @module
 */
var linear = function (k) { return k; };
exports.linear = linear;
var quadraticIn = function (k) { return k * k; };
exports.quadraticIn = quadraticIn;
var quadraticOut = function (k) { return k * (2 - k); };
exports.quadraticOut = quadraticOut;
var quadraticInOut = function (k) {
    if ((k *= 2) < 1)
        return 0.5 * k * k;
    return -0.5 * (--k * (k - 2) - 1);
};
exports.quadraticInOut = quadraticInOut;
var cubicIn = function (k) { return k * k * k; };
exports.cubicIn = cubicIn;
var cubicOut = function (k) { return --k * k * k + 1; };
exports.cubicOut = cubicOut;
var cubicInOut = function (k) {
    if ((k *= 2) < 1)
        return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
};
exports.cubicInOut = cubicInOut;
var easings = {
    linear: exports.linear,
    quadraticIn: exports.quadraticIn,
    quadraticOut: exports.quadraticOut,
    quadraticInOut: exports.quadraticInOut,
    cubicIn: exports.cubicIn,
    cubicOut: exports.cubicOut,
    cubicInOut: exports.cubicInOut,
};
exports["default"] = easings;


/***/ }),

/***/ "./node_modules/sigma/utils/edge-collisions.js":
/*!*****************************************************!*\
  !*** ./node_modules/sigma/utils/edge-collisions.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doEdgeCollideWithPoint = exports.isPixelColored = void 0;
/**
 * This helper returns true is the pixel at (x,y) in the given WebGL context is
 * colored, and false else.
 */
function isPixelColored(gl, x, y) {
    var pixels = new Uint8Array(4);
    gl.readPixels(x, gl.drawingBufferHeight - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return pixels[3] > 0;
}
exports.isPixelColored = isPixelColored;
/**
 * This helper checks whether or not a point (x, y) collides with an
 * edge, connecting a source (xS, yS) to a target (xT, yT) with a thickness in
 * pixels.
 */
function doEdgeCollideWithPoint(x, y, xS, yS, xT, yT, thickness) {
    // Check first if point is out of the rectangle which opposite corners are the
    // source and the target, rectangle we expand by `thickness` in every
    // directions:
    if (x < xS - thickness && x < xT - thickness)
        return false;
    if (y < yS - thickness && y < yT - thickness)
        return false;
    if (x > xS + thickness && x > xT + thickness)
        return false;
    if (y > yS + thickness && y > yT + thickness)
        return false;
    // Check actual collision now: Since we now the point is in this big rectangle
    // we "just" need to check that the distance between the point and the line
    // connecting the source and the target is less than `thickness`:
    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
    var distance = Math.abs((xT - xS) * (yS - y) - (xS - x) * (yT - yS)) / Math.sqrt(Math.pow(xT - xS, 2) + Math.pow(yT - yS, 2));
    return distance < thickness / 2;
}
exports.doEdgeCollideWithPoint = doEdgeCollideWithPoint;


/***/ }),

/***/ "./node_modules/sigma/utils/index.js":
/*!*******************************************!*\
  !*** ./node_modules/sigma/utils/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateGraph = exports.canUse32BitsIndices = exports.extractPixel = exports.getMatrixImpact = exports.matrixFromCamera = exports.getCorrectionRatio = exports.floatColor = exports.floatArrayColor = exports.parseColor = exports.zIndexOrdering = exports.createNormalizationFunction = exports.graphExtent = exports.getPixelRatio = exports.createElement = exports.cancelFrame = exports.requestFrame = exports.assignDeep = exports.assign = exports.isPlainObject = void 0;
var is_graph_1 = __importDefault(__webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js"));
var matrices_1 = __webpack_require__(/*! ./matrices */ "./node_modules/sigma/utils/matrices.js");
var data_1 = __webpack_require__(/*! ./data */ "./node_modules/sigma/utils/data.js");
/**
 * Checks whether the given value is a plain object.
 *
 * @param  {mixed}   value - Target value.
 * @return {boolean}
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function isPlainObject(value) {
    return typeof value === "object" && value !== null && value.constructor === Object;
}
exports.isPlainObject = isPlainObject;
/**
 * Helper to use Object.assign with more than two objects.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
function assign(target) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    target = target || {};
    for (var i = 0, l = objects.length; i < l; i++) {
        var o = objects[i];
        if (!o)
            continue;
        Object.assign(target, o);
    }
    return target;
}
exports.assign = assign;
/**
 * Very simple recursive Object.assign-like function.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
function assignDeep(target) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    target = target || {};
    for (var i = 0, l = objects.length; i < l; i++) {
        var o = objects[i];
        if (!o)
            continue;
        for (var k in o) {
            if (isPlainObject(o[k])) {
                target[k] = assignDeep(target[k], o[k]);
            }
            else {
                target[k] = o[k];
            }
        }
    }
    return target;
}
exports.assignDeep = assignDeep;
/**
 * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame "work" in Node.js, for unit tests:
 */
exports.requestFrame = typeof requestAnimationFrame !== "undefined"
    ? function (callback) { return requestAnimationFrame(callback); }
    : function (callback) { return setTimeout(callback, 0); };
exports.cancelFrame = typeof cancelAnimationFrame !== "undefined"
    ? function (requestID) { return cancelAnimationFrame(requestID); }
    : function (requestID) { return clearTimeout(requestID); };
/**
 * Function used to create DOM elements easily.
 *
 * @param  {string} tag        - Tag name of the element to create.
 * @param  {object} style      - Styles map.
 * @param  {object} attributes - Attributes map.
 * @return {HTMLElement}
 */
function createElement(tag, style, attributes) {
    var element = document.createElement(tag);
    if (style) {
        for (var k in style) {
            element.style[k] = style[k];
        }
    }
    if (attributes) {
        for (var k in attributes) {
            element.setAttribute(k, attributes[k]);
        }
    }
    return element;
}
exports.createElement = createElement;
/**
 * Function returning the browser's pixel ratio.
 *
 * @return {number}
 */
function getPixelRatio() {
    if (typeof window.devicePixelRatio !== "undefined")
        return window.devicePixelRatio;
    return 1;
}
exports.getPixelRatio = getPixelRatio;
/**
 * Function returning the graph's node extent in x & y.
 *
 * @param  {Graph}
 * @return {object}
 */
function graphExtent(graph) {
    if (!graph.order)
        return { x: [0, 1], y: [0, 1] };
    var xMin = Infinity;
    var xMax = -Infinity;
    var yMin = Infinity;
    var yMax = -Infinity;
    graph.forEachNode(function (_, attr) {
        var x = attr.x, y = attr.y;
        if (x < xMin)
            xMin = x;
        if (x > xMax)
            xMax = x;
        if (y < yMin)
            yMin = y;
        if (y > yMax)
            yMax = y;
    });
    return { x: [xMin, xMax], y: [yMin, yMax] };
}
exports.graphExtent = graphExtent;
function createNormalizationFunction(extent) {
    var _a = __read(extent.x, 2), minX = _a[0], maxX = _a[1], _b = __read(extent.y, 2), minY = _b[0], maxY = _b[1];
    var ratio = Math.max(maxX - minX, maxY - minY), dX = (maxX + minX) / 2, dY = (maxY + minY) / 2;
    if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio))
        ratio = 1;
    if (isNaN(dX))
        dX = 0;
    if (isNaN(dY))
        dY = 0;
    var fn = function (data) {
        return {
            x: 0.5 + (data.x - dX) / ratio,
            y: 0.5 + (data.y - dY) / ratio,
        };
    };
    // TODO: possibility to apply this in batch over array of indices
    fn.applyTo = function (data) {
        data.x = 0.5 + (data.x - dX) / ratio;
        data.y = 0.5 + (data.y - dY) / ratio;
    };
    fn.inverse = function (data) {
        return {
            x: dX + ratio * (data.x - 0.5),
            y: dY + ratio * (data.y - 0.5),
        };
    };
    fn.ratio = ratio;
    return fn;
}
exports.createNormalizationFunction = createNormalizationFunction;
/**
 * Function ordering the given elements in reverse z-order so they drawn
 * the correct way.
 *
 * @param  {number}   extent   - [min, max] z values.
 * @param  {function} getter   - Z attribute getter function.
 * @param  {array}    elements - The array to sort.
 * @return {array} - The sorted array.
 */
function zIndexOrdering(extent, getter, elements) {
    // If k is > n, we'll use a standard sort
    return elements.sort(function (a, b) {
        var zA = getter(a) || 0, zB = getter(b) || 0;
        if (zA < zB)
            return -1;
        if (zA > zB)
            return 1;
        return 0;
    });
    // TODO: counting sort optimization
}
exports.zIndexOrdering = zIndexOrdering;
/**
 * WebGL utils
 * ===========
 */
/**
 * Memoized function returning a float-encoded color from various string
 * formats describing colors.
 */
var INT8 = new Int8Array(4);
var INT32 = new Int32Array(INT8.buffer, 0, 1);
var FLOAT32 = new Float32Array(INT8.buffer, 0, 1);
var RGBA_TEST_REGEX = /^\s*rgba?\s*\(/;
var RGBA_EXTRACT_REGEX = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;
function parseColor(val) {
    var r = 0; // byte
    var g = 0; // byte
    var b = 0; // byte
    var a = 1; // float
    // Handling hexadecimal notation
    if (val[0] === "#") {
        if (val.length === 4) {
            r = parseInt(val.charAt(1) + val.charAt(1), 16);
            g = parseInt(val.charAt(2) + val.charAt(2), 16);
            b = parseInt(val.charAt(3) + val.charAt(3), 16);
        }
        else {
            r = parseInt(val.charAt(1) + val.charAt(2), 16);
            g = parseInt(val.charAt(3) + val.charAt(4), 16);
            b = parseInt(val.charAt(5) + val.charAt(6), 16);
        }
        if (val.length === 9) {
            a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;
        }
    }
    // Handling rgb notation
    else if (RGBA_TEST_REGEX.test(val)) {
        var match = val.match(RGBA_EXTRACT_REGEX);
        if (match) {
            r = +match[1];
            g = +match[2];
            b = +match[3];
            if (match[4])
                a = +match[4];
        }
    }
    return { r: r, g: g, b: b, a: a };
}
exports.parseColor = parseColor;
var FLOAT_COLOR_CACHE = {};
for (var htmlColor in data_1.HTML_COLORS) {
    FLOAT_COLOR_CACHE[htmlColor] = floatColor(data_1.HTML_COLORS[htmlColor]);
    // Replicating cache for hex values for free
    FLOAT_COLOR_CACHE[data_1.HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];
}
function floatArrayColor(val) {
    val = data_1.HTML_COLORS[val] || val;
    // NOTE: this variant is not cached because it is mostly used for uniforms
    var _a = parseColor(val), r = _a.r, g = _a.g, b = _a.b, a = _a.a;
    return new Float32Array([r / 255, g / 255, b / 255, a]);
}
exports.floatArrayColor = floatArrayColor;
function floatColor(val) {
    // If the color is already computed, we yield it
    if (typeof FLOAT_COLOR_CACHE[val] !== "undefined")
        return FLOAT_COLOR_CACHE[val];
    var parsed = parseColor(val);
    var r = parsed.r, g = parsed.g, b = parsed.b;
    var a = parsed.a;
    a = (a * 255) | 0;
    INT32[0] = ((a << 24) | (b << 16) | (g << 8) | r) & 0xfeffffff;
    var color = FLOAT32[0];
    FLOAT_COLOR_CACHE[val] = color;
    return color;
}
exports.floatColor = floatColor;
/**
 * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This
 * helps dealing with quadtree in particular.
 * But at some point, we need to rescale it so that it takes the best place in the screen, ie. we always want to see two
 * nodes "touching" opposite sides of the graph, with the camera being at its default state.
 *
 * This function determines this ratio.
 */
function getCorrectionRatio(viewportDimensions, graphDimensions) {
    var viewportRatio = viewportDimensions.height / viewportDimensions.width;
    var graphRatio = graphDimensions.height / graphDimensions.width;
    // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage
    // is taller than wide), we can stop here to have indeed nodes touching opposite sides:
    if ((viewportRatio < 1 && graphRatio > 1) || (viewportRatio > 1 && graphRatio < 1)) {
        return 1;
    }
    // Else, we need to fit the graph inside the stage:
    // 1. If the graph is "squarer" (ie. with a ratio closer to 1), we need to make the largest sides touch;
    // 2. If the stage is "squarer", we need to make the smallest sides touch.
    return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));
}
exports.getCorrectionRatio = getCorrectionRatio;
/**
 * Function returning a matrix from the current state of the camera.
 */
// TODO: it's possible to optimize this drastically!
function matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {
    var angle = state.angle, ratio = state.ratio, x = state.x, y = state.y;
    var width = viewportDimensions.width, height = viewportDimensions.height;
    var matrix = (0, matrices_1.identity)();
    var smallestDimension = Math.min(width, height) - 2 * padding;
    var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);
    if (!inverse) {
        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), -angle));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 1 / ratio));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), -x, -y));
    }
    else {
        (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), x, y));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), ratio));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), angle));
        (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));
    }
    return matrix;
}
exports.matrixFromCamera = matrixFromCamera;
/**
 * All these transformations we apply on the matrix to get it rescale the graph
 * as we want make it very hard to get pixel-perfect distances in WebGL. This
 * function returns a factor that properly cancels the matrix effect on lengths.
 *
 * [jacomyal]
 * To be fully honest, I can't really explain happens here... I notice that the
 * following ratio works (ie. it correctly compensates the matrix impact on all
 * camera states I could try):
 * > `R = size(V) / size(M * V) / W`
 * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works
 * as well with H and a vector that transforms into something parallel to (Oy).
 *
 * Also, note that we use `angle` and not `-angle` (that would seem logical,
 * since we want to anticipate the rotation), because of the fact that in WebGL,
 * the image is vertically swapped.
 */
function getMatrixImpact(matrix, cameraState, viewportDimensions) {
    var _a = (0, matrices_1.multiplyVec2)(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0), x = _a.x, y = _a.y;
    return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;
}
exports.getMatrixImpact = getMatrixImpact;
/**
 * Function extracting the color at the given pixel.
 */
function extractPixel(gl, x, y, array) {
    var data = array || new Uint8Array(4);
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
    return data;
}
exports.extractPixel = extractPixel;
/**
 * Function used to know whether given webgl context can use 32 bits indices.
 */
function canUse32BitsIndices(gl) {
    var webgl2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
    return webgl2 || !!gl.getExtension("OES_element_index_uint");
}
exports.canUse32BitsIndices = canUse32BitsIndices;
/**
 * Check if the graph variable is a valid graph, and if sigma can render it.
 */
function validateGraph(graph) {
    // check if it's a valid graphology instance
    if (!(0, is_graph_1.default)(graph))
        throw new Error("Sigma: invalid graph instance.");
    // check if nodes have x/y attributes
    graph.forEachNode(function (key, attributes) {
        if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {
            throw new Error("Sigma: Coordinates of node ".concat(key, " are invalid. A node must have a numeric 'x' and 'y' attribute."));
        }
    });
}
exports.validateGraph = validateGraph;


/***/ }),

/***/ "./node_modules/sigma/utils/matrices.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/utils/matrices.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiplyVec2 = exports.multiply = exports.translate = exports.rotate = exports.scale = exports.identity = void 0;
function identity() {
    return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
}
exports.identity = identity;
// TODO: optimize
function scale(m, x, y) {
    m[0] = x;
    m[4] = typeof y === "number" ? y : x;
    return m;
}
exports.scale = scale;
function rotate(m, r) {
    var s = Math.sin(r), c = Math.cos(r);
    m[0] = c;
    m[1] = s;
    m[3] = -s;
    m[4] = c;
    return m;
}
exports.rotate = rotate;
function translate(m, x, y) {
    m[6] = x;
    m[7] = y;
    return m;
}
exports.translate = translate;
function multiply(a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    a[0] = b00 * a00 + b01 * a10 + b02 * a20;
    a[1] = b00 * a01 + b01 * a11 + b02 * a21;
    a[2] = b00 * a02 + b01 * a12 + b02 * a22;
    a[3] = b10 * a00 + b11 * a10 + b12 * a20;
    a[4] = b10 * a01 + b11 * a11 + b12 * a21;
    a[5] = b10 * a02 + b11 * a12 + b12 * a22;
    a[6] = b20 * a00 + b21 * a10 + b22 * a20;
    a[7] = b20 * a01 + b21 * a11 + b22 * a21;
    a[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return a;
}
exports.multiply = multiply;
function multiplyVec2(a, b, z) {
    if (z === void 0) { z = 1; }
    var a00 = a[0];
    var a01 = a[1];
    var a10 = a[3];
    var a11 = a[4];
    var a20 = a[6];
    var a21 = a[7];
    var b0 = b.x;
    var b1 = b.y;
    return { x: b0 * a00 + b1 * a10 + a20 * z, y: b0 * a01 + b1 * a11 + a21 * z };
}
exports.multiplyVec2 = multiplyVec2;


/***/ }),

/***/ "./src/chonkyArrows/edge.arrowHead.ts":
/*!********************************************!*\
  !*** ./src/chonkyArrows/edge.arrowHead.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sigma.js WebGL Renderer Arrow Program
 * ======================================
 *
 * Program rendering direction arrows as a simple triangle.
 * @module
 *
 * This file taken from sigma.js.
 * See https://github.com/jacomyal/sigma.js/blob/e187ba5b567eb359f2b4e438987785da73684667/src/rendering/webgl/programs/edge.arrowHead.ts
 */
const edge_arrowHead_vert_glsl_1 = __importDefault(__webpack_require__(/*! ./edge.arrowHead.vert.glsl */ "./src/chonkyArrows/edge.arrowHead.vert.glsl"));
const edge_arrowHead_frag_glsl_1 = __importDefault(__webpack_require__(/*! ./edge.arrowHead.frag.glsl */ "./src/chonkyArrows/edge.arrowHead.frag.glsl"));
const edge_1 = __webpack_require__(/*! sigma/rendering/webgl/programs/common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
const utils_1 = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/index.js");
const CHONKINESS = 1.5;
const POINTS = 3, ATTRIBUTES = 9, STRIDE = POINTS * ATTRIBUTES;
class ChonkyArrrowHeadProgram extends edge_1.AbstractEdgeProgram {
    constructor(gl) {
        super(gl, edge_arrowHead_vert_glsl_1.default, edge_arrowHead_frag_glsl_1.default, POINTS, ATTRIBUTES);
        // Locations
        this.positionLocation = gl.getAttribLocation(this.program, "a_position");
        this.colorLocation = gl.getAttribLocation(this.program, "a_color");
        this.normalLocation = gl.getAttribLocation(this.program, "a_normal");
        this.radiusLocation = gl.getAttribLocation(this.program, "a_radius");
        this.barycentricLocation = gl.getAttribLocation(this.program, "a_barycentric");
        // Uniform locations
        const matrixLocation = gl.getUniformLocation(this.program, "u_matrix");
        if (matrixLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting matrixLocation");
        this.matrixLocation = matrixLocation;
        const sqrtZoomRatioLocation = gl.getUniformLocation(this.program, "u_sqrtZoomRatio");
        if (sqrtZoomRatioLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting sqrtZoomRatioLocation");
        this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;
        const correctionRatioLocation = gl.getUniformLocation(this.program, "u_correctionRatio");
        if (correctionRatioLocation === null)
            throw new Error("EdgeArrowHeadProgram: error while getting correctionRatioLocation");
        this.correctionRatioLocation = correctionRatioLocation;
        this.bind();
    }
    bind() {
        const gl = this.gl;
        // Bindings
        gl.enableVertexAttribArray(this.positionLocation);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.enableVertexAttribArray(this.radiusLocation);
        gl.enableVertexAttribArray(this.colorLocation);
        gl.enableVertexAttribArray(this.barycentricLocation);
        gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);
        gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);
        gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);
        gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);
        // TODO: maybe we can optimize here by packing this in a bit mask
        gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);
    }
    computeIndices() {
        // nothing to do
    }
    process(sourceData, targetData, data, hidden, offset) {
        if (hidden) {
            for (let i = offset * STRIDE, l = i + STRIDE; i < l; i++)
                this.array[i] = 0;
            return;
        }
        const thickness = data.size || 1, radius = targetData.size || 1, x1 = sourceData.x, y1 = sourceData.y, x2 = targetData.x, y2 = targetData.y, color = (0, utils_1.floatColor)(data.color);
        // Computing normals
        const dx = x2 - x1, dy = y2 - y1;
        let len = dx * dx + dy * dy, n1 = 0, n2 = 0;
        if (len) {
            len = 1 / Math.sqrt(len);
            n1 = -dy * len * thickness * CHONKINESS;
            n2 = dx * len * thickness * CHONKINESS;
        }
        let i = POINTS * ATTRIBUTES * offset;
        const array = this.array;
        // First point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = 0;
        array[i++] = 0;
        // Second point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 1;
        array[i++] = 0;
        // Third point
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = -n1;
        array[i++] = -n2;
        array[i++] = radius;
        array[i++] = color;
        array[i++] = 0;
        array[i++] = 0;
        array[i] = 1;
    }
    render(params) {
        if (this.hasNothingToRender())
            return;
        const gl = this.gl;
        const program = this.program;
        gl.useProgram(program);
        // Binding uniforms
        gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);
        gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));
        gl.uniform1f(this.correctionRatioLocation, params.correctionRatio);
        // Drawing:
        gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);
    }
}
exports["default"] = ChonkyArrrowHeadProgram;


/***/ }),

/***/ "./src/chonkyArrows/index.ts":
/*!***********************************!*\
  !*** ./src/chonkyArrows/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Sigma.js WebGL Renderer Edge Arrow Program
 * ===========================================
 *
 * Compound program rendering edges as an arrow from the source to the target.
 * @module
 *
 * This file taken from sigma.js.
 * See https://github.com/jacomyal/sigma.js/blob/e187ba5b567eb359f2b4e438987785da73684667/src/rendering/webgl/programs/edge.arrow.ts
 */
const edge_1 = __webpack_require__(/*! sigma/rendering/webgl/programs/common/edge */ "./node_modules/sigma/rendering/webgl/programs/common/edge.js");
const edge_arrowHead_1 = __importDefault(__webpack_require__(/*! ./edge.arrowHead */ "./src/chonkyArrows/edge.arrowHead.ts"));
const edge_clamped_1 = __importDefault(__webpack_require__(/*! sigma/rendering/webgl/programs/edge.clamped */ "./node_modules/sigma/rendering/webgl/programs/edge.clamped.js"));
const ChonkyArrowProgram = (0, edge_1.createEdgeCompoundProgram)([
    edge_clamped_1.default,
    edge_arrowHead_1.default,
]);
exports["default"] = ChonkyArrowProgram;


/***/ }),

/***/ "./src/ingest.ts":
/*!***********************!*\
  !*** ./src/ingest.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildGraph = exports.jsonTextToGraphDef = void 0;
const graphology_1 = __webpack_require__(/*! graphology */ "./node_modules/graphology/dist/graphology.umd.min.js");
const graphology_layout_1 = __webpack_require__(/*! graphology-layout */ "./node_modules/graphology-layout/index.js");
const graphology_layout_forceatlas2_1 = __importDefault(__webpack_require__(/*! graphology-layout-forceatlas2 */ "./node_modules/graphology-layout-forceatlas2/index.js"));
function jsonTextToGraphDef(text) {
    const parsed = JSON.parse(text);
    const checkField = (obj, fieldName, check, required = true) => {
        if (obj[fieldName] == null) {
            if (required)
                throw `required property "${fieldName}" is missing, have ${JSON.stringify(obj)}`;
            else
                return;
        }
        const checkResult = check(obj[fieldName]);
        if (checkResult === false) {
            throw `field ${fieldName} fails type check`;
        }
    };
    const isString = (v) => typeof v === "string";
    const isNumber = (v) => typeof v === "number";
    const isObject = (v) => typeof v === "object";
    checkField(parsed, "title", isString, false);
    checkField(parsed, "nodes", (v) => isObject(v) &&
        Object.entries(v).every(([k, v]) => {
            if (!isString(k)) {
                return false;
            }
            checkField(v, "props", isObject, false);
            checkField(v, "color", isString, false);
            checkField(v, "label", isString, false);
            checkField(v, "weight", isNumber, false);
            return true;
        }));
    checkField(parsed, "edges", (edges) => Array.isArray(edges) &&
        edges.forEach((edge) => {
            checkField(edge, "to", isString);
            checkField(edge, "from", isString);
        }));
    return parsed;
}
exports.jsonTextToGraphDef = jsonTextToGraphDef;
function buildGraph(def) {
    const graph = new graphology_1.DirectedGraph();
    Object.entries(def.nodes).forEach(([id, node]) => graph.addNode(id, {
        nodeDef: node,
        color: node.color,
        label: node.label || id,
    }));
    const createNodeIfNotExists = (name) => {
        if (!graph.hasNode(name)) {
            graph.addNode(name, { label: name, nodeDef: {} });
        }
    };
    def.edges.forEach((edge) => {
        let amountNum = parseFloat(edge.amount || "1");
        if (isNaN(amountNum)) {
            console.warn(`amount on edge ${edge.from} -> ${edge.to} "${edge.amount}" is unparseable`);
            amountNum = 1;
        }
        createNodeIfNotExists(edge.from);
        createNodeIfNotExists(edge.to);
        graph.addEdge(edge.from, edge.to, {
            label: edge.label || edge.amount,
            weight: amountNum,
            type: "arrow",
            size: 3,
        });
    });
    const minSize = 5, maxSize = 25;
    const sizes = graph
        .mapNodes((node) => graph.getNodeAttribute(node, "nodeDef").weight)
        .filter((n) => n != null);
    const minExplicitNodeSize = Math.min(...sizes);
    const maxExplicitNodeSize = Math.max(...sizes);
    console.log(minExplicitNodeSize, maxExplicitNodeSize);
    // Use total edge weights for node size
    const totalTransfersByNode = graph
        .nodes()
        .map((node) => graph.reduceEdges(node, (acc, _edge, edgeAttrs) => acc + edgeAttrs.weight, 0));
    const minXfers = Math.min(...totalTransfersByNode);
    const maxXfers = Math.max(...totalTransfersByNode);
    const scaledSizeFor = (transferAmount) => minSize +
        ((transferAmount - minXfers) / (maxXfers - minXfers)) *
            (maxSize - minSize);
    const scaledExplicitSizeFor = (size) => minSize +
        ((size - minExplicitNodeSize) /
            (maxExplicitNodeSize - minExplicitNodeSize)) *
            (maxSize - minSize);
    graph.forEachNode((node) => {
        const totalTransfers = graph.reduceEdges(node, (acc, _edge, edgeAttrs) => acc + edgeAttrs.weight, 0);
        const nodeAttrs = graph.getNodeAttributes(node);
        const explicitSize = nodeAttrs.nodeDef.weight != null
            ? scaledExplicitSizeFor(nodeAttrs.nodeDef.weight)
            : null;
        graph.setNodeAttribute(node, "size", explicitSize ?? scaledSizeFor(totalTransfers));
    });
    // Position nodes on a circle, then run Force Atlas 2 for a while to get
    // proper graph layout:
    graphology_layout_1.circular.assign(graph);
    const settings = graphology_layout_forceatlas2_1.default.inferSettings(graph);
    graphology_layout_forceatlas2_1.default.assign(graph, { settings, iterations: 600 });
    // for debugging
    globalThis.graph = graph;
    return graph;
}
exports.buildGraph = buildGraph;


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.View = exports.SigmaGraphView = exports.TableNodeDataView = void 0;
const sigma_1 = __importDefault(__webpack_require__(/*! sigma */ "./node_modules/sigma/index.js"));
const chonkyArrows_1 = __importDefault(__webpack_require__(/*! ./chonkyArrows */ "./src/chonkyArrows/index.ts"));
// FIXME: this might be good to replace with react and TSX. the stock DOM
// stuff sucks
class TableNodeDataView {
    constructor(elem) {
        this.table = elem.querySelector("[data-node-table]");
        this.nameElem = elem.querySelector("[data-node-name]");
    }
    renderProperty(intoEl, id, value) {
        const SPECIALS = {
            googleSearch: () => {
                const anchor = document.createElement("a");
                anchor.href = `https://google.com/search?q=${encodeURIComponent(value)}`;
                anchor.textContent = value;
                intoEl.appendChild(anchor);
            },
        };
        const defaultRender = () => {
            intoEl.textContent = value;
        };
        // XXX: type crimes?
        const renderFunc = SPECIALS[id] || defaultRender;
        renderFunc();
    }
    onNodeSelected(nodeId, node) {
        if (this.table.tBodies[0])
            this.table.tBodies[0].remove();
        this.nameElem.textContent = node.label || nodeId;
        const tbody = this.table.createTBody();
        for (const [prop, val] of Object.entries(node.props || {})) {
            const row = document.createElement("tr");
            const nameEl = document.createElement("td");
            const valueEl = document.createElement("td");
            nameEl.textContent = prop;
            this.renderProperty(valueEl, prop, val);
            row.appendChild(nameEl);
            row.appendChild(valueEl);
            tbody.appendChild(row);
        }
    }
}
exports.TableNodeDataView = TableNodeDataView;
class SigmaGraphView {
    constructor(sigma) {
        this.onNodeSelected = () => undefined;
        this.state = { hoveredNode: null, highlightNodes: null };
        this.sigma = sigma;
        this.nodeReducer = this.nodeReducer.bind(this);
        sigma.setSetting("nodeReducer", this.nodeReducer);
        sigma.addListener("clickNode", (payload) => {
            const graph = sigma.getGraph();
            const nodeDef = graph.getNodeAttribute(payload.node, "nodeDef");
            this.onNodeSelected(payload.node, nodeDef);
        });
        sigma.addListener("enterNode", (payload) => {
            const hoveredNode = payload.node;
            const graph = this.sigma.getGraph();
            this.state.highlightNodes = new Set(graph.neighbors(hoveredNode));
            this.state.hoveredNode = hoveredNode;
        });
        sigma.addListener("leaveNode", (_payload) => {
            this.state.hoveredNode = null;
            this.state.highlightNodes = null;
        });
    }
    nodeReducer(node, data) {
        const res = { ...data };
        if (node === this.state.hoveredNode) {
            res.highlighted = true;
        }
        if (this.state.highlightNodes &&
            this.state.hoveredNode !== node &&
            !this.state.highlightNodes.has(node)) {
            res.color = "#eee";
            res.label = "";
        }
        return res;
    }
    kill() {
        this.sigma.kill();
    }
}
exports.SigmaGraphView = SigmaGraphView;
class View {
    constructor(graph, graphContainer, propsContainer) {
        this.nodeDataView = new TableNodeDataView(propsContainer);
        this.sigmaGraphView = new SigmaGraphView(new sigma_1.default(graph, graphContainer, {
            renderEdgeLabels: true,
            edgeProgramClasses: {
                arrow: chonkyArrows_1.default,
            },
        }));
        this.sigmaGraphView.onNodeSelected = (nodeId, node) => this.nodeDataView.onNodeSelected(nodeId, node);
    }
    kill() {
        this.sigmaGraphView.kill();
    }
}
exports.View = View;


/***/ }),

/***/ "./src/chonkyArrows/edge.arrowHead.frag.glsl":
/*!***************************************************!*\
  !*** ./src/chonkyArrows/edge.arrowHead.frag.glsl ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = "/*\n * This file taken from sigma.js.\n * See https://github.com/jacomyal/sigma.js/blob/e187ba5b567eb359f2b4e438987785da73684667/src/rendering/webgl/shaders/edge.arrowHead.frag.glsl\n */\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";

/***/ }),

/***/ "./src/chonkyArrows/edge.arrowHead.vert.glsl":
/*!***************************************************!*\
  !*** ./src/chonkyArrows/edge.arrowHead.vert.glsl ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = "/*\n * This file taken from sigma.js.\n * See https://github.com/jacomyal/sigma.js/blob/e187ba5b567eb359f2b4e438987785da73684667/src/rendering/webgl/shaders/edge.arrowHead.vert.glsl\n */\nattribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec4 a_color;\nattribute vec3 a_barycentric;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadWidthLengthRatio = 0.66;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sqrtZoomRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float adaptedWebGLThickness = webGLThickness * u_sqrtZoomRatio;\n  float adaptedWebGLNodeRadius = a_radius * 2.0 * u_correctionRatio * u_sqrtZoomRatio;\n  float adaptedWebGLArrowHeadLength = adaptedWebGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n  float adaptedWebGLArrowHeadHalfWidth = adaptedWebGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (adaptedWebGLNodeRadius * unitNormal.y)\n    + db * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y + adaptedWebGLArrowHeadHalfWidth * unitNormal.x)\n    + dc * ((adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.y - adaptedWebGLArrowHeadHalfWidth * unitNormal.x),\n\n      da * (-adaptedWebGLNodeRadius * unitNormal.x)\n    + db * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x + adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n    + dc * (-(adaptedWebGLNodeRadius + adaptedWebGLArrowHeadLength) * unitNormal.x - adaptedWebGLArrowHeadHalfWidth * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ingest_1 = __webpack_require__(/*! ./ingest */ "./src/ingest.ts");
const renderer_1 = __webpack_require__(/*! ./renderer */ "./src/renderer.ts");
function startup() {
    const textControl = document.getElementById("paste-json");
    let myView;
    const graphContainer = document.getElementById("sigma-container");
    const loading = document.getElementById("loading-indication");
    const failures = document.getElementById("failures");
    const nodeDataView = document.getElementById("properties-table");
    async function onAcceptText(text) {
        loading.style.display = "block";
        setTimeout(() => onLoad(text), 0);
    }
    async function onLoad(content, title) {
        if (myView) {
            console.log("kill");
            myView.kill();
            myView = undefined;
            console.log("done");
        }
        let graphDef;
        let graph;
        try {
            graphDef = (0, ingest_1.jsonTextToGraphDef)(content);
            graph = (0, ingest_1.buildGraph)(graphDef);
        }
        catch (e) {
            failures.textContent = `Failed to parse JSON, try copying it again: ${e.toString()}`;
            console.error(e);
            loading.style.display = "none";
            return;
        }
        loading.style.display = "none";
        failures.textContent = "";
        document.title = `${graphDef.title || title || "untitled"} - Looking Glass 🔎`;
        myView = new renderer_1.View(graph, graphContainer, nodeDataView);
    }
    textControl.addEventListener("paste", (ev) => {
        ev.preventDefault();
        const data = ev.clipboardData?.getData("text/plain");
        if (!data) {
            throw "Clipboard data is null?";
        }
        onAcceptText(data);
    });
    (async () => {
        let json;
        try {
            json = await (await fetch("preloaded-data.json")).text();
        }
        catch (e) { }
        ;
        json === undefined || onAcceptText(json);
    })();
}
startup();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3h4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOEVBQTJCO0FBQ3pELGNBQWMsbUJBQU8sQ0FBQyw4RUFBMkI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLG9GQUE4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7Ozs7Ozs7Ozs7O0FDekRQO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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InNvdXJjZXMiOlsid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvQHlvbWd1aXRoZXJlYWwvaGVscGVycy9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1mb3JjZWF0bGFzMi9oZWxwZXJzLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1mb3JjZWF0bGFzMi9pdGVyYXRlLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQvY2lyY2xlcGFjay5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktbGF5b3V0L2NpcmN1bGFyLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC9yb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktdXRpbHMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS9kaXN0L2dyYXBob2xvZ3kudW1kLm1pbi5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3BhbmRlbW9uaXVtL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3BhbmRlbW9uaXVtL3NodWZmbGUtaW4tcGxhY2UuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9jb3JlL2NhbWVyYS5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2NvcmUvY2FwdG9ycy9jYXB0b3IuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9jb3JlL2NhcHRvcnMvbW91c2UuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9jb3JlL2NhcHRvcnMvdG91Y2guanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9jb3JlL2xhYmVscy5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2NvcmUvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9pbmRleC5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3JlbmRlcmluZy9jYW52YXMvZWRnZS1sYWJlbC5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3JlbmRlcmluZy9jYW52YXMvaG92ZXIuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvY2FudmFzL2xhYmVsLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2NvbW1vbi9lZGdlLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2NvbW1vbi9ub2RlLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2NvbW1vbi9wcm9ncmFtLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2VkZ2UuYXJyb3cuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvd2ViZ2wvcHJvZ3JhbXMvZWRnZS5hcnJvd0hlYWQuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvd2ViZ2wvcHJvZ3JhbXMvZWRnZS5jbGFtcGVkLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2VkZ2UuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvd2ViZ2wvcHJvZ3JhbXMvbm9kZS5mYXN0LmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3NoYWRlcnMvZWRnZS5hcnJvd0hlYWQuZnJhZy5nbHNsLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3NoYWRlcnMvZWRnZS5hcnJvd0hlYWQudmVydC5nbHNsLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3NoYWRlcnMvZWRnZS5jbGFtcGVkLnZlcnQuZ2xzbC5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3JlbmRlcmluZy93ZWJnbC9zaGFkZXJzL2VkZ2UuZnJhZy5nbHNsLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3NoYWRlcnMvZWRnZS52ZXJ0Lmdsc2wuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvd2ViZ2wvc2hhZGVycy9ub2RlLmZhc3QuZnJhZy5nbHNsLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL3dlYmdsL3NoYWRlcnMvbm9kZS5mYXN0LnZlcnQuZ2xzbC5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3JlbmRlcmluZy93ZWJnbC9zaGFkZXJzL3V0aWxzLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS9zaWdtYS5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3R5cGVzLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvdXRpbHMvYW5pbWF0ZS5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vbm9kZV9tb2R1bGVzL3NpZ21hL3V0aWxzL2RhdGEuanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS91dGlscy9lYXNpbmdzLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvdXRpbHMvZWRnZS1jb2xsaXNpb25zLmpzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3MvLi9ub2RlX21vZHVsZXMvc2lnbWEvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL25vZGVfbW9kdWxlcy9zaWdtYS91dGlscy9tYXRyaWNlcy5qcyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vc3JjL2Nob25reUFycm93cy9lZGdlLmFycm93SGVhZC50cyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vc3JjL2Nob25reUFycm93cy9pbmRleC50cyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vc3JjL2luZ2VzdC50cyIsIndlYnBhY2s6Ly9sb29raW5nLWdsYXNzLy4vc3JjL3JlbmRlcmVyLnRzIiwid2VicGFjazovL2xvb2tpbmctZ2xhc3Mvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbG9va2luZy1nbGFzcy8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVuZCBmdW5jdGlvblxuICogPT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gcHVzaCBhIGJ1bmNoIG9mIHZhbHVlcyBpbnRvIGFuIGFycmF5IGF0IG9uY2UuXG4gKlxuICogSXRzIHN0cmF0ZWd5IGlzIHRvIG11dGF0ZSB0YXJnZXQgYXJyYXkncyBsZW5ndGggdGhlbiBzZXR0aW5nIHRoZSBuZXcgaW5kaWNlc1xuICogdG8gYmUgdGhlIHZhbHVlcyB0byBhZGQuXG4gKlxuICogQSBiZW5jaG1hcmsgcHJvdmVkIHRoYXQgaXQgaXMgZmFzdGVyIHRoYW4gdGhlIGZvbGxvd2luZyBzdHJhdGVnaWVzOlxuICogICAxKSBgYXJyYXkucHVzaC5hcHBseShhcnJheSwgdmFsdWVzKWAuXG4gKiAgIDIpIEEgbG9vcCBvZiBwdXNoZXMuXG4gKiAgIDMpIGBhcnJheSA9IGFycmF5LmNvbmNhdCh2YWx1ZXMpYCwgb2J2aW91c2x5LlxuICpcbiAqIEludHVpdGl2ZWx5LCB0aGlzIGlzIGNvcnJlY3QgYmVjYXVzZSB3aGVuIGFkZGluZyBhIGxvdCBvZiBlbGVtZW50cywgdGhlXG4gKiBjaG9zZW4gc3RyYXRlZ2llcyBkb2VzIG5vdCBuZWVkIHRvIGhhbmRsZSB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0IHRvXG4gKiBleGVjdXRlICMuYXBwbHkncyB2YXJpYWRpY2l0eSBhbmQgYmVjYXVzZSB0aGUgYXJyYXkga25vdyBpdHMgZmluYWwgbGVuZ3RoXG4gKiBhdCB0aGUgYmVnaW5uaW5nLCBhdm9pZGluZyBwb3RlbnRpYWwgbXVsdGlwbGUgcmVhbGxvY2F0aW9ucyBvZiB0aGUgdW5kZXJseWluZ1xuICogY29udGlndW91cyBhcnJheS4gU29tZSBlbmdpbmVzIG1heSBiZSBhYmxlIHRvIG9wdGltaXplIHRoZSBsb29wIG9mIHB1c2hcbiAqIG9wZXJhdGlvbnMgYnV0IGVtcGlyaWNhbGx5IHRoZXkgZG9uJ3Qgc2VlbSB0byBkbyBzby5cbiAqL1xuXG4vKipcbiAqIEV4dGVuZHMgdGhlIHRhcmdldCBhcnJheSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IGFycmF5ICAtIFRhcmdldCBhcnJheS5cbiAqIEBwYXJhbSAge2FycmF5fSB2YWx1ZXMgLSBWYWx1ZXMgdG8gYWRkLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBsMiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKGwyID09PSAwKVxuICAgIHJldHVybjtcblxuICB2YXIgbDEgPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkubGVuZ3RoICs9IGwyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDI7IGkrKylcbiAgICBhcnJheVtsMSArIGldID0gdmFsdWVzW2ldO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgRm9yY2VBdGxhczIgTGF5b3V0IERlZmF1bHQgU2V0dGluZ3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsaW5Mb2dNb2RlOiBmYWxzZSxcbiAgb3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uOiBmYWxzZSxcbiAgYWRqdXN0U2l6ZXM6IGZhbHNlLFxuICBlZGdlV2VpZ2h0SW5mbHVlbmNlOiAxLFxuICBzY2FsaW5nUmF0aW86IDEsXG4gIHN0cm9uZ0dyYXZpdHlNb2RlOiBmYWxzZSxcbiAgZ3Jhdml0eTogMSxcbiAgc2xvd0Rvd246IDEsXG4gIGJhcm5lc0h1dE9wdGltaXplOiBmYWxzZSxcbiAgYmFybmVzSHV0VGhldGE6IDAuNVxufTtcbiIsIi8qKlxuICogR3JhcGhvbG9neSBGb3JjZUF0bGFzMiBIZWxwZXJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTWlzY2VsbGFuZW91cyBoZWxwZXIgZnVuY3Rpb25zLlxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG52YXIgUFBOID0gMTA7XG52YXIgUFBFID0gMztcblxuLyoqXG4gKiBWZXJ5IHNpbXBsZSBPYmplY3QuYXNzaWduLWxpa2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgICAgICAgLSBGaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0gIHtvYmplY3R9IFsuLi5vYmplY3RzXSAtIE9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cbiAgdmFyIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDEpLFxuICAgIGksXG4gICAgayxcbiAgICBsO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICghb2JqZWN0c1tpXSkgY29udGludWU7XG5cbiAgICBmb3IgKGsgaW4gb2JqZWN0c1tpXSkgdGFyZ2V0W2tdID0gb2JqZWN0c1tpXVtrXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGdpdmVuIHNldHRpbmdzLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICBzZXR0aW5ncyAtIFNldHRpbmdzIHRvIHZhbGlkYXRlLlxuICogQHJldHVybiB7b2JqZWN0fG51bGx9XG4gKi9cbmV4cG9ydHMudmFsaWRhdGVTZXR0aW5ncyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICBpZiAoJ2xpbkxvZ01vZGUnIGluIHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5saW5Mb2dNb2RlICE9PSAnYm9vbGVhbicpXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBsaW5Mb2dNb2RlYCBzZXR0aW5nIHNob3VsZCBiZSBhIGJvb2xlYW4uJ307XG5cbiAgaWYgKFxuICAgICdvdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24nIGluIHNldHRpbmdzICYmXG4gICAgdHlwZW9mIHNldHRpbmdzLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbiAhPT0gJ2Jvb2xlYW4nXG4gIClcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ3RoZSBgb3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uYCBzZXR0aW5nIHNob3VsZCBiZSBhIGJvb2xlYW4uJ1xuICAgIH07XG5cbiAgaWYgKCdhZGp1c3RTaXplcycgaW4gc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFkanVzdFNpemVzICE9PSAnYm9vbGVhbicpXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBhZGp1c3RTaXplc2Agc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnZWRnZVdlaWdodEluZmx1ZW5jZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3MuZWRnZVdlaWdodEluZmx1ZW5jZSAhPT0gJ251bWJlcidcbiAgKVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiAndGhlIGBlZGdlV2VpZ2h0SW5mbHVlbmNlYCBzZXR0aW5nIHNob3VsZCBiZSBhIG51bWJlci4nXG4gICAgfTtcblxuICBpZiAoXG4gICAgJ3NjYWxpbmdSYXRpbycgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5zY2FsaW5nUmF0aW8gPT09ICdudW1iZXInICYmIHNldHRpbmdzLnNjYWxpbmdSYXRpbyA+PSAwKVxuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBzY2FsaW5nUmF0aW9gIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdzdHJvbmdHcmF2aXR5TW9kZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3Muc3Ryb25nR3Jhdml0eU1vZGUgIT09ICdib29sZWFuJ1xuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBzdHJvbmdHcmF2aXR5TW9kZWAgc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnZ3Jhdml0eScgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5ncmF2aXR5ID09PSAnbnVtYmVyJyAmJiBzZXR0aW5ncy5ncmF2aXR5ID49IDApXG4gIClcbiAgICByZXR1cm4ge21lc3NhZ2U6ICd0aGUgYGdyYXZpdHlgIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdzbG93RG93bicgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5zbG93RG93biA9PT0gJ251bWJlcicgfHwgc2V0dGluZ3Muc2xvd0Rvd24gPj0gMClcbiAgKVxuICAgIHJldHVybiB7bWVzc2FnZTogJ3RoZSBgc2xvd0Rvd25gIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdiYXJuZXNIdXRPcHRpbWl6ZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3MuYmFybmVzSHV0T3B0aW1pemUgIT09ICdib29sZWFuJ1xuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBiYXJuZXNIdXRPcHRpbWl6ZWAgc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnYmFybmVzSHV0VGhldGEnIGluIHNldHRpbmdzICYmXG4gICAgIShcbiAgICAgIHR5cGVvZiBzZXR0aW5ncy5iYXJuZXNIdXRUaGV0YSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHNldHRpbmdzLmJhcm5lc0h1dFRoZXRhID49IDBcbiAgICApXG4gIClcbiAgICByZXR1cm4ge21lc3NhZ2U6ICd0aGUgYGJhcm5lc0h1dFRoZXRhYCBzZXR0aW5nIHNob3VsZCBiZSBhIG51bWJlciA+PSAwLid9O1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBnZW5lcmF0aW5nIGEgZmxhdCBtYXRyaXggZm9yIGJvdGggbm9kZXMgJiBlZGdlcyBvZiB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZ2V0RWRnZVdlaWdodCAtIEVkZ2Ugd2VpZ2h0IGdldHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgIC0gQm90aCBtYXRyaWNlcy5cbiAqL1xuZXhwb3J0cy5ncmFwaFRvQnl0ZUFycmF5cyA9IGZ1bmN0aW9uIChncmFwaCwgZ2V0RWRnZVdlaWdodCkge1xuICB2YXIgb3JkZXIgPSBncmFwaC5vcmRlcjtcbiAgdmFyIHNpemUgPSBncmFwaC5zaXplO1xuICB2YXIgaW5kZXggPSB7fTtcbiAgdmFyIGo7XG5cbiAgLy8gTk9URTogZmxvYXQzMiBjb3VsZCBsZWFkIHRvIGlzc3VlcyBpZiBlZGdlIGFycmF5IG5lZWRzIHRvIGluZGV4IGxhcmdlXG4gIC8vIG51bWJlciBvZiBub2Rlcy5cbiAgdmFyIE5vZGVNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KG9yZGVyICogUFBOKTtcbiAgdmFyIEVkZ2VNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBQUEUpO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBub2Rlc1xuICBqID0gMDtcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAvLyBOb2RlIGluZGV4XG4gICAgaW5kZXhbbm9kZV0gPSBqO1xuXG4gICAgLy8gUG9wdWxhdGluZyBieXRlIGFycmF5XG4gICAgTm9kZU1hdHJpeFtqXSA9IGF0dHIueDtcbiAgICBOb2RlTWF0cml4W2ogKyAxXSA9IGF0dHIueTtcbiAgICBOb2RlTWF0cml4W2ogKyAyXSA9IDA7IC8vIGR4XG4gICAgTm9kZU1hdHJpeFtqICsgM10gPSAwOyAvLyBkeVxuICAgIE5vZGVNYXRyaXhbaiArIDRdID0gMDsgLy8gb2xkX2R4XG4gICAgTm9kZU1hdHJpeFtqICsgNV0gPSAwOyAvLyBvbGRfZHlcbiAgICBOb2RlTWF0cml4W2ogKyA2XSA9IDE7IC8vIG1hc3NcbiAgICBOb2RlTWF0cml4W2ogKyA3XSA9IDE7IC8vIGNvbnZlcmdlbmNlXG4gICAgTm9kZU1hdHJpeFtqICsgOF0gPSBhdHRyLnNpemUgfHwgMTtcbiAgICBOb2RlTWF0cml4W2ogKyA5XSA9IGF0dHIuZml4ZWQgPyAxIDogMDtcbiAgICBqICs9IFBQTjtcbiAgfSk7XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVkZ2VzXG4gIGogPSAwO1xuICBncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgYXR0ciwgc291cmNlLCB0YXJnZXQsIHNhLCB0YSwgdSkge1xuICAgIHZhciBzaiA9IGluZGV4W3NvdXJjZV07XG4gICAgdmFyIHRqID0gaW5kZXhbdGFyZ2V0XTtcblxuICAgIC8vIEhhbmRsaW5nIG5vZGUgbWFzcyB0aHJvdWdoIGRlZ3JlZVxuICAgIE5vZGVNYXRyaXhbc2ogKyA2XSArPSAxO1xuICAgIE5vZGVNYXRyaXhbdGogKyA2XSArPSAxO1xuXG4gICAgLy8gUG9wdWxhdGluZyBieXRlIGFycmF5XG4gICAgRWRnZU1hdHJpeFtqXSA9IHNqO1xuICAgIEVkZ2VNYXRyaXhbaiArIDFdID0gdGo7XG4gICAgRWRnZU1hdHJpeFtqICsgMl0gPSBnZXRFZGdlV2VpZ2h0KGVkZ2UsIGF0dHIsIHNvdXJjZSwgdGFyZ2V0LCBzYSwgdGEsIHUpO1xuICAgIGogKz0gUFBFO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG5vZGVzOiBOb2RlTWF0cml4LFxuICAgIGVkZ2VzOiBFZGdlTWF0cml4XG4gIH07XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGFwcGx5aW5nIHRoZSBsYXlvdXQgYmFjayB0byB0aGUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gICAgICAgICBncmFwaCAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9ICBOb2RlTWF0cml4ICAgIC0gTm9kZSBtYXRyaXguXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IG91dHB1dFJlZHVjZXIgLSBBIG5vZGUgcmVkdWNlci5cbiAqL1xuZXhwb3J0cy5hc3NpZ25MYXlvdXRDaGFuZ2VzID0gZnVuY3Rpb24gKGdyYXBoLCBOb2RlTWF0cml4LCBvdXRwdXRSZWR1Y2VyKSB7XG4gIHZhciBpID0gMDtcblxuICBncmFwaC51cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXMoZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICBhdHRyLnggPSBOb2RlTWF0cml4W2ldO1xuICAgIGF0dHIueSA9IE5vZGVNYXRyaXhbaSArIDFdO1xuXG4gICAgaSArPSBQUE47XG5cbiAgICByZXR1cm4gb3V0cHV0UmVkdWNlciA/IG91dHB1dFJlZHVjZXIobm9kZSwgYXR0cikgOiBhdHRyO1xuICB9KTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gcmVhZGluZyB0aGUgcG9zaXRpb25zIChvbmx5KSBmcm9tIHRoZSBncmFwaCwgdG8gd3JpdGUgdGhlbSBpbiB0aGUgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7R3JhcGh9ICAgICAgICBncmFwaCAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IE5vZGVNYXRyaXggLSBOb2RlIG1hdHJpeC5cbiAqL1xuZXhwb3J0cy5yZWFkR3JhcGhQb3NpdGlvbnMgPSBmdW5jdGlvbiAoZ3JhcGgsIE5vZGVNYXRyaXgpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgTm9kZU1hdHJpeFtpXSA9IGF0dHIueDtcbiAgICBOb2RlTWF0cml4W2kgKyAxXSA9IGF0dHIueTtcblxuICAgIGkgKz0gUFBOO1xuICB9KTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gY29sbGVjdGluZyB0aGUgbGF5b3V0IHBvc2l0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgICAgICBncmFwaCAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSAgTm9kZU1hdHJpeCAgICAtIE5vZGUgbWF0cml4LlxuICogQHBhcmFtICB7ZnVuY3Rpb258bnVsbH0gb3V0cHV0UmVkdWNlciAtIEEgbm9kZXMgcmVkdWNlci5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgLSBNYXAgdG8gbm9kZSBwb3NpdGlvbnMuXG4gKi9cbmV4cG9ydHMuY29sbGVjdExheW91dENoYW5nZXMgPSBmdW5jdGlvbiAoZ3JhcGgsIE5vZGVNYXRyaXgsIG91dHB1dFJlZHVjZXIpIHtcbiAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKSxcbiAgICBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDAsIGwgPSBOb2RlTWF0cml4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gUFBOKSB7XG4gICAgaWYgKG91dHB1dFJlZHVjZXIpIHtcbiAgICAgIHZhciBuZXdBdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZXMobm9kZXNbal0pKTtcbiAgICAgIG5ld0F0dHIueCA9IE5vZGVNYXRyaXhbaV07XG4gICAgICBuZXdBdHRyLnkgPSBOb2RlTWF0cml4W2kgKyAxXTtcbiAgICAgIG5ld0F0dHIgPSBvdXRwdXRSZWR1Y2VyKG5vZGVzW2pdLCBuZXdBdHRyKTtcbiAgICAgIHBvc2l0aW9uc1tub2Rlc1tqXV0gPSB7XG4gICAgICAgIHg6IG5ld0F0dHIueCxcbiAgICAgICAgeTogbmV3QXR0ci55XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbnNbbm9kZXNbal1dID0ge1xuICAgICAgICB4OiBOb2RlTWF0cml4W2ldLFxuICAgICAgICB5OiBOb2RlTWF0cml4W2kgKyAxXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBqKys7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb25zO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSB3ZWIgd29ya2VyIGZyb20gdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgZm4gLSBGdW5jdGlvbiBmb3IgdGhlIHdvcmtlci5cbiAqIEByZXR1cm4ge0RPTVN0cmluZ31cbiAqL1xuZXhwb3J0cy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgdmFyIHhVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gIHZhciBjb2RlID0gZm4udG9TdHJpbmcoKTtcbiAgdmFyIG9iamVjdFVybCA9IHhVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgIG5ldyBCbG9iKFsnKCcgKyBjb2RlICsgJykuY2FsbCh0aGlzKTsnXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSlcbiAgKTtcbiAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgeFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcblxuICByZXR1cm4gd29ya2VyO1xufTtcbiIsIi8qKlxuICogR3JhcGhvbG9neSBGb3JjZUF0bGFzMiBMYXlvdXRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIExpYnJhcnkgZW5kcG9pbnQuXG4gKi9cbnZhciBpc0dyYXBoID0gcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCcpO1xudmFyIGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPVxuICByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMnKS5jcmVhdGVFZGdlV2VpZ2h0R2V0dGVyO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuL2l0ZXJhdGUuanMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5cbnZhciBERUZBVUxUX1NFVFRJTkdTID0gcmVxdWlyZSgnLi9kZWZhdWx0cy5qcycpO1xuXG4vKipcbiAqIEFzYnRyYWN0IGZ1bmN0aW9uIHVzZWQgdG8gcnVuIGEgY2VydGFpbiBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSAgICAgICBhc3NpZ24gICAgICAgICAgLSBXaGV0aGVyIHRvIGFzc2lnbiBwb3NpdGlvbnMuXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgICAgICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtvYmplY3R8bnVtYmVyfSBwYXJhbXMgICAgICAgICAgLSBJZiBudW1iZXIsIHBhcmFtcy5pdGVyYXRpb25zLCBlbHNlOlxuICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICAgICBnZXRXZWlnaHQgICAgIC0gRWRnZSB3ZWlnaHQgZ2V0dGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICBpdGVyYXRpb25zICAgIC0gTnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbnxudWxsfSAgIG91dHB1dFJlZHVjZXIgLSBBIG5vZGUgcmVkdWNlclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICBbc2V0dGluZ3NdICAgIC0gU2V0dGluZ3MuXG4gKiBAcmV0dXJuIHtvYmplY3R8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhYnN0cmFjdFN5bmNocm9ub3VzTGF5b3V0KGFzc2lnbiwgZ3JhcGgsIHBhcmFtcykge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWxheW91dC1mb3JjZWF0bGFzMjogdGhlIGdpdmVuIGdyYXBoIGlzIG5vdCBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInKSBwYXJhbXMgPSB7aXRlcmF0aW9uczogcGFyYW1zfTtcblxuICB2YXIgaXRlcmF0aW9ucyA9IHBhcmFtcy5pdGVyYXRpb25zO1xuXG4gIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyOiBpbnZhbGlkIG51bWJlciBvZiBpdGVyYXRpb25zLidcbiAgICApO1xuXG4gIGlmIChpdGVyYXRpb25zIDw9IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyOiB5b3Ugc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBudW1iZXIgb2YgaXRlcmF0aW9ucy4nXG4gICAgKTtcblxuICB2YXIgZ2V0RWRnZVdlaWdodCA9IGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIocGFyYW1zLmdldEVkZ2VXZWlnaHQpLmZyb21FbnRyeTtcblxuICB2YXIgb3V0cHV0UmVkdWNlciA9XG4gICAgdHlwZW9mIHBhcmFtcy5vdXRwdXRSZWR1Y2VyID09PSAnZnVuY3Rpb24nID8gcGFyYW1zLm91dHB1dFJlZHVjZXIgOiBudWxsO1xuXG4gIC8vIFZhbGlkYXRpbmcgc2V0dGluZ3NcbiAgdmFyIHNldHRpbmdzID0gaGVscGVycy5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIHBhcmFtcy5zZXR0aW5ncyk7XG4gIHZhciB2YWxpZGF0aW9uRXJyb3IgPSBoZWxwZXJzLnZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG4gIGlmICh2YWxpZGF0aW9uRXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyOiAnICsgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2VcbiAgICApO1xuXG4gIC8vIEJ1aWxkaW5nIG1hdHJpY2VzXG4gIHZhciBtYXRyaWNlcyA9IGhlbHBlcnMuZ3JhcGhUb0J5dGVBcnJheXMoZ3JhcGgsIGdldEVkZ2VXZWlnaHQpO1xuXG4gIHZhciBpO1xuXG4gIC8vIEl0ZXJhdGluZ1xuICBmb3IgKGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKVxuICAgIGl0ZXJhdGUoc2V0dGluZ3MsIG1hdHJpY2VzLm5vZGVzLCBtYXRyaWNlcy5lZGdlcyk7XG5cbiAgLy8gQXBwbHlpbmdcbiAgaWYgKGFzc2lnbikge1xuICAgIGhlbHBlcnMuYXNzaWduTGF5b3V0Q2hhbmdlcyhncmFwaCwgbWF0cmljZXMubm9kZXMsIG91dHB1dFJlZHVjZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLmNvbGxlY3RMYXlvdXRDaGFuZ2VzKGdyYXBoLCBtYXRyaWNlcy5ub2Rlcyk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHNhbmUgbGF5b3V0IHNldHRpbmdzIGZvciB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh8bnVtYmVyfSBncmFwaCAtIFRhcmdldCBncmFwaCBvciBncmFwaCBvcmRlci5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW5mZXJTZXR0aW5ncyhncmFwaCkge1xuICB2YXIgb3JkZXIgPSB0eXBlb2YgZ3JhcGggPT09ICdudW1iZXInID8gZ3JhcGggOiBncmFwaC5vcmRlcjtcblxuICByZXR1cm4ge1xuICAgIGJhcm5lc0h1dE9wdGltaXplOiBvcmRlciA+IDIwMDAsXG4gICAgc3Ryb25nR3Jhdml0eU1vZGU6IHRydWUsXG4gICAgZ3Jhdml0eTogMC4wNSxcbiAgICBzY2FsaW5nUmF0aW86IDEwLFxuICAgIHNsb3dEb3duOiAxICsgTWF0aC5sb2cob3JkZXIpXG4gIH07XG59XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG52YXIgc3luY2hyb25vdXNMYXlvdXQgPSBhYnN0cmFjdFN5bmNocm9ub3VzTGF5b3V0LmJpbmQobnVsbCwgZmFsc2UpO1xuc3luY2hyb25vdXNMYXlvdXQuYXNzaWduID0gYWJzdHJhY3RTeW5jaHJvbm91c0xheW91dC5iaW5kKG51bGwsIHRydWUpO1xuc3luY2hyb25vdXNMYXlvdXQuaW5mZXJTZXR0aW5ncyA9IGluZmVyU2V0dGluZ3M7XG5cbm1vZHVsZS5leHBvcnRzID0gc3luY2hyb25vdXNMYXlvdXQ7XG4iLCIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOiAwICovXG4vKipcbiAqIEdyYXBob2xvZ3kgRm9yY2VBdGxhczIgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaXRlcmF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4gKi9cblxuLyoqXG4gKiBNYXRyaWNlcyBwcm9wZXJ0aWVzIGFjY2Vzc29ycy5cbiAqL1xudmFyIE5PREVfWCA9IDA7XG52YXIgTk9ERV9ZID0gMTtcbnZhciBOT0RFX0RYID0gMjtcbnZhciBOT0RFX0RZID0gMztcbnZhciBOT0RFX09MRF9EWCA9IDQ7XG52YXIgTk9ERV9PTERfRFkgPSA1O1xudmFyIE5PREVfTUFTUyA9IDY7XG52YXIgTk9ERV9DT05WRVJHRU5DRSA9IDc7XG52YXIgTk9ERV9TSVpFID0gODtcbnZhciBOT0RFX0ZJWEVEID0gOTtcblxudmFyIEVER0VfU09VUkNFID0gMDtcbnZhciBFREdFX1RBUkdFVCA9IDE7XG52YXIgRURHRV9XRUlHSFQgPSAyO1xuXG52YXIgUkVHSU9OX05PREUgPSAwO1xudmFyIFJFR0lPTl9DRU5URVJfWCA9IDE7XG52YXIgUkVHSU9OX0NFTlRFUl9ZID0gMjtcbnZhciBSRUdJT05fU0laRSA9IDM7XG52YXIgUkVHSU9OX05FWFRfU0lCTElORyA9IDQ7XG52YXIgUkVHSU9OX0ZJUlNUX0NISUxEID0gNTtcbnZhciBSRUdJT05fTUFTUyA9IDY7XG52YXIgUkVHSU9OX01BU1NfQ0VOVEVSX1ggPSA3O1xudmFyIFJFR0lPTl9NQVNTX0NFTlRFUl9ZID0gODtcblxudmFyIFNVQkRJVklTSU9OX0FUVEVNUFRTID0gMztcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBQUE4gPSAxMDtcbnZhciBQUEUgPSAzO1xudmFyIFBQUiA9IDk7XG5cbnZhciBNQVhfRk9SQ0UgPSAxMDtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaW50ZXJhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAtIExheW91dCBvcHRpb25zLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBOb2RlTWF0cml4IC0gTm9kZSBkYXRhLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBFZGdlTWF0cml4IC0gRWRnZSBkYXRhLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gU29tZSBtZXRhZGF0YS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlKG9wdGlvbnMsIE5vZGVNYXRyaXgsIEVkZ2VNYXRyaXgpIHtcbiAgLy8gSW5pdGlhbGl6aW5nIHZhcmlhYmxlc1xuICB2YXIgbCwgciwgbiwgbjEsIG4yLCBybiwgZSwgdywgZywgcztcblxuICB2YXIgb3JkZXIgPSBOb2RlTWF0cml4Lmxlbmd0aCxcbiAgICBzaXplID0gRWRnZU1hdHJpeC5sZW5ndGg7XG5cbiAgdmFyIGFkanVzdFNpemVzID0gb3B0aW9ucy5hZGp1c3RTaXplcztcblxuICB2YXIgdGhldGFTcXVhcmVkID0gb3B0aW9ucy5iYXJuZXNIdXRUaGV0YSAqIG9wdGlvbnMuYmFybmVzSHV0VGhldGE7XG5cbiAgdmFyIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uLCBjb2VmZmljaWVudCwgeERpc3QsIHlEaXN0LCBld2MsIGRpc3RhbmNlLCBmYWN0b3I7XG5cbiAgdmFyIFJlZ2lvbk1hdHJpeCA9IFtdO1xuXG4gIC8vIDEpIEluaXRpYWxpemluZyBsYXlvdXQgZGF0YVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmVzZXR0aW5nIHBvc2l0aW9ucyAmIGNvbXB1dGluZyBtYXggdmFsdWVzXG4gIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gPSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXTtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gPSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXTtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSA9IDA7XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gPSAwO1xuICB9XG5cbiAgLy8gSWYgb3V0Ym91bmQgYXR0cmFjdGlvbiBkaXN0cmlidXRpb24sIGNvbXBlbnNhdGVcbiAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gPSAwO1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uICs9IE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU107XG4gICAgfVxuXG4gICAgb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gLz0gb3JkZXIgLyBQUE47XG4gIH1cblxuICAvLyAxLmJpcykgQmFybmVzLUh1dCBjb21wdXRhdGlvblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGlmIChvcHRpb25zLmJhcm5lc0h1dE9wdGltaXplKSB7XG4gICAgLy8gU2V0dGluZyB1cFxuICAgIHZhciBtaW5YID0gSW5maW5pdHksXG4gICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgbWF4WSA9IC1JbmZpbml0eSxcbiAgICAgIHEsXG4gICAgICBxMixcbiAgICAgIHN1YmRpdmlzaW9uQXR0ZW1wdHM7XG5cbiAgICAvLyBDb21wdXRpbmcgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIE5vZGVNYXRyaXhbbiArIE5PREVfWF0pO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIE5vZGVNYXRyaXhbbiArIE5PREVfWF0pO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIE5vZGVNYXRyaXhbbiArIE5PREVfWV0pO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIE5vZGVNYXRyaXhbbiArIE5PREVfWV0pO1xuICAgIH1cblxuICAgIC8vIHNxdWFyaWZ5IGJvdW5kcywgaXQncyBhIHF1YWR0cmVlXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblgsXG4gICAgICBkeSA9IG1heFkgLSBtaW5ZO1xuICAgIGlmIChkeCA+IGR5KSB7XG4gICAgICBtaW5ZIC09IChkeCAtIGR5KSAvIDI7XG4gICAgICBtYXhZID0gbWluWSArIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5YIC09IChkeSAtIGR4KSAvIDI7XG4gICAgICBtYXhYID0gbWluWCArIGR5O1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBCYXJuZXMgSHV0IHJvb3QgcmVnaW9uXG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9DRU5URVJfWF0gPSAobWluWCArIG1heFgpIC8gMjtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9DRU5URVJfWV0gPSAobWluWSArIG1heFkpIC8gMjtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9TSVpFXSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IC0xO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9NQVNTX0NFTlRFUl9YXSA9IDA7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgLy8gQWRkIGVhY2ggbm9kZSBpbiB0aGUgdHJlZVxuICAgIGwgPSAxO1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIC8vIEN1cnJlbnQgcmVnaW9uLCBzdGFydGluZyB3aXRoIHJvb3RcbiAgICAgIHIgPSAwO1xuICAgICAgc3ViZGl2aXNpb25BdHRlbXB0cyA9IFNVQkRJVklTSU9OX0FUVEVNUFRTO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBBcmUgdGhlcmUgc3ViLXJlZ2lvbnM/XG5cbiAgICAgICAgLy8gV2UgbG9vayBhdCBmaXJzdCBjaGlsZCBpbmRleFxuICAgICAgICBpZiAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdID49IDApIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgc3ViLXJlZ2lvbnNcblxuICAgICAgICAgIC8vIFdlIGp1c3QgaXRlcmF0ZSB0byBmaW5kIGEgXCJsZWFmXCIgb2YgdGhlIHRyZWVcbiAgICAgICAgICAvLyB0aGF0IGlzIGFuIGVtcHR5IHJlZ2lvbiBvciBhIHJlZ2lvbiB3aXRoIGEgc2luZ2xlIG5vZGVcbiAgICAgICAgICAvLyAoc2VlIG5leHQgY2FzZSlcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIHF1YWRyYW50IG9mIG5cbiAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSkge1xuICAgICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0pIHtcbiAgICAgICAgICAgICAgLy8gVG9wIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSkge1xuICAgICAgICAgICAgICAvLyBUb3AgUmlnaHQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJvdHRvbSBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFIgKiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSBjZW50ZXIgb2YgbWFzcyBhbmQgbWFzcyAod2Ugb25seSBkbyBpdCBmb3Igbm9uLWxlYXZlIHJlZ2lvbnMpXG4gICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPVxuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdICpcbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gK1xuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSk7XG5cbiAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gKlxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSArXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gKiBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdKSAvXG4gICAgICAgICAgICAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gKyBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdKTtcblxuICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICs9IE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU107XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIG9uIHRoZSByaWdodCBxdWFkcmFudFxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBzdWItcmVnaW9uczogd2UgYXJlIGluIGEgXCJsZWFmXCJcblxuICAgICAgICAgIC8vIElzIHRoZXJlIGEgbm9kZSBpbiB0aGlzIGxlYXZlP1xuICAgICAgICAgIGlmIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5vZGUgaW4gcmVnaW9uOlxuICAgICAgICAgICAgLy8gd2UgcmVjb3JkIG5vZGUgbiBhbmQgZ28gb25cbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdID0gbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIG5vZGUgaW4gdGhpcyByZWdpb25cblxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSBzdWItcmVnaW9ucywgc3RpY2sgdGhlIHR3b1xuICAgICAgICAgICAgLy8gbm9kZXMgKHRoZSBvbGQgb25lIHJbMF0gYW5kIHRoZSBuZXcgb25lIG4pIGluIHR3b1xuICAgICAgICAgICAgLy8gc3VicmVnaW9ucy4gSWYgdGhleSBmYWxsIGluIHRoZSBzYW1lIHF1YWRyYW50LFxuICAgICAgICAgICAgLy8gd2Ugd2lsbCBpdGVyYXRlLlxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3ViLXJlZ2lvbnNcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IGwgKiBQUFI7XG4gICAgICAgICAgICB3ID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fU0laRV0gLyAyOyAvLyBuZXcgc2l6ZSAoaGFsZilcblxuICAgICAgICAgICAgLy8gTk9URTogd2UgdXNlIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgLy8gZnJvbSBUb3AgTGVmdCB0byBCb3R0b20gUmlnaHRcblxuICAgICAgICAgICAgLy8gVG9wIExlZnQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcblxuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9YXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSAtIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWV0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0gLSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fU0laRV0gPSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IGcgKyBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdIC0gdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID0gZyArIFBQUjtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICAvLyBUb3AgUmlnaHQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdICsgdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSAtIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID0gZyArIFBQUjtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICAvLyBCb3R0b20gUmlnaHQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdICsgdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTkVYVF9TSUJMSU5HXTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICBsICs9IDQ7XG5cbiAgICAgICAgICAgIC8vIE5vdyB0aGUgZ29hbCBpcyB0byBmaW5kIHR3byBkaWZmZXJlbnQgc3ViLXJlZ2lvbnNcbiAgICAgICAgICAgIC8vIGZvciB0aGUgdHdvIG5vZGVzOiB0aGUgb25lIHByZXZpb3VzbHkgcmVjb3JkZWQgKHJbMF0pXG4gICAgICAgICAgICAvLyBhbmQgdGhlIG9uZSB3ZSB3YW50IHRvIGFkZCAobilcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcXVhZHJhbnQgb2YgdGhlIG9sZCBub2RlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX1hdIDxcbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX1ldIDxcbiAgICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV1cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9wIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9ZXSA8XG4gICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSICogMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgclswXSBmcm9tIHRoZSByZWdpb24gciwgYWRkIGl0cyBtYXNzIHRvIHIgYW5kIHJlY29yZCBpdCBpbiBxXG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSA9XG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX01BU1NdO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPVxuICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9YXTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSArIE5PREVfWV07XG5cbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtxICsgUkVHSU9OX05PREVdID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV07XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSA9IC0xO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBxdWFkcmFudCBvZiBuXG4gICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSkge1xuICAgICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gTGVmdCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcTIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX1ldIDwgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9wIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEgPT09IHEyKSB7XG4gICAgICAgICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIGluIHRoZSBzYW1lIHF1YWRyYW50LFxuICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHRyeSBpdCBhZ2FpbiBvbiB0aGlzIHF1YWRyYW50XG4gICAgICAgICAgICAgIGlmIChzdWJkaXZpc2lvbkF0dGVtcHRzLS0pIHtcbiAgICAgICAgICAgICAgICByID0gcTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gd2hpbGVcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgb3V0IG9mIHByZWNpc2lvbiBoZXJlLCBhbmQgd2UgY2Fubm90IHN1YmRpdmlkZSBhbnltb3JlXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gYnJlYWsgdGhlIGxvb3AgYW55d2F5XG4gICAgICAgICAgICAgICAgc3ViZGl2aXNpb25BdHRlbXB0cyA9IFNVQkRJVklTSU9OX0FUVEVNUFRTO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3aGlsZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGJvdGggcXVhZHJhbnRzIGFyZSBkaWZmZXJlbnQsIHdlIHJlY29yZCBuXG4gICAgICAgICAgICAvLyBpbiBpdHMgcXVhZHJhbnRcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtxMiArIFJFR0lPTl9OT0RFXSA9IG47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAyKSBSZXB1bHNpb25cbiAgLy8tLS0tLS0tLS0tLS0tLVxuICAvLyBOT1RFUzogYWRqdXN0U2l6ZXMgPSBhbnRpQ29sbGlzaW9uICYgc2NhbGluZ1JhdGlvID0gY29lZmZpY2llbnRcblxuICBpZiAob3B0aW9ucy5iYXJuZXNIdXRPcHRpbWl6ZSkge1xuICAgIGNvZWZmaWNpZW50ID0gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG5cbiAgICAvLyBBcHBseWluZyByZXB1bHNpb24gdGhyb3VnaCByZWdpb25zXG4gICAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgICAgLy8gQ29tcHV0aW5nIGxlYWYgcXVhZCBub2RlcyBpdGVyYXRpb25cblxuICAgICAgciA9IDA7IC8vIFN0YXJ0aW5nIHdpdGggcm9vdCByZWdpb25cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gPj0gMCkge1xuICAgICAgICAgIC8vIFRoZSByZWdpb24gaGFzIHN1Yi1yZWdpb25zXG5cbiAgICAgICAgICAvLyBXZSBydW4gdGhlIEJhcm5lcyBIdXQgdGVzdCB0byBzZWUgaWYgd2UgYXJlIGF0IHRoZSByaWdodCBkaXN0YW5jZVxuICAgICAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgICAgIE1hdGgucG93KFxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdIC0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0sXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgTWF0aC5wb3coXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gLSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIHMgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9TSVpFXTtcblxuICAgICAgICAgIGlmICgoNCAqIHMgKiBzKSAvIGRpc3RhbmNlIDwgdGhldGFTcXVhcmVkKSB7XG4gICAgICAgICAgICAvLyBXZSB0cmVhdCB0aGUgcmVnaW9uIGFzIGEgc2luZ2xlIGJvZHksIGFuZCB3ZSByZXB1bHNlXG5cbiAgICAgICAgICAgIHhEaXN0ID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSAtIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdO1xuICAgICAgICAgICAgeURpc3QgPVxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldIC0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV07XG5cbiAgICAgICAgICAgIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLy0tIExpbmVhciBBbnRpLWNvbGxpc2lvbiBSZXB1bHNpb25cbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgICgtY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIE1hdGguc3FydChkaXN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8tLSBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdKSAvXG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyBpcyBkb25lLCB3ZSBpdGVyYXRlLiBXZSBoYXZlIHRvIGxvb2sgYXQgdGhlIG5leHQgc2libGluZy5cbiAgICAgICAgICAgIHIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9ORVhUX1NJQkxJTkddO1xuICAgICAgICAgICAgaWYgKHIgPCAwKSBicmVhazsgLy8gTm8gbmV4dCBzaWJsaW5nOiB3ZSBoYXZlIGZpbmlzaGVkIHRoZSB0cmVlXG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcmVnaW9uIGlzIHRvbyBjbG9zZSBhbmQgd2UgaGF2ZSB0byBsb29rIGF0IHN1Yi1yZWdpb25zXG4gICAgICAgICAgICByID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSByZWdpb24gaGFzIG5vIHN1Yi1yZWdpb25cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG5vZGUgclswXSBhbmQgaXQgaXMgbm90IG4sIHRoZW4gcmVwdWxzZVxuICAgICAgICAgIHJuID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV07XG5cbiAgICAgICAgICBpZiAocm4gPj0gMCAmJiBybiAhPT0gbikge1xuICAgICAgICAgICAgeERpc3QgPSBOb2RlTWF0cml4W24gKyBOT0RFX1hdIC0gTm9kZU1hdHJpeFtybiArIE5PREVfWF07XG4gICAgICAgICAgICB5RGlzdCA9IE5vZGVNYXRyaXhbbiArIE5PREVfWV0gLSBOb2RlTWF0cml4W3JuICsgTk9ERV9ZXTtcblxuICAgICAgICAgICAgZGlzdGFuY2UgPSB4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdDtcblxuICAgICAgICAgICAgaWYgKGFkanVzdFNpemVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIFJlcHVsc2lvblxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgIChjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W3JuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKC1jb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W3JuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KGRpc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLy0tIExpbmVhciBSZXB1bHNpb25cbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtybiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHRoaXMgaXMgZG9uZSwgd2UgaXRlcmF0ZS4gV2UgaGF2ZSB0byBsb29rIGF0IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICAgICAgciA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05FWFRfU0lCTElOR107XG5cbiAgICAgICAgICBpZiAociA8IDApIGJyZWFrOyAvLyBObyBuZXh0IHNpYmxpbmc6IHdlIGhhdmUgZmluaXNoZWQgdGhlIHRyZWVcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvZWZmaWNpZW50ID0gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG5cbiAgICAvLyBTcXVhcmUgaXRlcmF0aW9uXG4gICAgZm9yIChuMSA9IDA7IG4xIDwgb3JkZXI7IG4xICs9IFBQTikge1xuICAgICAgZm9yIChuMiA9IDA7IG4yIDwgbjE7IG4yICs9IFBQTikge1xuICAgICAgICAvLyBDb21tb24gdG8gYm90aCBtZXRob2RzXG4gICAgICAgIHhEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWF0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9YXTtcbiAgICAgICAgeURpc3QgPSBOb2RlTWF0cml4W24xICsgTk9ERV9ZXSAtIE5vZGVNYXRyaXhbbjIgKyBOT0RFX1ldO1xuXG4gICAgICAgIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vLS0gQW50aWNvbGxpc2lvbiBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgZGlzdGFuY2UgPVxuICAgICAgICAgICAgTWF0aC5zcXJ0KHhEaXN0ICogeERpc3QgKyB5RGlzdCAqIHlEaXN0KSAtXG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9TSVpFXSAtXG4gICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9TSVpFXTtcblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgIChjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX01BU1NdKSAvXG4gICAgICAgICAgICAgIGRpc3RhbmNlIC9cbiAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIG5vZGVzJyBkeCBhbmQgZHlcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcblxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAxMDAgKlxuICAgICAgICAgICAgICBjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfTUFTU107XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIG5vZGVzJyBkeCBhbmQgZHlcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcblxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFhdIC09IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFldIC09IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBSZXB1bHNpb25cbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydCh4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdCk7XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RYXSAtPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RZXSAtPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAzKSBHcmF2aXR5XG4gIC8vLS0tLS0tLS0tLS0tXG4gIGcgPSBvcHRpb25zLmdyYXZpdHkgLyBvcHRpb25zLnNjYWxpbmdSYXRpbztcbiAgY29lZmZpY2llbnQgPSBvcHRpb25zLnNjYWxpbmdSYXRpbztcbiAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgIGZhY3RvciA9IDA7XG5cbiAgICAvLyBDb21tb24gdG8gYm90aCBtZXRob2RzXG4gICAgeERpc3QgPSBOb2RlTWF0cml4W24gKyBOT0RFX1hdO1xuICAgIHlEaXN0ID0gTm9kZU1hdHJpeFtuICsgTk9ERV9ZXTtcbiAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4RGlzdCwgMikgKyBNYXRoLnBvdyh5RGlzdCwgMikpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3Ryb25nR3Jhdml0eU1vZGUpIHtcbiAgICAgIC8vLS0gU3Ryb25nIGdyYXZpdHlcbiAgICAgIGlmIChkaXN0YW5jZSA+IDApIGZhY3RvciA9IGNvZWZmaWNpZW50ICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqIGc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIFJlcHVsc2lvbiBuXG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKVxuICAgICAgICBmYWN0b3IgPSAoY29lZmZpY2llbnQgKiBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICogZykgLyBkaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGluZyBub2RlJ3MgZHggYW5kIGR5XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gLT0geERpc3QgKiBmYWN0b3I7XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gLT0geURpc3QgKiBmYWN0b3I7XG4gIH1cblxuICAvLyA0KSBBdHRyYWN0aW9uXG4gIC8vLS0tLS0tLS0tLS0tLS0tXG4gIGNvZWZmaWNpZW50ID1cbiAgICAxICogKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uID8gb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gOiAxKTtcblxuICAvLyBUT0RPOiBzaW1wbGlmeSBkaXN0YW5jZVxuICAvLyBUT0RPOiBjb2VmZmljaWVudCBpcyBhbHdheXMgdXNlZCBhcyAtYyAtLT4gb3B0aW1pemU/XG4gIGZvciAoZSA9IDA7IGUgPCBzaXplOyBlICs9IFBQRSkge1xuICAgIG4xID0gRWRnZU1hdHJpeFtlICsgRURHRV9TT1VSQ0VdO1xuICAgIG4yID0gRWRnZU1hdHJpeFtlICsgRURHRV9UQVJHRVRdO1xuICAgIHcgPSBFZGdlTWF0cml4W2UgKyBFREdFX1dFSUdIVF07XG5cbiAgICAvLyBFZGdlIHdlaWdodCBpbmZsdWVuY2VcbiAgICBld2MgPSBNYXRoLnBvdyh3LCBvcHRpb25zLmVkZ2VXZWlnaHRJbmZsdWVuY2UpO1xuXG4gICAgLy8gQ29tbW9uIG1lYXN1cmVzXG4gICAgeERpc3QgPSBOb2RlTWF0cml4W24xICsgTk9ERV9YXSAtIE5vZGVNYXRyaXhbbjIgKyBOT0RFX1hdO1xuICAgIHlEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWV0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9ZXTtcblxuICAgIC8vIEFwcGx5aW5nIGF0dHJhY3Rpb24gdG8gbm9kZXNcbiAgICBpZiAoYWRqdXN0U2l6ZXMgPT09IHRydWUpIHtcbiAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgTWF0aC5zcXJ0KHhEaXN0ICogeERpc3QgKyB5RGlzdCAqIHlEaXN0KSAtXG4gICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX1NJWkVdIC1cbiAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfU0laRV07XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbkxvZ01vZGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgRGVncmVlIERpc3RyaWJ1dGVkIEFudGktY29sbGlzaW9uIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoLWNvZWZmaWNpZW50ICogZXdjICogTWF0aC5sb2coMSArIGRpc3RhbmNlKSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbkxvZyBBbnRpLWNvbGxpc2lvbiBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID0gKC1jb2VmZmljaWVudCAqIGV3YyAqIE1hdGgubG9nKDEgKyBkaXN0YW5jZSkpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBEZWdyZWUgRGlzdHJpYnV0ZWQgQW50aS1jb2xsaXNpb24gQXR0cmFjdGlvblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIGZhY3RvciA9ICgtY29lZmZpY2llbnQgKiBld2MpIC8gTm9kZU1hdHJpeFtuMSArIE5PREVfTUFTU107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPSAtY29lZmZpY2llbnQgKiBld2M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHhEaXN0LCAyKSArIE1hdGgucG93KHlEaXN0LCAyKSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbkxvZ01vZGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgRGVncmVlIERpc3RyaWJ1dGVkIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoLWNvZWZmaWNpZW50ICogZXdjICogTWF0aC5sb2coMSArIGRpc3RhbmNlKSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbkxvZyBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMClcbiAgICAgICAgICAgIGZhY3RvciA9ICgtY29lZmZpY2llbnQgKiBld2MgKiBNYXRoLmxvZygxICsgZGlzdGFuY2UpKSAvIGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBBdHRyYWN0aW9uIE1hc3MgRGlzdHJpYnV0ZWRcbiAgICAgICAgICAvLyBOT1RFOiBEaXN0YW5jZSBpcyBzZXQgdG8gMSB0byBvdmVycmlkZSBuZXh0IGNvbmRpdGlvblxuICAgICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgICAgICBmYWN0b3IgPSAoLWNvZWZmaWNpZW50ICogZXdjKSAvIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vLS0gTGluZWFyIEF0dHJhY3Rpb25cbiAgICAgICAgICAvLyBOT1RFOiBEaXN0YW5jZSBpcyBzZXQgdG8gMSB0byBvdmVycmlkZSBuZXh0IGNvbmRpdGlvblxuICAgICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgICAgICBmYWN0b3IgPSAtY29lZmZpY2llbnQgKiBld2M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgLy8gVE9ETzogaWYgY29uZGl0aW9uIG9yIGZhY3RvciA9IDE/XG4gICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgLy8gVXBkYXRpbmcgbm9kZXMnIGR4IGFuZCBkeVxuICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuXG4gICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWF0gLT0geERpc3QgKiBmYWN0b3I7XG4gICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWV0gLT0geURpc3QgKiBmYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgLy8gNSkgQXBwbHkgRm9yY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGZvcmNlLCBzd2luZ2luZywgdHJhY3Rpb24sIG5vZGVzcGVlZCwgbmV3WCwgbmV3WTtcblxuICAvLyBNQVRIOiBzcXJ0IGFuZCBzcXVhcmUgZGlzdGFuY2VzXG4gIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX0ZJWEVEXSAhPT0gMSkge1xuICAgICAgICBmb3JjZSA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhOb2RlTWF0cml4W24gKyBOT0RFX0RYXSwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3coTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0sIDIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGZvcmNlID4gTUFYX0ZPUkNFKSB7XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gPVxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogTUFYX0ZPUkNFKSAvIGZvcmNlO1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldID1cbiAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIE1BWF9GT1JDRSkgLyBmb3JjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aW5naW5nID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICpcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSArXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSkgKlxuICAgICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSlcbiAgICAgICAgICApO1xuXG4gICAgICAgIHRyYWN0aW9uID1cbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICpcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSArXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSkgKlxuICAgICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSlcbiAgICAgICAgICApIC8gMjtcblxuICAgICAgICBub2Rlc3BlZWQgPSAoMC4xICogTWF0aC5sb2coMSArIHRyYWN0aW9uKSkgLyAoMSArIE1hdGguc3FydChzd2luZ2luZykpO1xuXG4gICAgICAgIC8vIFVwZGF0aW5nIG5vZGUncyBwb3NpdG9uXG4gICAgICAgIG5ld1ggPVxuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWF0gK1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogKG5vZGVzcGVlZCAvIG9wdGlvbnMuc2xvd0Rvd24pO1xuICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdID0gbmV3WDtcblxuICAgICAgICBuZXdZID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA9IG5ld1k7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX0ZJWEVEXSAhPT0gMSkge1xuICAgICAgICBzd2luZ2luZyA9XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKTtcblxuICAgICAgICB0cmFjdGlvbiA9XG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKSAvIDI7XG5cbiAgICAgICAgbm9kZXNwZWVkID1cbiAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9DT05WRVJHRU5DRV0gKiBNYXRoLmxvZygxICsgdHJhY3Rpb24pKSAvXG4gICAgICAgICAgKDEgKyBNYXRoLnNxcnQoc3dpbmdpbmcpKTtcblxuICAgICAgICAvLyBVcGRhdGluZyBub2RlIGNvbnZlcmdlbmNlXG4gICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfQ09OVkVSR0VOQ0VdID0gTWF0aC5taW4oXG4gICAgICAgICAgMSxcbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAobm9kZXNwZWVkICpcbiAgICAgICAgICAgICAgKE1hdGgucG93KE5vZGVNYXRyaXhbbiArIE5PREVfRFhdLCAyKSArXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0sIDIpKSkgL1xuICAgICAgICAgICAgICAoMSArIE1hdGguc3FydChzd2luZ2luZykpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVwZGF0aW5nIG5vZGUncyBwb3NpdG9uXG4gICAgICAgIG5ld1ggPVxuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWF0gK1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogKG5vZGVzcGVlZCAvIG9wdGlvbnMuc2xvd0Rvd24pO1xuICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdID0gbmV3WDtcblxuICAgICAgICBuZXdZID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA9IG5ld1k7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF5b3V0IChubyBuZWVkIHRvIHJldHVybiB0aGUgbWF0cmljZXMpXG4gIHJldHVybiB7fTtcbn07XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgQ2lyY2xlUGFjayBMYXlvdXRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ2lyY2xlcGFjayBsYXlvdXQgZnJvbSBkMy1oaWVyYXJjaHkvZ2VwaGkuXG4gKi9cbnZhciByZXNvbHZlRGVmYXVsdHMgPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2RlZmF1bHRzJyk7XG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcbnZhciBzaHVmZmxlID0gcmVxdWlyZSgncGFuZGVtb25pdW0vc2h1ZmZsZS1pbi1wbGFjZScpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucy5cbiAqL1xudmFyIERFRkFVTFRTID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgeDogJ3gnLFxuICAgIHk6ICd5J1xuICB9LFxuICBjZW50ZXI6IDAsXG4gIGhpZXJhcmNoeUF0dHJpYnV0ZXM6IFtdLFxuICBybmc6IE1hdGgucmFuZG9tLFxuICBzY2FsZTogMVxufTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5mdW5jdGlvbiBDaXJjbGVXcmFwKGlkLCB4LCB5LCByLCBjaXJjbGVXcmFwKSB7XG4gIHRoaXMud3JhcHBlZENpcmNsZSA9IGNpcmNsZVdyYXAgfHwgbnVsbDsgLy9oYWNreSBkMyByZWZlcmVuY2UgdGhpbmdcblxuICB0aGlzLmNoaWxkcmVuID0ge307XG4gIHRoaXMuY291bnRDaGlsZHJlbiA9IDA7XG4gIHRoaXMuaWQgPSBpZCB8fCBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcblxuICB0aGlzLnggPSB4IHx8IG51bGw7XG4gIHRoaXMueSA9IHkgfHwgbnVsbDtcbiAgaWYgKGNpcmNsZVdyYXApIHRoaXMuciA9IDEwMTAxMDE7XG4gIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgLSBzaG91bGQgbm90IGJlIHVzZWQgaW4gdGhpcyBjYXNlXG4gIGVsc2UgdGhpcy5yID0gciB8fCA5OTk7XG59XG5cbkNpcmNsZVdyYXAucHJvdG90eXBlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb3VudENoaWxkcmVuID4gMDtcbn07XG5cbkNpcmNsZVdyYXAucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGlkLCBjaGlsZCkge1xuICB0aGlzLmNoaWxkcmVuW2lkXSA9IGNoaWxkO1xuICArK3RoaXMuY291bnRDaGlsZHJlbjtcbn07XG5cbkNpcmNsZVdyYXAucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmICghdGhpcy5jaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgY2lyY2xlV3JhcCA9IG5ldyBDaXJjbGVXcmFwKCk7XG4gICAgdGhpcy5jaGlsZHJlbltpZF0gPSBjaXJjbGVXcmFwO1xuICAgICsrdGhpcy5jb3VudENoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzLmNoaWxkcmVuW2lkXTtcbn07XG5cbkNpcmNsZVdyYXAucHJvdG90eXBlLmFwcGx5UG9zaXRpb25Ub0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzOyAvLyB1c2luZyAndGhpcycgaW4gT2JqZWN0LmtleXMuZm9yRWFjaCBzZWVtcyBhIGJhZCBpZGVhXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3QuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjaGlsZCA9IHJvb3QuY2hpbGRyZW5ba2V5XTtcbiAgICAgIGNoaWxkLnggKz0gcm9vdC54O1xuICAgICAgY2hpbGQueSArPSByb290Lnk7XG4gICAgICBjaGlsZC5hcHBseVBvc2l0aW9uVG9DaGlsZHJlbigpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0Tm9kZSgvKkdyYXBoKi8gZ3JhcGgsIC8qQ2lyY2xlV3JhcCovIHBhcmVudENpcmNsZSwgLypNYXAqLyBwb3NNYXApIHtcbiAgZm9yICh2YXIga2V5IGluIHBhcmVudENpcmNsZS5jaGlsZHJlbikge1xuICAgIHZhciBjaXJjbGUgPSBwYXJlbnRDaXJjbGUuY2hpbGRyZW5ba2V5XTtcbiAgICBpZiAoY2lyY2xlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgIHNldE5vZGUoZ3JhcGgsIGNpcmNsZSwgcG9zTWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zTWFwW2NpcmNsZS5pZF0gPSB7eDogY2lyY2xlLngsIHk6IGNpcmNsZS55fTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNOb3QoLypDaXJjbGVXcmFwKi8gYSwgLypDaXJjbGVXcmFwKi8gYikge1xuICB2YXIgZHIgPSBhLnIgLSBiLnI7XG4gIHZhciBkeCA9IGIueCAtIGEueDtcbiAgdmFyIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKC8qQ2lyY2xlV3JhcCovIGEsIC8qQ2lyY2xlV3JhcCovIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNjtcbiAgdmFyIGR4ID0gYi54IC0gYS54O1xuICB2YXIgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBkciA+IDAgJiYgZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc1dlYWtBbGwoLypDaXJjbGVXcmFwKi8gYSwgLypBcnJheTxDaXJjbGVXcmFwPiovIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczEoLypDaXJjbGVXcmFwKi8gYSkge1xuICByZXR1cm4gbmV3IENpcmNsZVdyYXAobnVsbCwgYS54LCBhLnksIGEucik7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczIoLypDaXJjbGVXcmFwKi8gYSwgLypDaXJjbGVXcmFwKi8gYikge1xuICB2YXIgeDEgPSBhLngsXG4gICAgeTEgPSBhLnksXG4gICAgcjEgPSBhLnIsXG4gICAgeDIgPSBiLngsXG4gICAgeTIgPSBiLnksXG4gICAgcjIgPSBiLnIsXG4gICAgeDIxID0geDIgLSB4MSxcbiAgICB5MjEgPSB5MiAtIHkxLFxuICAgIHIyMSA9IHIyIC0gcjEsXG4gICAgbCA9IE1hdGguc3FydCh4MjEgKiB4MjEgKyB5MjEgKiB5MjEpO1xuICByZXR1cm4gbmV3IENpcmNsZVdyYXAoXG4gICAgbnVsbCxcbiAgICAoeDEgKyB4MiArICh4MjEgLyBsKSAqIHIyMSkgLyAyLFxuICAgICh5MSArIHkyICsgKHkyMSAvIGwpICogcjIxKSAvIDIsXG4gICAgKGwgKyByMSArIHIyKSAvIDJcbiAgKTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMygvKkNpcmNsZVdyYXAqLyBhLCAvKkNpcmNsZVdyYXAqLyBiLCAvKkNpcmNsZVdyYXAqLyBjKSB7XG4gIHZhciB4MSA9IGEueCxcbiAgICB5MSA9IGEueSxcbiAgICByMSA9IGEucixcbiAgICB4MiA9IGIueCxcbiAgICB5MiA9IGIueSxcbiAgICByMiA9IGIucixcbiAgICB4MyA9IGMueCxcbiAgICB5MyA9IGMueSxcbiAgICByMyA9IGMucixcbiAgICBhMiA9IHgxIC0geDIsXG4gICAgYTMgPSB4MSAtIHgzLFxuICAgIGIyID0geTEgLSB5MixcbiAgICBiMyA9IHkxIC0geTMsXG4gICAgYzIgPSByMiAtIHIxLFxuICAgIGMzID0gcjMgLSByMSxcbiAgICBkMSA9IHgxICogeDEgKyB5MSAqIHkxIC0gcjEgKiByMSxcbiAgICBkMiA9IGQxIC0geDIgKiB4MiAtIHkyICogeTIgKyByMiAqIHIyLFxuICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgYWIgPSBhMyAqIGIyIC0gYTIgKiBiMyxcbiAgICB4YSA9IChiMiAqIGQzIC0gYjMgKiBkMikgLyAoYWIgKiAyKSAtIHgxLFxuICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgIHlhID0gKGEzICogZDIgLSBhMiAqIGQzKSAvIChhYiAqIDIpIC0geTEsXG4gICAgeWIgPSAoYTIgKiBjMyAtIGEzICogYzIpIC8gYWIsXG4gICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICBCID0gMiAqIChyMSArIHhhICogeGIgKyB5YSAqIHliKSxcbiAgICBDID0geGEgKiB4YSArIHlhICogeWEgLSByMSAqIHIxLFxuICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIG5ldyBDaXJjbGVXcmFwKG51bGwsIHgxICsgeGEgKyB4YiAqIHIsIHkxICsgeWEgKyB5YiAqIHIsIHIpO1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMoLypBcnJheTxDaXJjbGVXcmFwPiovIEIpIHtcbiAgc3dpdGNoIChCLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBlbmNsb3NlQmFzaXMyKEJbMF0sIEJbMV0pO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBlbmNsb3NlQmFzaXMzKEJbMF0sIEJbMV0sIEJbMl0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdncmFwaG9sb2d5LWxheW91dC9jaXJjbGVwYWNrOiBJbnZhbGlkIGJhc2lzIGxlbmd0aCAnICsgQi5sZW5ndGhcbiAgICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoLypBcnJheTxDaXJjbGVXcmFwPiovIEIsIC8qQ2lyY2xlV3JhcCovIHApIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGVuY2xvc2VzV2Vha0FsbChwLCBCKSkgcmV0dXJuIFtwXTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmIChlbmNsb3Nlc05vdChwLCBCW2ldKSAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQikpIHtcbiAgICAgIHJldHVybiBbQltpXSwgcF07XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBCIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gZWxlbWVudHMuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgQi5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKFxuICAgICAgICBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIEJbal0pLCBwKSAmJlxuICAgICAgICBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKSAmJlxuICAgICAgICBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbal0sIHApLCBCW2ldKSAmJlxuICAgICAgICBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMyhCW2ldLCBCW2pdLCBwKSwgQilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gW0JbaV0sIEJbal0sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmcuXG4gIHRocm93IG5ldyBFcnJvcignZ3JhcGhvbG9neS1sYXlvdXQvY2lyY2xlcGFjazogZXh0ZW5kQmFzaXMgZmFpbHVyZSAhJyk7XG59XG5cbmZ1bmN0aW9uIHNjb3JlKC8qQ2lyY2xlV3JhcCovIG5vZGUpIHtcbiAgdmFyIGEgPSBub2RlLndyYXBwZWRDaXJjbGU7XG4gIHZhciBiID0gbm9kZS5uZXh0LndyYXBwZWRDaXJjbGU7XG4gIHZhciBhYiA9IGEuciArIGIucjtcbiAgdmFyIGR4ID0gKGEueCAqIGIuciArIGIueCAqIGEucikgLyBhYjtcbiAgdmFyIGR5ID0gKGEueSAqIGIuciArIGIueSAqIGEucikgLyBhYjtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlKGNpcmNsZXMsIHNodWZmbGVGdW5jKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGNpcmNsZXNMb2MgPSBjaXJjbGVzLnNsaWNlKCk7XG5cbiAgdmFyIG4gPSBjaXJjbGVzLmxlbmd0aDtcbiAgdmFyIEIgPSBbXTtcbiAgdmFyIHA7XG4gIHZhciBlO1xuICBzaHVmZmxlRnVuYyhjaXJjbGVzTG9jKTtcbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgcCA9IGNpcmNsZXNMb2NbaV07XG4gICAgaWYgKGUgJiYgZW5jbG9zZXNXZWFrKGUsIHApKSB7XG4gICAgICArK2k7XG4gICAgfSBlbHNlIHtcbiAgICAgIEIgPSBleHRlbmRCYXNpcyhCLCBwKTtcbiAgICAgIGUgPSBlbmNsb3NlQmFzaXMoQik7XG4gICAgICBpID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIHBsYWNlKC8qQ2lyY2xlV3JhcCovIGIsIC8qQ2lyY2xlV3JhcCovIGEsIC8qQ2lyY2xlV3JhcCovIGMpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54LFxuICAgIHgsXG4gICAgYTIsXG4gICAgZHkgPSBiLnkgLSBhLnksXG4gICAgeSxcbiAgICBiMixcbiAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMucjtcbiAgICBhMiAqPSBhMjtcbiAgICBiMiA9IGIuciArIGMucjtcbiAgICBiMiAqPSBiMjtcbiAgICBpZiAoYTIgPiBiMikge1xuICAgICAgeCA9IChkMiArIGIyIC0gYTIpIC8gKDIgKiBkMik7XG4gICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGIyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgYy54ID0gYi54IC0geCAqIGR4IC0geSAqIGR5O1xuICAgICAgYy55ID0gYi55IC0geCAqIGR5ICsgeSAqIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKGQyICsgYTIgLSBiMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYTIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBhLnggKyB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBhLnkgKyB4ICogZHkgKyB5ICogZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMueCA9IGEueCArIGMucjtcbiAgICBjLnkgPSBhLnk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cygvKkNpcmNsZVdyYXAqLyBhLCAvKkNpcmNsZVdyYXAqLyBiKSB7XG4gIHZhciBkciA9IGEuciArIGIuciAtIDFlLTYsXG4gICAgZHggPSBiLnggLSBhLngsXG4gICAgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBkciA+IDAgJiYgZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBwYWNrRW5jbG9zZSgvKkFycmF5PENpcmNsZVdyYXA+Ki8gY2lyY2xlcywgc2h1ZmZsZUZ1bmMpIHtcbiAgdmFyIG4gPSBjaXJjbGVzLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHJldHVybiAwO1xuXG4gIHZhciBhLCBiLCBjLCBhYSwgY2EsIGksIGosIGssIHNqLCBzaztcblxuICAvLyBQbGFjZSB0aGUgZmlyc3QgY2lyY2xlLlxuICBhID0gY2lyY2xlc1swXTtcbiAgYS54ID0gMDtcbiAgYS55ID0gMDtcbiAgaWYgKG4gPD0gMSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV07XG4gIGEueCA9IC1iLnI7XG4gIGIueCA9IGEucjtcbiAgYi55ID0gMDtcbiAgaWYgKG4gPD0gMikgcmV0dXJuIGEuciArIGIucjtcblxuICAvLyBQbGFjZSB0aGUgdGhpcmQgY2lyY2xlLlxuICBjID0gY2lyY2xlc1syXTtcbiAgcGxhY2UoYiwgYSwgYyk7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgZnJvbnQtY2hhaW4gdXNpbmcgdGhlIGZpcnN0IHRocmVlIGNpcmNsZXMgYSwgYiBhbmQgYy5cbiAgYSA9IG5ldyBDaXJjbGVXcmFwKG51bGwsIG51bGwsIG51bGwsIG51bGwsIGEpO1xuICBiID0gbmV3IENpcmNsZVdyYXAobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgYik7XG4gIGMgPSBuZXcgQ2lyY2xlV3JhcChudWxsLCBudWxsLCBudWxsLCBudWxsLCBjKTtcbiAgYS5uZXh0ID0gYy5wcmV2aW91cyA9IGI7XG4gIGIubmV4dCA9IGEucHJldmlvdXMgPSBjO1xuICBjLm5leHQgPSBiLnByZXZpb3VzID0gYTtcblxuICAvLyBBdHRlbXB0IHRvIHBsYWNlIGVhY2ggcmVtYWluaW5nIGNpcmNsZeKAplxuICBwYWNrOiBmb3IgKGkgPSAzOyBpIDwgbjsgKytpKSB7XG4gICAgYyA9IGNpcmNsZXNbaV07XG4gICAgcGxhY2UoYS53cmFwcGVkQ2lyY2xlLCBiLndyYXBwZWRDaXJjbGUsIGMpO1xuICAgIGMgPSBuZXcgQ2lyY2xlV3JhcChudWxsLCBudWxsLCBudWxsLCBudWxsLCBjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0O1xuICAgIGsgPSBhLnByZXZpb3VzO1xuICAgIHNqID0gYi53cmFwcGVkQ2lyY2xlLnI7XG4gICAgc2sgPSBhLndyYXBwZWRDaXJjbGUucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai53cmFwcGVkQ2lyY2xlLCBjLndyYXBwZWRDaXJjbGUpKSB7XG4gICAgICAgICAgYiA9IGo7XG4gICAgICAgICAgYS5uZXh0ID0gYjtcbiAgICAgICAgICBiLnByZXZpb3VzID0gYTtcbiAgICAgICAgICAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLndyYXBwZWRDaXJjbGUucjtcbiAgICAgICAgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsud3JhcHBlZENpcmNsZSwgYy53cmFwcGVkQ2lyY2xlKSkge1xuICAgICAgICAgIGEgPSBrO1xuICAgICAgICAgIGEubmV4dCA9IGI7XG4gICAgICAgICAgYi5wcmV2aW91cyA9IGE7XG4gICAgICAgICAgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay53cmFwcGVkQ2lyY2xlLnI7XG4gICAgICAgIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGE7XG4gICAgYy5uZXh0ID0gYjtcbiAgICBhLm5leHQgPSBiLnByZXZpb3VzID0gYiA9IGM7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXcgY2xvc2VzdCBjaXJjbGUgcGFpciB0byB0aGUgY2VudHJvaWQuXG4gICAgYWEgPSBzY29yZShhKTtcbiAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgICBpZiAoKGNhID0gc2NvcmUoYykpIDwgYWEpIHtcbiAgICAgICAgYSA9IGM7XG4gICAgICAgIGFhID0gY2E7XG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBhLm5leHQ7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBlbmNsb3NpbmcgY2lyY2xlIG9mIHRoZSBmcm9udCBjaGFpbi5cbiAgYSA9IFtiLndyYXBwZWRDaXJjbGVdO1xuICBjID0gYjtcbiAgdmFyIHNhZmV0eSA9IDEwMDAwO1xuICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgaWYgKC0tc2FmZXR5ID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYS5wdXNoKGMud3JhcHBlZENpcmNsZSk7XG4gIH1cbiAgYyA9IGVuY2xvc2UoYSwgc2h1ZmZsZUZ1bmMpO1xuXG4gIC8vIFRyYW5zbGF0ZSB0aGUgY2lyY2xlcyB0byBwdXQgdGhlIGVuY2xvc2luZyBjaXJjbGUgYXJvdW5kIHRoZSBvcmlnaW4uXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhID0gY2lyY2xlc1tpXTtcbiAgICBhLnggLT0gYy54O1xuICAgIGEueSAtPSBjLnk7XG4gIH1cbiAgcmV0dXJuIGMucjtcbn1cblxuZnVuY3Rpb24gcGFja0hpZXJhcmNoeSgvKkNpcmNsZVdyYXAqLyBwYXJlbnRDaXJjbGUsIHNodWZmbGVGdW5jKSB7XG4gIHZhciByID0gMDtcbiAgaWYgKHBhcmVudENpcmNsZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgLy9wYWNrIHRoZSBjaGlsZHJlbiBmaXJzdCBiZWNhdXNlIHRoZSByYWRpdXMgaXMgZGV0ZXJtaW5lZCBieSBob3cgdGhlIGNoaWxkcmVuIGdldCBwYWNrZWQgKHJlY3Vyc2l2ZSlcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyZW50Q2lyY2xlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2lyY2xlID0gcGFyZW50Q2lyY2xlLmNoaWxkcmVuW2tleV07XG4gICAgICBpZiAoY2lyY2xlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgY2lyY2xlLnIgPSBwYWNrSGllcmFyY2h5KGNpcmNsZSwgc2h1ZmZsZUZ1bmMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvL25vdyB0aGF0IGVhY2ggY2lyY2xlIGhhcyBhIHJhZGl1cyBzZXQgYnkgaXRzIGNoaWxkcmVuLCBwYWNrIHRoZSBjaXJjbGVzIGF0IHRoaXMgbGV2ZWxcbiAgICByID0gcGFja0VuY2xvc2UoT2JqZWN0LnZhbHVlcyhwYXJlbnRDaXJjbGUuY2hpbGRyZW4pLCBzaHVmZmxlRnVuYyk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHBhY2tIaWVyYXJjaHlBbmRTaGlmdCgvKkNpcmNsZVdyYXAqLyBwYXJlbnRDaXJjbGUsIHNodWZmbGVGdW5jKSB7XG4gIHBhY2tIaWVyYXJjaHkocGFyZW50Q2lyY2xlLCBzaHVmZmxlRnVuYyk7XG4gIGZvciAodmFyIGtleSBpbiBwYXJlbnRDaXJjbGUuY2hpbGRyZW4pIHtcbiAgICB2YXIgY2lyY2xlID0gcGFyZW50Q2lyY2xlLmNoaWxkcmVuW2tleV07XG4gICAgY2lyY2xlLmFwcGx5UG9zaXRpb25Ub0NoaWxkcmVuKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBmdW5jdGlvbiBydW5uaW5nIHRoZSBsYXlvdXQuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgICAgICAgICAgIC0gVGFyZ2V0ICBncmFwaC5cbiAqIEBwYXJhbSAge29iamVjdH0gICBbb3B0aW9uc10gICAgICAgICAgICAgICAtIE9wdGlvbnM6XG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICBbYXR0cmlidXRlc10gICAgICAgICAgLSBBdHRyaWJ1dGVzIG5hbWVzIHRvIG1hcC5cbiAqIEBwYXJhbSAge251bWJlcn0gICAgIFtjZW50ZXJdICAgICAgICAgICAgICAtIENlbnRlciBvZiB0aGUgbGF5b3V0LlxuICogQHBhcmFtICB7c3RyaW5nW119ICAgW2hpZXJhcmNoeUF0dHJpYnV0ZXNdIC0gTGlzdCBvZiBhdHRyaWJ1dGVzIHVzZWQgZm9yIHRoZSBsYXlvdXQgaW4gZGVjcmVhc2luZyBvcmRlci5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgIFtybmddICAgICAgICAgICAgICAgICAtIEN1c3RvbSBSTkcgZnVuY3Rpb24gdG8gYmUgdXNlZC5cbiAqIEBwYXJhbSAge251bWJlcn0gICAgIFtzY2FsZV0gICAgICAgICAgICAgICAtIFNjYWxlIG9mIHRoZSBsYXlvdXQuXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgcG9zaXRpb25zIGJ5IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyaWNDaXJjbGVQYWNrTGF5b3V0KGFzc2lnbiwgZ3JhcGgsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQvY2lyY2xlcGFjazogdGhlIGdpdmVuIGdyYXBoIGlzIG5vdCBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgb3B0aW9ucyA9IHJlc29sdmVEZWZhdWx0cyhvcHRpb25zLCBERUZBVUxUUyk7XG5cbiAgdmFyIHBvc01hcCA9IHt9LFxuICAgIHBvc2l0aW9ucyA9IHt9LFxuICAgIG5vZGVzID0gZ3JhcGgubm9kZXMoKSxcbiAgICBjZW50ZXIgPSBvcHRpb25zLmNlbnRlcixcbiAgICBoaWVyYXJjaHlBdHRyaWJ1dGVzID0gb3B0aW9ucy5oaWVyYXJjaHlBdHRyaWJ1dGVzLFxuICAgIHNodWZmbGVGdW5jID0gc2h1ZmZsZS5jcmVhdGVTaHVmZmxlSW5QbGFjZShvcHRpb25zLnJuZyksXG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gIHZhciBjb250YWluZXIgPSBuZXcgQ2lyY2xlV3JhcCgpO1xuXG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChrZXksIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgciA9IGF0dHJpYnV0ZXMuc2l6ZSA/IGF0dHJpYnV0ZXMuc2l6ZSA6IDE7XG4gICAgdmFyIG5ld0NpcmNsZVdyYXAgPSBuZXcgQ2lyY2xlV3JhcChrZXksIG51bGwsIG51bGwsIHIpO1xuICAgIHZhciBwYXJlbnRDb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICBoaWVyYXJjaHlBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1t2XTtcbiAgICAgIHBhcmVudENvbnRhaW5lciA9IHBhcmVudENvbnRhaW5lci5nZXRDaGlsZChhdHRyKTtcbiAgICB9KTtcblxuICAgIHBhcmVudENvbnRhaW5lci5hZGRDaGlsZChrZXksIG5ld0NpcmNsZVdyYXApO1xuICB9KTtcbiAgcGFja0hpZXJhcmNoeUFuZFNoaWZ0KGNvbnRhaW5lciwgc2h1ZmZsZUZ1bmMpO1xuICBzZXROb2RlKGdyYXBoLCBjb250YWluZXIsIHBvc01hcCk7XG4gIHZhciBsID0gbm9kZXMubGVuZ3RoLFxuICAgIHgsXG4gICAgeSxcbiAgICBpO1xuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIHggPSBjZW50ZXIgKyBzY2FsZSAqIHBvc01hcFtub2RlXS54O1xuICAgIHkgPSBjZW50ZXIgKyBzY2FsZSAqIHBvc01hcFtub2RlXS55O1xuXG4gICAgcG9zaXRpb25zW25vZGVdID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgaWYgKGFzc2lnbikge1xuICAgICAgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBvcHRpb25zLmF0dHJpYnV0ZXMueCwgeCk7XG4gICAgICBncmFwaC5zZXROb2RlQXR0cmlidXRlKG5vZGUsIG9wdGlvbnMuYXR0cmlidXRlcy55LCB5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxudmFyIGNpcmNsZVBhY2tMYXlvdXQgPSBnZW5lcmljQ2lyY2xlUGFja0xheW91dC5iaW5kKG51bGwsIGZhbHNlKTtcbmNpcmNsZVBhY2tMYXlvdXQuYXNzaWduID0gZ2VuZXJpY0NpcmNsZVBhY2tMYXlvdXQuYmluZChudWxsLCB0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaXJjbGVQYWNrTGF5b3V0O1xuIiwiLyoqXG4gKiBHcmFwaG9sb2d5IENpcmN1bGFyIExheW91dFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTGF5b3V0IGFycmFuZ2luZyB0aGUgbm9kZXMgaW4gYSBjaXJjbGUuXG4gKi9cbnZhciByZXNvbHZlRGVmYXVsdHMgPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2RlZmF1bHRzJyk7XG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMuXG4gKi9cbnZhciBERUZBVUxUUyA9IHtcbiAgZGltZW5zaW9uczogWyd4JywgJ3knXSxcbiAgY2VudGVyOiAwLjUsXG4gIHNjYWxlOiAxXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGZ1bmN0aW9uIHJ1bm5pbmcgdGhlIGxheW91dC5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgICAgICAgLSBUYXJnZXQgIGdyYXBoLlxuICogQHBhcmFtICB7b2JqZWN0fSAgIFtvcHRpb25zXSAgICAgIC0gT3B0aW9uczpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgIFthdHRyaWJ1dGVzXSAtIEF0dHJpYnV0ZXMgbmFtZXMgdG8gbWFwLlxuICogQHBhcmFtICB7bnVtYmVyfSAgICAgW2NlbnRlcl0gICAgIC0gQ2VudGVyIG9mIHRoZSBsYXlvdXQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgICBbc2NhbGVdICAgICAgLSBTY2FsZSBvZiB0aGUgbGF5b3V0LlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gVGhlIHBvc2l0aW9ucyBieSBub2RlLlxuICovXG5mdW5jdGlvbiBnZW5lcmljQ2lyY3VsYXJMYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWxheW91dC9yYW5kb206IHRoZSBnaXZlbiBncmFwaCBpcyBub3QgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlLidcbiAgICApO1xuXG4gIG9wdGlvbnMgPSByZXNvbHZlRGVmYXVsdHMob3B0aW9ucywgREVGQVVMVFMpO1xuXG4gIHZhciBkaW1lbnNpb25zID0gb3B0aW9ucy5kaW1lbnNpb25zO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShkaW1lbnNpb25zKSB8fCBkaW1lbnNpb25zLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBob2xvZ3ktbGF5b3V0L3JhbmRvbTogZ2l2ZW4gZGltZW5zaW9ucyBhcmUgaW52YWxpZC4nKTtcblxuICB2YXIgY2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gIHZhciBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIHZhciB0YXUgPSBNYXRoLlBJICogMjtcblxuICB2YXIgb2Zmc2V0ID0gKGNlbnRlciAtIDAuNSkgKiBzY2FsZTtcbiAgdmFyIGwgPSBncmFwaC5vcmRlcjtcblxuICB2YXIgeCA9IGRpbWVuc2lvbnNbMF07XG4gIHZhciB5ID0gZGltZW5zaW9uc1sxXTtcblxuICBmdW5jdGlvbiBhc3NpZ25Qb3NpdGlvbihpLCB0YXJnZXQpIHtcbiAgICB0YXJnZXRbeF0gPSBzY2FsZSAqIE1hdGguY29zKChpICogdGF1KSAvIGwpICsgb2Zmc2V0O1xuICAgIHRhcmdldFt5XSA9IHNjYWxlICogTWF0aC5zaW4oKGkgKiB0YXUpIC8gbCkgKyBvZmZzZXQ7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmICghYXNzaWduKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuXG4gICAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHBvc2l0aW9uc1tub2RlXSA9IGFzc2lnblBvc2l0aW9uKGkrKywge30pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIGdyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyhcbiAgICBmdW5jdGlvbiAoXywgYXR0cikge1xuICAgICAgYXNzaWduUG9zaXRpb24oaSsrLCBhdHRyKTtcbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0sXG4gICAge1xuICAgICAgYXR0cmlidXRlczogZGltZW5zaW9uc1xuICAgIH1cbiAgKTtcbn1cblxudmFyIGNpcmN1bGFyTGF5b3V0ID0gZ2VuZXJpY0NpcmN1bGFyTGF5b3V0LmJpbmQobnVsbCwgZmFsc2UpO1xuY2lyY3VsYXJMYXlvdXQuYXNzaWduID0gZ2VuZXJpY0NpcmN1bGFyTGF5b3V0LmJpbmQobnVsbCwgdHJ1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2lyY3VsYXJMYXlvdXQ7XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgTGF5b3V0XG4gKiA9PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBMaWJyYXJ5IGVuZHBvaW50LlxuICovXG5leHBvcnRzLmNpcmNsZXBhY2sgPSByZXF1aXJlKCcuL2NpcmNsZXBhY2suanMnKTtcbmV4cG9ydHMuY2lyY3VsYXIgPSByZXF1aXJlKCcuL2NpcmN1bGFyLmpzJyk7XG5leHBvcnRzLnJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tLmpzJyk7XG5leHBvcnRzLnJvdGF0aW9uID0gcmVxdWlyZSgnLi9yb3RhdGlvbi5qcycpO1xuIiwiLyoqXG4gKiBHcmFwaG9sb2d5IFJhbmRvbSBMYXlvdXRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBTaW1wbGUgbGF5b3V0IGdpdmluZyB1bmlmb3JtIHJhbmRvbSBwb3NpdGlvbnMgdG8gdGhlIG5vZGVzLlxuICovXG52YXIgcmVzb2x2ZURlZmF1bHRzID0gcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9kZWZhdWx0cycpO1xudmFyIGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG4gIGNlbnRlcjogMC41LFxuICBybmc6IE1hdGgucmFuZG9tLFxuICBzY2FsZTogMVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBmdW5jdGlvbiBydW5uaW5nIHRoZSBsYXlvdXQuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgIC0gVGFyZ2V0ICBncmFwaC5cbiAqIEBwYXJhbSAge29iamVjdH0gICBbb3B0aW9uc10gICAgICAtIE9wdGlvbnM6XG4gKiBAcGFyYW0gIHthcnJheX0gICAgICBbZGltZW5zaW9uc10gLSBMaXN0IG9mIGRpbWVuc2lvbnMgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSAge251bWJlcn0gICAgIFtjZW50ZXJdICAgICAtIENlbnRlciBvZiB0aGUgbGF5b3V0LlxuICogQHBhcmFtICB7ZnVuY3Rpb259ICAgW3JuZ10gICAgICAgIC0gQ3VzdG9tIFJORyBmdW5jdGlvbiB0byBiZSB1c2VkLlxuICogQHBhcmFtICB7bnVtYmVyfSAgICAgW3NjYWxlXSAgICAgIC0gU2NhbGUgb2YgdGhlIGxheW91dC5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAtIFRoZSBwb3NpdGlvbnMgYnkgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJpY1JhbmRvbUxheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0L3JhbmRvbTogdGhlIGdpdmVuIGdyYXBoIGlzIG5vdCBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgb3B0aW9ucyA9IHJlc29sdmVEZWZhdWx0cyhvcHRpb25zLCBERUZBVUxUUyk7XG5cbiAgdmFyIGRpbWVuc2lvbnMgPSBvcHRpb25zLmRpbWVuc2lvbnM7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGRpbWVuc2lvbnMpIHx8IGRpbWVuc2lvbnMubGVuZ3RoIDwgMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBob2xvZ3ktbGF5b3V0L3JhbmRvbTogZ2l2ZW4gZGltZW5zaW9ucyBhcmUgaW52YWxpZC4nKTtcblxuICB2YXIgZCA9IGRpbWVuc2lvbnMubGVuZ3RoO1xuICB2YXIgY2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gIHZhciBybmcgPSBvcHRpb25zLnJuZztcbiAgdmFyIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcblxuICB2YXIgb2Zmc2V0ID0gKGNlbnRlciAtIDAuNSkgKiBzY2FsZTtcblxuICBmdW5jdGlvbiBhc3NpZ25Qb3NpdGlvbih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQ7IGkrKykge1xuICAgICAgdGFyZ2V0W2RpbWVuc2lvbnNbaV1dID0gcm5nKCkgKiBzY2FsZSArIG9mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKCFhc3NpZ24pIHtcbiAgICB2YXIgcG9zaXRpb25zID0ge307XG5cbiAgICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcG9zaXRpb25zW25vZGVdID0gYXNzaWduUG9zaXRpb24oe30pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIGdyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyhcbiAgICBmdW5jdGlvbiAoXywgYXR0cikge1xuICAgICAgYXNzaWduUG9zaXRpb24oYXR0cik7XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9LFxuICAgIHtcbiAgICAgIGF0dHJpYnV0ZXM6IGRpbWVuc2lvbnNcbiAgICB9XG4gICk7XG59XG5cbnZhciByYW5kb21MYXlvdXQgPSBnZW5lcmljUmFuZG9tTGF5b3V0LmJpbmQobnVsbCwgZmFsc2UpO1xucmFuZG9tTGF5b3V0LmFzc2lnbiA9IGdlbmVyaWNSYW5kb21MYXlvdXQuYmluZChudWxsLCB0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5kb21MYXlvdXQ7XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgUm90YXRpb24gTGF5b3V0IEhlbHBlclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIHJvdGF0aW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZ3JhcGguXG4gKi9cbnZhciByZXNvbHZlRGVmYXVsdHMgPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2RlZmF1bHRzJyk7XG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBSQURfQ09OVkVSU0lPTiA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zLlxuICovXG52YXIgREVGQVVMVFMgPSB7XG4gIGRpbWVuc2lvbnM6IFsneCcsICd5J10sXG4gIGNlbnRlcmVkT25aZXJvOiBmYWxzZSxcbiAgZGVncmVlczogZmFsc2Vcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgZnVuY3Rpb24gZm9yIHJvdGF0aW5nIGEgZ3JhcGgncyBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgICAgICAgLSBUYXJnZXQgIGdyYXBoLlxuICogQHBhcmFtICB7bnVtYmVyfSAgIGFuZ2xlICAgICAgICAgIC0gUm90YXRpb24gYW5nbGUuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnNdICAgICAgLSBPcHRpb25zLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gVGhlIHBvc2l0aW9ucyBieSBub2RlLlxuICovXG5mdW5jdGlvbiBnZW5lcmljUm90YXRpb24oYXNzaWduLCBncmFwaCwgYW5nbGUsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQvcm90YXRpb246IHRoZSBnaXZlbiBncmFwaCBpcyBub3QgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlLidcbiAgICApO1xuXG4gIG9wdGlvbnMgPSByZXNvbHZlRGVmYXVsdHMob3B0aW9ucywgREVGQVVMVFMpO1xuXG4gIGlmIChvcHRpb25zLmRlZ3JlZXMpIGFuZ2xlICo9IFJBRF9DT05WRVJTSU9OO1xuXG4gIHZhciBkaW1lbnNpb25zID0gb3B0aW9ucy5kaW1lbnNpb25zO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShkaW1lbnNpb25zKSB8fCBkaW1lbnNpb25zLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBob2xvZ3ktbGF5b3V0L3JhbmRvbTogZ2l2ZW4gZGltZW5zaW9ucyBhcmUgaW52YWxpZC4nKTtcblxuICAvLyBIYW5kbGluZyBudWxsIGdyYXBoXG4gIGlmIChncmFwaC5vcmRlciA9PT0gMCkge1xuICAgIGlmIChhc3NpZ24pIHJldHVybjtcblxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHZhciB4ZCA9IGRpbWVuc2lvbnNbMF07XG4gIHZhciB5ZCA9IGRpbWVuc2lvbnNbMV07XG5cbiAgdmFyIHhDZW50ZXIgPSAwO1xuICB2YXIgeUNlbnRlciA9IDA7XG5cbiAgaWYgKCFvcHRpb25zLmNlbnRlcmVkT25aZXJvKSB7XG4gICAgLy8gRmluZGluZyBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgdmFyIHhNaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgeE1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgeU1pbiA9IEluZmluaXR5O1xuICAgIHZhciB5TWF4ID0gLUluZmluaXR5O1xuXG4gICAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgIHZhciB4ID0gYXR0clt4ZF07XG4gICAgICB2YXIgeSA9IGF0dHJbeWRdO1xuXG4gICAgICBpZiAoeCA8IHhNaW4pIHhNaW4gPSB4O1xuICAgICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgICBpZiAoeSA+IHlNYXgpIHlNYXggPSB5O1xuICAgIH0pO1xuXG4gICAgeENlbnRlciA9ICh4TWluICsgeE1heCkgLyAyO1xuICAgIHlDZW50ZXIgPSAoeU1pbiArIHlNYXgpIC8gMjtcbiAgfVxuXG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgZnVuY3Rpb24gYXNzaWduUG9zaXRpb24odGFyZ2V0KSB7XG4gICAgdmFyIHggPSB0YXJnZXRbeGRdO1xuICAgIHZhciB5ID0gdGFyZ2V0W3lkXTtcblxuICAgIHRhcmdldFt4ZF0gPSB4Q2VudGVyICsgKHggLSB4Q2VudGVyKSAqIGNvcyAtICh5IC0geUNlbnRlcikgKiBzaW47XG4gICAgdGFyZ2V0W3lkXSA9IHlDZW50ZXIgKyAoeCAtIHhDZW50ZXIpICogc2luICsgKHkgLSB5Q2VudGVyKSAqIGNvcztcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoIWFzc2lnbikge1xuICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcblxuICAgIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgb1t4ZF0gPSBhdHRyW3hkXTtcbiAgICAgIG9beWRdID0gYXR0clt5ZF07XG4gICAgICBwb3NpdGlvbnNbbm9kZV0gPSBhc3NpZ25Qb3NpdGlvbihvKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3NpdGlvbnM7XG4gIH1cblxuICBncmFwaC51cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXMoXG4gICAgZnVuY3Rpb24gKF8sIGF0dHIpIHtcbiAgICAgIGFzc2lnblBvc2l0aW9uKGF0dHIpO1xuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSxcbiAgICB7XG4gICAgICBhdHRyaWJ1dGVzOiBkaW1lbnNpb25zXG4gICAgfVxuICApO1xufVxuXG52YXIgcm90YXRpb24gPSBnZW5lcmljUm90YXRpb24uYmluZChudWxsLCBmYWxzZSk7XG5yb3RhdGlvbi5hc3NpZ24gPSBnZW5lcmljUm90YXRpb24uYmluZChudWxsLCB0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb3RhdGlvbjtcbiIsIi8qKlxuICogR3JhcGhvbG9neSBEZWZhdWx0c1xuICogPT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0aHJvdWdob3V0IHRoZSBzdGFuZGFyZCBsaWIgdG8gcmVzb2x2ZSBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaXNMZWFmKG8pIHtcbiAgcmV0dXJuIChcbiAgICAhbyB8fFxuICAgIHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8XG4gICAgQXJyYXkuaXNBcnJheShvKSB8fFxuICAgIG8gaW5zdGFuY2VvZiBTZXQgfHxcbiAgICBvIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgbyBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgIG8gaW5zdGFuY2VvZiBEYXRlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0cyh0YXJnZXQsIGRlZmF1bHRzKSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcblxuICB2YXIgb3V0cHV0ID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBkZWZhdWx0cykge1xuICAgIHZhciBleGlzdGluZyA9IHRhcmdldFtrXTtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNba107XG5cbiAgICAvLyBSZWN1cnNpb25cbiAgICBpZiAoIWlzTGVhZihkZWYpKSB7XG4gICAgICBvdXRwdXRba10gPSByZXNvbHZlRGVmYXVsdHMoZXhpc3RpbmcsIGRlZik7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIExlYWZcbiAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0W2tdID0gZGVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRba10gPSBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVEZWZhdWx0cztcbiIsIi8qKlxuICogR3JhcGhvbG9neSBXZWlnaHQgR2V0dGVyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgd2VpZ2h0IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVdlaWdodCh2YWx1ZSkge1xuICAvLyBFbnN1cmluZyB0YXJnZXQgdmFsdWUgaXMgYSBjb3JyZWN0IG51bWJlclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHJldHVybiAxO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZVZhbHVlR2V0dGVyKG5hbWVPckZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGdldHRlciA9IHt9O1xuXG4gIHZhciBjb2VyY2VUb0RlZmF1bHQgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgY29lcmNlVG9EZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoYXR0cmlidXRlc1tuYW1lT3JGdW5jdGlvbl0pO1xuICB9O1xuXG4gIHZhciByZXR1cm5EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQodW5kZWZpbmVkKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGdldDtcbiAgICBnZXR0ZXIuZnJvbUdyYXBoID0gZnVuY3Rpb24gKGdyYXBoLCBub2RlKSB7XG4gICAgICByZXR1cm4gZ2V0KGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAobm9kZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGdldChhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2dyYXBob2xvZ3ktdXRpbHMvZ2V0dGVycy9jcmVhdGVOb2RlVmFsdWVHZXR0ZXI6IGlycmVsZXZhbnQgdXNhZ2UuJ1xuICAgICAgKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSBmdW5jdGlvbiAoZ3JhcGgsIG5vZGUpIHtcbiAgICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoXG4gICAgICAgIG5hbWVPckZ1bmN0aW9uKG5vZGUsIGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAobm9kZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihub2RlLCBhdHRyaWJ1dGVzKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIuZnJvbUF0dHJpYnV0ZXMgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSByZXR1cm5EZWZhdWx0O1xuICB9XG5cbiAgcmV0dXJuIGdldHRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWRnZVZhbHVlR2V0dGVyKG5hbWVPckZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGdldHRlciA9IHt9O1xuXG4gIHZhciBjb2VyY2VUb0RlZmF1bHQgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgY29lcmNlVG9EZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoYXR0cmlidXRlc1tuYW1lT3JGdW5jdGlvbl0pO1xuICB9O1xuXG4gIHZhciByZXR1cm5EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQodW5kZWZpbmVkKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGdldDtcbiAgICBnZXR0ZXIuZnJvbUdyYXBoID0gZnVuY3Rpb24gKGdyYXBoLCBlZGdlKSB7XG4gICAgICByZXR1cm4gZ2V0KGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGVkZ2UpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAoZWRnZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGdldChhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tUGFydGlhbEVudHJ5ID0gZ2V0dGVyLmZyb21FbnRyeTtcbiAgICBnZXR0ZXIuZnJvbU1pbmltYWxFbnRyeSA9IGdldHRlci5mcm9tRW50cnk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZ2V0dGVyLmZyb21BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZ3JhcGhvbG9neS11dGlscy9nZXR0ZXJzL2NyZWF0ZUVkZ2VWYWx1ZUdldHRlcjogaXJyZWxldmFudCB1c2FnZS4nXG4gICAgICApO1xuICAgIH07XG4gICAgZ2V0dGVyLmZyb21HcmFwaCA9IGZ1bmN0aW9uIChncmFwaCwgZWRnZSkge1xuICAgICAgLy8gVE9ETzogd2UgY2FuIGRvIGJldHRlciwgY2hlY2sgIzMxMFxuICAgICAgdmFyIGV4dHJlbWl0aWVzID0gZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSk7XG4gICAgICByZXR1cm4gY29lcmNlVG9EZWZhdWx0KFxuICAgICAgICBuYW1lT3JGdW5jdGlvbihcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGVkZ2UpLFxuICAgICAgICAgIGV4dHJlbWl0aWVzWzBdLFxuICAgICAgICAgIGV4dHJlbWl0aWVzWzFdLFxuICAgICAgICAgIGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKGV4dHJlbWl0aWVzWzBdKSxcbiAgICAgICAgICBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhleHRyZW1pdGllc1sxXSksXG4gICAgICAgICAgZ3JhcGguaXNVbmRpcmVjdGVkKGVkZ2UpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfTtcbiAgICBnZXR0ZXIuZnJvbUVudHJ5ID0gZnVuY3Rpb24gKGUsIGEsIHMsIHQsIHNhLCB0YSwgdSkge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihlLCBhLCBzLCB0LCBzYSwgdGEsIHUpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tUGFydGlhbEVudHJ5ID0gZnVuY3Rpb24gKGUsIGEsIHMsIHQpIHtcbiAgICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQobmFtZU9yRnVuY3Rpb24oZSwgYSwgcywgdCkpO1xuICAgIH07XG4gICAgZ2V0dGVyLmZyb21NaW5pbWFsRW50cnkgPSBmdW5jdGlvbiAoZSwgYSkge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihlLCBhKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIuZnJvbUF0dHJpYnV0ZXMgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tTWluaW1hbEVudHJ5ID0gcmV0dXJuRGVmYXVsdDtcbiAgfVxuXG4gIHJldHVybiBnZXR0ZXI7XG59XG5cbmV4cG9ydHMuY3JlYXRlTm9kZVZhbHVlR2V0dGVyID0gY3JlYXRlTm9kZVZhbHVlR2V0dGVyO1xuZXhwb3J0cy5jcmVhdGVFZGdlVmFsdWVHZXR0ZXIgPSBjcmVhdGVFZGdlVmFsdWVHZXR0ZXI7XG5leHBvcnRzLmNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gY3JlYXRlRWRnZVZhbHVlR2V0dGVyKG5hbWUsIGNvZXJjZVdlaWdodCk7XG59O1xuIiwiLyoqXG4gKiBHcmFwaG9sb2d5IGlzR3JhcGhcbiAqID09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBWZXJ5IHNpbXBsZSBmdW5jdGlvbiBhaW1pbmcgYXQgZW5zdXJpbmcgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFcbiAqIGdyYXBob2xvZ3kgaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBDaGVja2luZyB0aGUgdmFsdWUgaXMgYSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge2FueX0gICAgIHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dyYXBoKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5kcm9wTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5tdWx0aSA9PT0gJ2Jvb2xlYW4nXG4gICk7XG59O1xuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5ncmFwaG9sb2d5PWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe3JldHVybiB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9LHQoZSl9ZnVuY3Rpb24gZSh0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQscih0LGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIG49T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0sbih0KX1mdW5jdGlvbiByKHQsZSl7cmV0dXJuIHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9LHIodCxlKX1mdW5jdGlvbiBpKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19ZnVuY3Rpb24gbyh0LGUsbil7cmV0dXJuIG89aSgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1bbnVsbF07aS5wdXNoLmFwcGx5KGksZSk7dmFyIG89bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkodCxpKSk7cmV0dXJuIG4mJnIobyxuLnByb3RvdHlwZSksb30sby5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYSh0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuIGE9ZnVuY3Rpb24odCl7aWYobnVsbD09PXR8fChpPXQsLTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKGkpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSlyZXR1cm4gdDt2YXIgaTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT1lKXtpZihlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7ZS5zZXQodCxhKX1mdW5jdGlvbiBhKCl7cmV0dXJuIG8odCxhcmd1bWVudHMsbih0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIGEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTphLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHIoYSx0KX0sYSh0KX1mdW5jdGlvbiB1KHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fXZhciBjPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTEsbj1hcmd1bWVudHMubGVuZ3RoO2U8bjtlKyspaWYoYXJndW1lbnRzW2VdKWZvcih2YXIgciBpbiBhcmd1bWVudHNbZV0pdFtyXT1hcmd1bWVudHNbZV1bcl07cmV0dXJuIHR9O2Z1bmN0aW9uIHModCxlLG4scil7dmFyIGk9dC5fbm9kZXMuZ2V0KGUpLG89bnVsbDtyZXR1cm4gaT9vPVwibWl4ZWRcIj09PXI/aS5vdXQmJmkub3V0W25dfHxpLnVuZGlyZWN0ZWQmJmkudW5kaXJlY3RlZFtuXTpcImRpcmVjdGVkXCI9PT1yP2kub3V0JiZpLm91dFtuXTppLnVuZGlyZWN0ZWQmJmkudW5kaXJlY3RlZFtuXTpvfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIG51bGwhPT1lJiZcIm9iamVjdFwiPT09dChlKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZHJvcE5vZGV9ZnVuY3Rpb24gaChlKXtyZXR1cm5cIm9iamVjdFwiPT09dChlKSYmbnVsbCE9PWUmJmUuY29uc3RydWN0b3I9PT1PYmplY3R9ZnVuY3Rpb24gcCh0KXt2YXIgZTtmb3IoZSBpbiB0KXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGYodCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLHdyaXRhYmxlOiEwLHZhbHVlOm59KX1mdW5jdGlvbiBsKHQsZSxuKXt2YXIgcj17ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9O1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/ci5nZXQ9bjooci52YWx1ZT1uLHIud3JpdGFibGU9ITEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUscil9ZnVuY3Rpb24gZyh0KXtyZXR1cm4hIWgodCkmJiEodC5hdHRyaWJ1dGVzJiYhQXJyYXkuaXNBcnJheSh0LmF0dHJpYnV0ZXMpKX1cImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuYXNzaWduJiYoYz1PYmplY3QuYXNzaWduKTt2YXIgeSx3PXtleHBvcnRzOnt9fSx2PVwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0P1JlZmxlY3Q6bnVsbCxiPXYmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHYuYXBwbHk/di5hcHBseTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHQsZSxuKX07eT12JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB2Lm93bktleXM/di5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKX06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpfTt2YXIgbT1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKHQpe3JldHVybiB0IT10fTtmdW5jdGlvbiBrKCl7ay5pbml0LmNhbGwodGhpcyl9dy5leHBvcnRzPWssdy5leHBvcnRzLm9uY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7ZnVuY3Rpb24gaShuKXt0LnJlbW92ZUxpc3RlbmVyKGUsbykscihuKX1mdW5jdGlvbiBvKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdC5yZW1vdmVMaXN0ZW5lciYmdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsaSksbihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfU4odCxlLG8se29uY2U6ITB9KSxcImVycm9yXCIhPT1lJiZmdW5jdGlvbih0LGUsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgdC5vbiYmTih0LFwiZXJyb3JcIixlLG4pfSh0LGkse29uY2U6ITB9KX0pKX0say5FdmVudEVtaXR0ZXI9ayxrLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxrLnByb3RvdHlwZS5fZXZlbnRzQ291bnQ9MCxrLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMDt2YXIgXz0xMDtmdW5jdGlvbiBHKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCl9ZnVuY3Rpb24geCh0KXtyZXR1cm4gdm9pZCAwPT09dC5fbWF4TGlzdGVuZXJzP2suZGVmYXVsdE1heExpc3RlbmVyczp0Ll9tYXhMaXN0ZW5lcnN9ZnVuY3Rpb24gRSh0LGUsbixyKXt2YXIgaSxvLGEsdTtpZihHKG4pLHZvaWQgMD09PShvPXQuX2V2ZW50cyk/KG89dC5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdC5fZXZlbnRzQ291bnQ9MCk6KHZvaWQgMCE9PW8ubmV3TGlzdGVuZXImJih0LmVtaXQoXCJuZXdMaXN0ZW5lclwiLGUsbi5saXN0ZW5lcj9uLmxpc3RlbmVyOm4pLG89dC5fZXZlbnRzKSxhPW9bZV0pLHZvaWQgMD09PWEpYT1vW2VdPW4sKyt0Ll9ldmVudHNDb3VudDtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGE/YT1vW2VdPXI/W24sYV06W2Esbl06cj9hLnVuc2hpZnQobik6YS5wdXNoKG4pLChpPXgodCkpPjAmJmEubGVuZ3RoPmkmJiFhLndhcm5lZCl7YS53YXJuZWQ9ITA7dmFyIGM9bmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIithLmxlbmd0aCtcIiBcIitTdHJpbmcoZSkrXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKTtjLm5hbWU9XCJNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmdcIixjLmVtaXR0ZXI9dCxjLnR5cGU9ZSxjLmNvdW50PWEubGVuZ3RoLHU9Yyxjb25zb2xlJiZjb25zb2xlLndhcm4mJmNvbnNvbGUud2Fybih1KX1yZXR1cm4gdH1mdW5jdGlvbiBBKCl7aWYoIXRoaXMuZmlyZWQpcmV0dXJuIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbiksdGhpcy5maXJlZD0hMCwwPT09YXJndW1lbnRzLmxlbmd0aD90aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpOnRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsYXJndW1lbnRzKX1mdW5jdGlvbiBTKHQsZSxuKXt2YXIgcj17ZmlyZWQ6ITEsd3JhcEZuOnZvaWQgMCx0YXJnZXQ6dCx0eXBlOmUsbGlzdGVuZXI6bn0saT1BLmJpbmQocik7cmV0dXJuIGkubGlzdGVuZXI9bixyLndyYXBGbj1pLGl9ZnVuY3Rpb24gRCh0LGUsbil7dmFyIHI9dC5fZXZlbnRzO2lmKHZvaWQgMD09PXIpcmV0dXJuW107dmFyIGk9cltlXTtyZXR1cm4gdm9pZCAwPT09aT9bXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBpP24/W2kubGlzdGVuZXJ8fGldOltpXTpuP2Z1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgpLG49MDtuPGUubGVuZ3RoOysrbillW25dPXRbbl0ubGlzdGVuZXJ8fHRbbl07cmV0dXJuIGV9KGkpOlUoaSxpLmxlbmd0aCl9ZnVuY3Rpb24gTCh0KXt2YXIgZT10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09ZSl7dmFyIG49ZVt0XTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXJldHVybiAxO2lmKHZvaWQgMCE9PW4pcmV0dXJuIG4ubGVuZ3RofXJldHVybiAwfWZ1bmN0aW9uIFUodCxlKXtmb3IodmFyIG49bmV3IEFycmF5KGUpLHI9MDtyPGU7KytyKW5bcl09dFtyXTtyZXR1cm4gbn1mdW5jdGlvbiBOKHQsZSxuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQub24pci5vbmNlP3Qub25jZShlLG4pOnQub24oZSxuKTtlbHNle2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuYWRkRXZlbnRMaXN0ZW5lcil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiB0KTt0LmFkZEV2ZW50TGlzdGVuZXIoZSwoZnVuY3Rpb24gaShvKXtyLm9uY2UmJnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGkpLG4obyl9KSl9fWZ1bmN0aW9uIGoodCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJvYmxpdGVyYXRvci9pdGVyYXRvcjogZXhwZWN0aW5nIGEgZnVuY3Rpb24hXCIpO3RoaXMubmV4dD10fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShrLFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBffSxzZXQ6ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHR8fHQ8MHx8bSh0KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrdCtcIi5cIik7Xz10fX0pLGsuaW5pdD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzIT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LGsucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdHx8dDwwfHxtKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyt0K1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30say5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHgodGhpcyl9LGsucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWUucHVzaChhcmd1bWVudHNbbl0pO3ZhciByPVwiZXJyb3JcIj09PXQsaT10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09aSlyPXImJnZvaWQgMD09PWkuZXJyb3I7ZWxzZSBpZighcilyZXR1cm4hMTtpZihyKXt2YXIgbztpZihlLmxlbmd0aD4wJiYobz1lWzBdKSxvIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgbzt2YXIgYT1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKG8/XCIgKFwiK28ubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgYS5jb250ZXh0PW8sYX12YXIgdT1pW3RdO2lmKHZvaWQgMD09PXUpcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdSliKHUsdGhpcyxlKTtlbHNle3ZhciBjPXUubGVuZ3RoLHM9VSh1LGMpO2ZvcihuPTA7bjxjOysrbiliKHNbbl0sdGhpcyxlKX1yZXR1cm4hMH0say5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gRSh0aGlzLHQsZSwhMSl9LGsucHJvdG90eXBlLm9uPWsucHJvdG90eXBlLmFkZExpc3RlbmVyLGsucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBFKHRoaXMsdCxlLCEwKX0say5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe3JldHVybiBHKGUpLHRoaXMub24odCxTKHRoaXMsdCxlKSksdGhpc30say5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBHKGUpLHRoaXMucHJlcGVuZExpc3RlbmVyKHQsUyh0aGlzLHQsZSkpLHRoaXN9LGsucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIG4scixpLG8sYTtpZihHKGUpLHZvaWQgMD09PShyPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09KG49clt0XSkpcmV0dXJuIHRoaXM7aWYobj09PWV8fG4ubGlzdGVuZXI9PT1lKTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSByW3RdLHIucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxuLmxpc3RlbmVyfHxlKSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXtmb3IoaT0tMSxvPW4ubGVuZ3RoLTE7bz49MDtvLS0paWYobltvXT09PWV8fG5bb10ubGlzdGVuZXI9PT1lKXthPW5bb10ubGlzdGVuZXIsaT1vO2JyZWFrfWlmKGk8MClyZXR1cm4gdGhpczswPT09aT9uLnNoaWZ0KCk6ZnVuY3Rpb24odCxlKXtmb3IoO2UrMTx0Lmxlbmd0aDtlKyspdFtlXT10W2UrMV07dC5wb3AoKX0obixpKSwxPT09bi5sZW5ndGgmJihyW3RdPW5bMF0pLHZvaWQgMCE9PXIucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxhfHxlKX1yZXR1cm4gdGhpc30say5wcm90b3R5cGUub2ZmPWsucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLGsucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZSxuLHI7aWYodm9pZCAwPT09KG49dGhpcy5fZXZlbnRzKSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1uLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09blt0XSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIG5bdF0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpLG89T2JqZWN0LmtleXMobik7Zm9yKHI9MDtyPG8ubGVuZ3RoOysrcilcInJlbW92ZUxpc3RlbmVyXCIhPT0oaT1vW3JdKSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoaSk7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9blt0XSkpdGhpcy5yZW1vdmVMaXN0ZW5lcih0LGUpO2Vsc2UgaWYodm9pZCAwIT09ZSlmb3Iocj1lLmxlbmd0aC0xO3I+PTA7ci0tKXRoaXMucmVtb3ZlTGlzdGVuZXIodCxlW3JdKTtyZXR1cm4gdGhpc30say5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBEKHRoaXMsdCwhMCl9LGsucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gRCh0aGlzLHQsITEpfSxrLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lmxpc3RlbmVyQ291bnQ/dC5saXN0ZW5lckNvdW50KGUpOkwuY2FsbCh0LGUpfSxrLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PUwsay5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP3kodGhpcy5fZXZlbnRzKTpbXX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmKGoucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGoub2Y9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMsZT10Lmxlbmd0aCxuPTA7cmV0dXJuIG5ldyBqKChmdW5jdGlvbigpe3JldHVybiBuPj1lP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W24rK119fSkpfSxqLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBqKChmdW5jdGlvbigpe3JldHVybntkb25lOiEwfX0pKX0sai5mcm9tU2VxdWVuY2U9ZnVuY3Rpb24odCl7dmFyIGU9MCxuPXQubGVuZ3RoO3JldHVybiBuZXcgaigoZnVuY3Rpb24oKXtyZXR1cm4gZT49bj97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtlKytdfX0pKX0sai5pcz1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGp8fFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5uZXh0fTt2YXIgTz1qLEM9e307Qy5BUlJBWV9CVUZGRVJfU1VQUE9SVD1cInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXIsQy5TWU1CT0xfU1VQUE9SVD1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sO3ZhciB6PU8sTT1DLFc9TS5BUlJBWV9CVUZGRVJfU1VQUE9SVCxQPU0uU1lNQk9MX1NVUFBPUlQ7dmFyIFI9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fEFycmF5LmlzQXJyYXkodCl8fFcmJkFycmF5QnVmZmVyLmlzVmlldyh0KT96LmZyb21TZXF1ZW5jZSh0KTpcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/bnVsbDpQJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W1N5bWJvbC5pdGVyYXRvcl0/dFtTeW1ib2wuaXRlcmF0b3JdKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdC5uZXh0P3Q6bnVsbH0odCk7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwib2JsaXRlcmF0b3I6IHRhcmdldCBpcyBub3QgaXRlcmFibGUgbm9yIGEgdmFsaWQgaXRlcmF0b3IuXCIpO3JldHVybiBlfSxLPVIsVD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbixyPWFyZ3VtZW50cy5sZW5ndGg+MT9lOjEvMCxpPXIhPT0xLzA/bmV3IEFycmF5KHIpOltdLG89MCxhPUsodCk7Oyl7aWYobz09PXIpcmV0dXJuIGk7aWYoKG49YS5uZXh0KCkpLmRvbmUpcmV0dXJuIG8hPT1lJiYoaS5sZW5ndGg9byksaTtpW28rK109bi52YWx1ZX19LEI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlKXt2YXIgbjtyZXR1cm4obj10LmNhbGwodGhpcyl8fHRoaXMpLm5hbWU9XCJHcmFwaEVycm9yXCIsbi5tZXNzYWdlPWUsbn1yZXR1cm4gZShuLHQpLG59KGEoRXJyb3IpKSxGPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7dmFyIHI7cmV0dXJuKHI9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLm5hbWU9XCJJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvclwiLFwiZnVuY3Rpb25cIj09dHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh1KHIpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSxyfXJldHVybiBlKG4sdCksbn0oQiksST1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUpe3ZhciByO3JldHVybihyPXQuY2FsbCh0aGlzLGUpfHx0aGlzKS5uYW1lPVwiTm90Rm91bmRHcmFwaEVycm9yXCIsXCJmdW5jdGlvblwiPT10eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHUociksbi5wcm90b3R5cGUuY29uc3RydWN0b3IpLHJ9cmV0dXJuIGUobix0KSxufShCKSxZPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7dmFyIHI7cmV0dXJuKHI9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLm5hbWU9XCJVc2FnZUdyYXBoRXJyb3JcIixcImZ1bmN0aW9uXCI9PXR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodShyKSxuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikscn1yZXR1cm4gZShuLHQpLG59KEIpO2Z1bmN0aW9uIHEodCxlKXt0aGlzLmtleT10LHRoaXMuYXR0cmlidXRlcz1lLHRoaXMuY2xlYXIoKX1mdW5jdGlvbiBKKHQsZSl7dGhpcy5rZXk9dCx0aGlzLmF0dHJpYnV0ZXM9ZSx0aGlzLmNsZWFyKCl9ZnVuY3Rpb24gVih0LGUpe3RoaXMua2V5PXQsdGhpcy5hdHRyaWJ1dGVzPWUsdGhpcy5jbGVhcigpfWZ1bmN0aW9uIEgodCxlLG4scixpKXt0aGlzLmtleT1lLHRoaXMuYXR0cmlidXRlcz1pLHRoaXMudW5kaXJlY3RlZD10LHRoaXMuc291cmNlPW4sdGhpcy50YXJnZXQ9cn1xLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuaW5EZWdyZWU9MCx0aGlzLm91dERlZ3JlZT0wLHRoaXMudW5kaXJlY3RlZERlZ3JlZT0wLHRoaXMuaW49e30sdGhpcy5vdXQ9e30sdGhpcy51bmRpcmVjdGVkPXt9fSxKLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuaW5EZWdyZWU9MCx0aGlzLm91dERlZ3JlZT0wLHRoaXMuaW49e30sdGhpcy5vdXQ9e319LFYucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy51bmRpcmVjdGVkRGVncmVlPTAsdGhpcy51bmRpcmVjdGVkPXt9fSxILnByb3RvdHlwZS5hdHRhY2g9ZnVuY3Rpb24oKXt2YXIgdD1cIm91dFwiLGU9XCJpblwiO3RoaXMudW5kaXJlY3RlZCYmKHQ9ZT1cInVuZGlyZWN0ZWRcIik7dmFyIG49dGhpcy5zb3VyY2Uua2V5LHI9dGhpcy50YXJnZXQua2V5O3RoaXMuc291cmNlW3RdW3JdPXRoaXMsdGhpcy51bmRpcmVjdGVkJiZuPT09cnx8KHRoaXMudGFyZ2V0W2VdW25dPXRoaXMpfSxILnByb3RvdHlwZS5hdHRhY2hNdWx0aT1mdW5jdGlvbigpe3ZhciB0PVwib3V0XCIsZT1cImluXCIsbj10aGlzLnNvdXJjZS5rZXkscj10aGlzLnRhcmdldC5rZXk7dGhpcy51bmRpcmVjdGVkJiYodD1lPVwidW5kaXJlY3RlZFwiKTt2YXIgaT10aGlzLnNvdXJjZVt0XSxvPWlbcl07aWYodm9pZCAwPT09bylyZXR1cm4gaVtyXT10aGlzLHZvaWQodGhpcy51bmRpcmVjdGVkJiZuPT09cnx8KHRoaXMudGFyZ2V0W2VdW25dPXRoaXMpKTtvLnByZXZpb3VzPXRoaXMsdGhpcy5uZXh0PW8saVtyXT10aGlzLHRoaXMudGFyZ2V0W2VdW25dPXRoaXN9LEgucHJvdG90eXBlLmRldGFjaD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuc291cmNlLmtleSxlPXRoaXMudGFyZ2V0LmtleSxuPVwib3V0XCIscj1cImluXCI7dGhpcy51bmRpcmVjdGVkJiYobj1yPVwidW5kaXJlY3RlZFwiKSxkZWxldGUgdGhpcy5zb3VyY2Vbbl1bZV0sZGVsZXRlIHRoaXMudGFyZ2V0W3JdW3RdfSxILnByb3RvdHlwZS5kZXRhY2hNdWx0aT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuc291cmNlLmtleSxlPXRoaXMudGFyZ2V0LmtleSxuPVwib3V0XCIscj1cImluXCI7dGhpcy51bmRpcmVjdGVkJiYobj1yPVwidW5kaXJlY3RlZFwiKSx2b2lkIDA9PT10aGlzLnByZXZpb3VzP3ZvaWQgMD09PXRoaXMubmV4dD8oZGVsZXRlIHRoaXMuc291cmNlW25dW2VdLGRlbGV0ZSB0aGlzLnRhcmdldFtyXVt0XSk6KHRoaXMubmV4dC5wcmV2aW91cz12b2lkIDAsdGhpcy5zb3VyY2Vbbl1bZV09dGhpcy5uZXh0LHRoaXMudGFyZ2V0W3JdW3RdPXRoaXMubmV4dCk6KHRoaXMucHJldmlvdXMubmV4dD10aGlzLm5leHQsdm9pZCAwIT09dGhpcy5uZXh0JiYodGhpcy5uZXh0LnByZXZpb3VzPXRoaXMucHJldmlvdXMpKX07ZnVuY3Rpb24gUSh0LGUsbixyLGksbyxhKXt2YXIgdSxjLHMsZDtpZihyPVwiXCIrciwwPT09bil7aWYoISh1PXQuX25vZGVzLmdldChyKSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQociwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3M9aSxkPW99ZWxzZSBpZigzPT09bil7aWYoaT1cIlwiK2ksIShjPXQuX2VkZ2VzLmdldChpKSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQoaSwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpO3ZhciBoPWMuc291cmNlLmtleSxwPWMudGFyZ2V0LmtleTtpZihyPT09aCl1PWMudGFyZ2V0O2Vsc2V7aWYociE9PXApdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiB0aGUgXCInKS5jb25jYXQociwnXCIgbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIFwiJykuY29uY2F0KGksJ1wiIGVkZ2UgKCcpLmNvbmNhdChoLFwiLCBcIikuY29uY2F0KHAsXCIpLlwiKSk7dT1jLnNvdXJjZX1zPW8sZD1hfWVsc2V7aWYoIShjPXQuX2VkZ2VzLmdldChyKSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQociwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpO3U9MT09PW4/Yy5zb3VyY2U6Yy50YXJnZXQscz1pLGQ9b31yZXR1cm5bdSxzLGRdfXZhciBYPVt7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cImdldFwiLmNvbmNhdCh0LFwiQXR0cmlidXRlXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCxyLGkpe3ZhciBvPVEodGhpcyxlLG4sdCxyLGkpLGE9b1swXSx1PW9bMV07cmV0dXJuIGEuYXR0cmlidXRlc1t1XX19fSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cImdldFwiLmNvbmNhdCh0LFwiQXR0cmlidXRlc1wiKX0sYXR0YWNoZXI6ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscil7cmV0dXJuIFEodGhpcyxlLG4sdCxyKVswXS5hdHRyaWJ1dGVzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwiaGFzXCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSl7dmFyIG89USh0aGlzLGUsbix0LHIsaSksYT1vWzBdLHU9b1sxXTtyZXR1cm4gYS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHUpfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwic2V0XCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSxvKXt2YXIgYT1RKHRoaXMsZSxuLHQscixpLG8pLHU9YVswXSxjPWFbMV0scz1hWzJdO3JldHVybiB1LmF0dHJpYnV0ZXNbY109cyx0aGlzLmVtaXQoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5OnUua2V5LHR5cGU6XCJzZXRcIixhdHRyaWJ1dGVzOnUuYXR0cmlidXRlcyxuYW1lOmN9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwidXBkYXRlXCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSxvKXt2YXIgYT1RKHRoaXMsZSxuLHQscixpLG8pLHU9YVswXSxjPWFbMV0scz1hWzJdO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHMpdGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIikpO3ZhciBkPXUuYXR0cmlidXRlcyxoPXMoZFtjXSk7cmV0dXJuIGRbY109aCx0aGlzLmVtaXQoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5OnUua2V5LHR5cGU6XCJzZXRcIixhdHRyaWJ1dGVzOnUuYXR0cmlidXRlcyxuYW1lOmN9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwicmVtb3ZlXCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSl7dmFyIG89USh0aGlzLGUsbix0LHIsaSksYT1vWzBdLHU9b1sxXTtyZXR1cm4gZGVsZXRlIGEuYXR0cmlidXRlc1t1XSx0aGlzLmVtaXQoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5OmEua2V5LHR5cGU6XCJyZW1vdmVcIixhdHRyaWJ1dGVzOmEuYXR0cmlidXRlcyxuYW1lOnV9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwicmVwbGFjZVwiLmNvbmNhdCh0LFwiQXR0cmlidXRlc1wiKX0sYXR0YWNoZXI6ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscixpKXt2YXIgbz1RKHRoaXMsZSxuLHQscixpKSxhPW9bMF0sdT1vWzFdO2lmKCFoKHUpKXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5cIikpO3JldHVybiBhLmF0dHJpYnV0ZXM9dSx0aGlzLmVtaXQoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5OmEua2V5LHR5cGU6XCJyZXBsYWNlXCIsYXR0cmlidXRlczphLmF0dHJpYnV0ZXN9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwibWVyZ2VcIi5jb25jYXQodCxcIkF0dHJpYnV0ZXNcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSl7dmFyIG89USh0aGlzLGUsbix0LHIsaSksYT1vWzBdLHU9b1sxXTtpZighaCh1KSl0aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXCIpKTtyZXR1cm4gYyhhLmF0dHJpYnV0ZXMsdSksdGhpcy5lbWl0KFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIse2tleTphLmtleSx0eXBlOlwibWVyZ2VcIixhdHRyaWJ1dGVzOmEuYXR0cmlidXRlcyxkYXRhOnV9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwidXBkYXRlXCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVzXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCxyLGkpe3ZhciBvPVEodGhpcyxlLG4sdCxyLGkpLGE9b1swXSx1PW9bMV07aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdSl0aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBwcm92aWRlZCB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKSk7cmV0dXJuIGEuYXR0cmlidXRlcz11KGEuYXR0cmlidXRlcyksdGhpcy5lbWl0KFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIse2tleTphLmtleSx0eXBlOlwidXBkYXRlXCIsYXR0cmlidXRlczphLmF0dHJpYnV0ZXN9KSx0aGlzfX19XTt2YXIgWj1be25hbWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJnZXRcIi5jb25jYXQodCxcIkF0dHJpYnV0ZVwiKX0sYXR0YWNoZXI6ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscil7dmFyIGk7aWYoXCJtaXhlZFwiIT09dGhpcy50eXBlJiZcIm1peGVkXCIhPT1uJiZuIT09dGhpcy50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyIFwiKS5jb25jYXQodGhpcy50eXBlLFwiIGdyYXBoLlwiKSk7aWYoYXJndW1lbnRzLmxlbmd0aD4yKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LlwiKSk7dmFyIG89XCJcIit0LGE9XCJcIityO2lmKHI9YXJndW1lbnRzWzJdLCEoaT1zKHRoaXMsbyxhLG4pKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIicpLmNvbmNhdChvLCdcIiAtIFwiJykuY29uY2F0KGEsJ1wiKS4nKSl9ZWxzZXtpZihcIm1peGVkXCIhPT1uKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5cIikpO2lmKHQ9XCJcIit0LCEoaT10aGlzLl9lZGdlcy5nZXQodCkpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIGVkZ2UgaW4gdGhlIGdyYXBoLicpKX1yZXR1cm4gaS5hdHRyaWJ1dGVzW3JdfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwiZ2V0XCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVzXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCl7dmFyIHI7aWYoXCJtaXhlZFwiIT09dGhpcy50eXBlJiZcIm1peGVkXCIhPT1uJiZuIT09dGhpcy50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyIFwiKS5jb25jYXQodGhpcy50eXBlLFwiIGdyYXBoLlwiKSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LlwiKSk7dmFyIGk9XCJcIit0LG89XCJcIithcmd1bWVudHNbMV07aWYoIShyPXModGhpcyxpLG8sbikpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJykuY29uY2F0KGksJ1wiIC0gXCInKS5jb25jYXQobywnXCIpLicpKX1lbHNle2lmKFwibWl4ZWRcIiE9PW4pdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLlwiKSk7aWYodD1cIlwiK3QsIShyPXRoaXMuX2VkZ2VzLmdldCh0KSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpfXJldHVybiByLmF0dHJpYnV0ZXN9fX0se25hbWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJoYXNcIi5jb25jYXQodCxcIkF0dHJpYnV0ZVwiKX0sYXR0YWNoZXI6ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscil7dmFyIGk7aWYoXCJtaXhlZFwiIT09dGhpcy50eXBlJiZcIm1peGVkXCIhPT1uJiZuIT09dGhpcy50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyIFwiKS5jb25jYXQodGhpcy50eXBlLFwiIGdyYXBoLlwiKSk7aWYoYXJndW1lbnRzLmxlbmd0aD4yKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LlwiKSk7dmFyIG89XCJcIit0LGE9XCJcIityO2lmKHI9YXJndW1lbnRzWzJdLCEoaT1zKHRoaXMsbyxhLG4pKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIicpLmNvbmNhdChvLCdcIiAtIFwiJykuY29uY2F0KGEsJ1wiKS4nKSl9ZWxzZXtpZihcIm1peGVkXCIhPT1uKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5cIikpO2lmKHQ9XCJcIit0LCEoaT10aGlzLl9lZGdlcy5nZXQodCkpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIGVkZ2UgaW4gdGhlIGdyYXBoLicpKX1yZXR1cm4gaS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHIpfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwic2V0XCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIsaSl7dmFyIG87aWYoXCJtaXhlZFwiIT09dGhpcy50eXBlJiZcIm1peGVkXCIhPT1uJiZuIT09dGhpcy50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyIFwiKS5jb25jYXQodGhpcy50eXBlLFwiIGdyYXBoLlwiKSk7aWYoYXJndW1lbnRzLmxlbmd0aD4zKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LlwiKSk7dmFyIGE9XCJcIit0LHU9XCJcIityO2lmKHI9YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdLCEobz1zKHRoaXMsYSx1LG4pKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIicpLmNvbmNhdChhLCdcIiAtIFwiJykuY29uY2F0KHUsJ1wiKS4nKSl9ZWxzZXtpZihcIm1peGVkXCIhPT1uKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5cIikpO2lmKHQ9XCJcIit0LCEobz10aGlzLl9lZGdlcy5nZXQodCkpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIGVkZ2UgaW4gdGhlIGdyYXBoLicpKX1yZXR1cm4gby5hdHRyaWJ1dGVzW3JdPWksdGhpcy5lbWl0KFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIse2tleTpvLmtleSx0eXBlOlwic2V0XCIsYXR0cmlidXRlczpvLmF0dHJpYnV0ZXMsbmFtZTpyfSksdGhpc319fSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cInVwZGF0ZVwiLmNvbmNhdCh0LFwiQXR0cmlidXRlXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCxyLGkpe3ZhciBvO2lmKFwibWl4ZWRcIiE9PXRoaXMudHlwZSYmXCJtaXhlZFwiIT09biYmbiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciBcIikuY29uY2F0KHRoaXMudHlwZSxcIiBncmFwaC5cIikpO2lmKGFyZ3VtZW50cy5sZW5ndGg+Myl7aWYodGhpcy5tdWx0aSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5cIikpO3ZhciBhPVwiXCIrdCx1PVwiXCIrcjtpZihyPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXSwhKG89cyh0aGlzLGEsdSxuKSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCInKS5jb25jYXQoYSwnXCIgLSBcIicpLmNvbmNhdCh1LCdcIikuJykpfWVsc2V7aWYoXCJtaXhlZFwiIT09bil0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuXCIpKTtpZih0PVwiXCIrdCwhKG89dGhpcy5fZWRnZXMuZ2V0KHQpKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSl9aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSl0aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiB1cGRhdGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKSk7cmV0dXJuIG8uYXR0cmlidXRlc1tyXT1pKG8uYXR0cmlidXRlc1tyXSksdGhpcy5lbWl0KFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIse2tleTpvLmtleSx0eXBlOlwic2V0XCIsYXR0cmlidXRlczpvLmF0dHJpYnV0ZXMsbmFtZTpyfSksdGhpc319fSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cInJlbW92ZVwiLmNvbmNhdCh0LFwiQXR0cmlidXRlXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCxyKXt2YXIgaTtpZihcIm1peGVkXCIhPT10aGlzLnR5cGUmJlwibWl4ZWRcIiE9PW4mJm4hPT10aGlzLnR5cGUpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgXCIpLmNvbmNhdCh0aGlzLnR5cGUsXCIgZ3JhcGguXCIpKTtpZihhcmd1bWVudHMubGVuZ3RoPjIpe2lmKHRoaXMubXVsdGkpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuXCIpKTt2YXIgbz1cIlwiK3QsYT1cIlwiK3I7aWYocj1hcmd1bWVudHNbMl0sIShpPXModGhpcyxvLGEsbikpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJykuY29uY2F0KG8sJ1wiIC0gXCInKS5jb25jYXQoYSwnXCIpLicpKX1lbHNle2lmKFwibWl4ZWRcIiE9PW4pdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLlwiKSk7aWYodD1cIlwiK3QsIShpPXRoaXMuX2VkZ2VzLmdldCh0KSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpfXJldHVybiBkZWxldGUgaS5hdHRyaWJ1dGVzW3JdLHRoaXMuZW1pdChcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLHtrZXk6aS5rZXksdHlwZTpcInJlbW92ZVwiLGF0dHJpYnV0ZXM6aS5hdHRyaWJ1dGVzLG5hbWU6cn0pLHRoaXN9fX0se25hbWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJyZXBsYWNlXCIuY29uY2F0KHQsXCJBdHRyaWJ1dGVzXCIpfSxhdHRhY2hlcjpmdW5jdGlvbih0LGUsbil7dC5wcm90b3R5cGVbZV09ZnVuY3Rpb24odCxyKXt2YXIgaTtpZihcIm1peGVkXCIhPT10aGlzLnR5cGUmJlwibWl4ZWRcIiE9PW4mJm4hPT10aGlzLnR5cGUpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgXCIpLmNvbmNhdCh0aGlzLnR5cGUsXCIgZ3JhcGguXCIpKTtpZihhcmd1bWVudHMubGVuZ3RoPjIpe2lmKHRoaXMubXVsdGkpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuXCIpKTt2YXIgbz1cIlwiK3QsYT1cIlwiK3I7aWYocj1hcmd1bWVudHNbMl0sIShpPXModGhpcyxvLGEsbikpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJykuY29uY2F0KG8sJ1wiIC0gXCInKS5jb25jYXQoYSwnXCIpLicpKX1lbHNle2lmKFwibWl4ZWRcIiE9PW4pdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLlwiKSk7aWYodD1cIlwiK3QsIShpPXRoaXMuX2VkZ2VzLmdldCh0KSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpfWlmKCFoKHIpKXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5cIikpO3JldHVybiBpLmF0dHJpYnV0ZXM9cix0aGlzLmVtaXQoXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5Omkua2V5LHR5cGU6XCJyZXBsYWNlXCIsYXR0cmlidXRlczppLmF0dHJpYnV0ZXN9KSx0aGlzfX19LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwibWVyZ2VcIi5jb25jYXQodCxcIkF0dHJpYnV0ZXNcIil9LGF0dGFjaGVyOmZ1bmN0aW9uKHQsZSxuKXt0LnByb3RvdHlwZVtlXT1mdW5jdGlvbih0LHIpe3ZhciBpO2lmKFwibWl4ZWRcIiE9PXRoaXMudHlwZSYmXCJtaXhlZFwiIT09biYmbiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciBcIikuY29uY2F0KHRoaXMudHlwZSxcIiBncmFwaC5cIikpO2lmKGFyZ3VtZW50cy5sZW5ndGg+Mil7aWYodGhpcy5tdWx0aSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5cIikpO3ZhciBvPVwiXCIrdCxhPVwiXCIrcjtpZihyPWFyZ3VtZW50c1syXSwhKGk9cyh0aGlzLG8sYSxuKSkpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCInKS5jb25jYXQobywnXCIgLSBcIicpLmNvbmNhdChhLCdcIikuJykpfWVsc2V7aWYoXCJtaXhlZFwiIT09bil0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuXCIpKTtpZih0PVwiXCIrdCwhKGk9dGhpcy5fZWRnZXMuZ2V0KHQpKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSl9aWYoIWgocikpdGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LlwiKSk7cmV0dXJuIGMoaS5hdHRyaWJ1dGVzLHIpLHRoaXMuZW1pdChcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLHtrZXk6aS5rZXksdHlwZTpcIm1lcmdlXCIsYXR0cmlidXRlczppLmF0dHJpYnV0ZXMsZGF0YTpyfSksdGhpc319fSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cInVwZGF0ZVwiLmNvbmNhdCh0LFwiQXR0cmlidXRlc1wiKX0sYXR0YWNoZXI6ZnVuY3Rpb24odCxlLG4pe3QucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscil7dmFyIGk7aWYoXCJtaXhlZFwiIT09dGhpcy50eXBlJiZcIm1peGVkXCIhPT1uJiZuIT09dGhpcy50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyIFwiKS5jb25jYXQodGhpcy50eXBlLFwiIGdyYXBoLlwiKSk7aWYoYXJndW1lbnRzLmxlbmd0aD4yKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LlwiKSk7dmFyIG89XCJcIit0LGE9XCJcIityO2lmKHI9YXJndW1lbnRzWzJdLCEoaT1zKHRoaXMsbyxhLG4pKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIicpLmNvbmNhdChvLCdcIiAtIFwiJykuY29uY2F0KGEsJ1wiKS4nKSl9ZWxzZXtpZihcIm1peGVkXCIhPT1uKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5cIikpO2lmKHQ9XCJcIit0LCEoaT10aGlzLl9lZGdlcy5nZXQodCkpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KGUsJzogY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIGVkZ2UgaW4gdGhlIGdyYXBoLicpKX1pZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IHByb3ZpZGVkIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uXCIpKTtyZXR1cm4gaS5hdHRyaWJ1dGVzPXIoaS5hdHRyaWJ1dGVzKSx0aGlzLmVtaXQoXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIix7a2V5Omkua2V5LHR5cGU6XCJ1cGRhdGVcIixhdHRyaWJ1dGVzOmkuYXR0cmlidXRlc30pLHRoaXN9fX1dO3ZhciAkPU8sdHQ9UixldD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cyxlPW51bGwsbj0tMTtyZXR1cm4gbmV3ICQoKGZ1bmN0aW9uKCl7Zm9yKHZhciByPW51bGw7Oyl7aWYobnVsbD09PWUpe2lmKCsrbj49dC5sZW5ndGgpcmV0dXJue2RvbmU6ITB9O2U9dHQodFtuXSl9aWYoITAhPT0ocj1lLm5leHQoKSkuZG9uZSlicmVhaztlPW51bGx9cmV0dXJuIHJ9KSl9LG50PVt7bmFtZTpcImVkZ2VzXCIsdHlwZTpcIm1peGVkXCJ9LHtuYW1lOlwiaW5FZGdlc1wiLHR5cGU6XCJkaXJlY3RlZFwiLGRpcmVjdGlvbjpcImluXCJ9LHtuYW1lOlwib3V0RWRnZXNcIix0eXBlOlwiZGlyZWN0ZWRcIixkaXJlY3Rpb246XCJvdXRcIn0se25hbWU6XCJpbmJvdW5kRWRnZXNcIix0eXBlOlwibWl4ZWRcIixkaXJlY3Rpb246XCJpblwifSx7bmFtZTpcIm91dGJvdW5kRWRnZXNcIix0eXBlOlwibWl4ZWRcIixkaXJlY3Rpb246XCJvdXRcIn0se25hbWU6XCJkaXJlY3RlZEVkZ2VzXCIsdHlwZTpcImRpcmVjdGVkXCJ9LHtuYW1lOlwidW5kaXJlY3RlZEVkZ2VzXCIsdHlwZTpcInVuZGlyZWN0ZWRcIn1dO2Z1bmN0aW9uIHJ0KHQsZSxuLHIpe3ZhciBpPSExO2Zvcih2YXIgbyBpbiBlKWlmKG8hPT1yKXt2YXIgYT1lW29dO2lmKGk9bihhLmtleSxhLmF0dHJpYnV0ZXMsYS5zb3VyY2Uua2V5LGEudGFyZ2V0LmtleSxhLnNvdXJjZS5hdHRyaWJ1dGVzLGEudGFyZ2V0LmF0dHJpYnV0ZXMsYS51bmRpcmVjdGVkKSx0JiZpKXJldHVybiBhLmtleX19ZnVuY3Rpb24gaXQodCxlLG4scil7dmFyIGksbyxhLHU9ITE7Zm9yKHZhciBjIGluIGUpaWYoYyE9PXIpe2k9ZVtjXTtkb3tpZihvPWkuc291cmNlLGE9aS50YXJnZXQsdT1uKGkua2V5LGkuYXR0cmlidXRlcyxvLmtleSxhLmtleSxvLmF0dHJpYnV0ZXMsYS5hdHRyaWJ1dGVzLGkudW5kaXJlY3RlZCksdCYmdSlyZXR1cm4gaS5rZXk7aT1pLm5leHR9d2hpbGUodm9pZCAwIT09aSl9fWZ1bmN0aW9uIG90KHQsZSl7dmFyIG4scj1PYmplY3Qua2V5cyh0KSxpPXIubGVuZ3RoLG89MDtyZXR1cm4gbmV3IE8oKGZ1bmN0aW9uKCl7ZG97aWYobiluPW4ubmV4dDtlbHNle2lmKG8+PWkpcmV0dXJue2RvbmU6ITB9O3ZhciBhPXJbbysrXTtpZihhPT09ZSl7bj12b2lkIDA7Y29udGludWV9bj10W2FdfX13aGlsZSghbik7cmV0dXJue2RvbmU6ITEsdmFsdWU6e2VkZ2U6bi5rZXksYXR0cmlidXRlczpuLmF0dHJpYnV0ZXMsc291cmNlOm4uc291cmNlLmtleSx0YXJnZXQ6bi50YXJnZXQua2V5LHNvdXJjZUF0dHJpYnV0ZXM6bi5zb3VyY2UuYXR0cmlidXRlcyx0YXJnZXRBdHRyaWJ1dGVzOm4udGFyZ2V0LmF0dHJpYnV0ZXMsdW5kaXJlY3RlZDpuLnVuZGlyZWN0ZWR9fX0pKX1mdW5jdGlvbiBhdCh0LGUsbixyKXt2YXIgaT1lW25dO2lmKGkpe3ZhciBvPWkuc291cmNlLGE9aS50YXJnZXQ7cmV0dXJuIHIoaS5rZXksaS5hdHRyaWJ1dGVzLG8ua2V5LGEua2V5LG8uYXR0cmlidXRlcyxhLmF0dHJpYnV0ZXMsaS51bmRpcmVjdGVkKSYmdD9pLmtleTp2b2lkIDB9fWZ1bmN0aW9uIHV0KHQsZSxuLHIpe3ZhciBpPWVbbl07aWYoaSl7dmFyIG89ITE7ZG97aWYobz1yKGkua2V5LGkuYXR0cmlidXRlcyxpLnNvdXJjZS5rZXksaS50YXJnZXQua2V5LGkuc291cmNlLmF0dHJpYnV0ZXMsaS50YXJnZXQuYXR0cmlidXRlcyxpLnVuZGlyZWN0ZWQpLHQmJm8pcmV0dXJuIGkua2V5O2k9aS5uZXh0fXdoaWxlKHZvaWQgMCE9PWkpfX1mdW5jdGlvbiBjdCh0LGUpe3ZhciBuPXRbZV07cmV0dXJuIHZvaWQgMCE9PW4ubmV4dD9uZXcgTygoZnVuY3Rpb24oKXtpZighbilyZXR1cm57ZG9uZTohMH07dmFyIHQ9e2VkZ2U6bi5rZXksYXR0cmlidXRlczpuLmF0dHJpYnV0ZXMsc291cmNlOm4uc291cmNlLmtleSx0YXJnZXQ6bi50YXJnZXQua2V5LHNvdXJjZUF0dHJpYnV0ZXM6bi5zb3VyY2UuYXR0cmlidXRlcyx0YXJnZXRBdHRyaWJ1dGVzOm4udGFyZ2V0LmF0dHJpYnV0ZXMsdW5kaXJlY3RlZDpuLnVuZGlyZWN0ZWR9O3JldHVybiBuPW4ubmV4dCx7ZG9uZTohMSx2YWx1ZTp0fX0pKTpPLm9mKHtlZGdlOm4ua2V5LGF0dHJpYnV0ZXM6bi5hdHRyaWJ1dGVzLHNvdXJjZTpuLnNvdXJjZS5rZXksdGFyZ2V0Om4udGFyZ2V0LmtleSxzb3VyY2VBdHRyaWJ1dGVzOm4uc291cmNlLmF0dHJpYnV0ZXMsdGFyZ2V0QXR0cmlidXRlczpuLnRhcmdldC5hdHRyaWJ1dGVzLHVuZGlyZWN0ZWQ6bi51bmRpcmVjdGVkfSl9ZnVuY3Rpb24gc3QodCxlKXtpZigwPT09dC5zaXplKXJldHVybltdO2lmKFwibWl4ZWRcIj09PWV8fGU9PT10LnR5cGUpcmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkuZnJvbT9BcnJheS5mcm9tKHQuX2VkZ2VzLmtleXMoKSk6VCh0Ll9lZGdlcy5rZXlzKCksdC5fZWRnZXMuc2l6ZSk7Zm9yKHZhciBuLHIsaT1cInVuZGlyZWN0ZWRcIj09PWU/dC51bmRpcmVjdGVkU2l6ZTp0LmRpcmVjdGVkU2l6ZSxvPW5ldyBBcnJheShpKSxhPVwidW5kaXJlY3RlZFwiPT09ZSx1PXQuX2VkZ2VzLnZhbHVlcygpLGM9MDshMCE9PShuPXUubmV4dCgpKS5kb25lOykocj1uLnZhbHVlKS51bmRpcmVjdGVkPT09YSYmKG9bYysrXT1yLmtleSk7cmV0dXJuIG99ZnVuY3Rpb24gZHQodCxlLG4scil7aWYoMCE9PWUuc2l6ZSlmb3IodmFyIGksbyxhPVwibWl4ZWRcIiE9PW4mJm4hPT1lLnR5cGUsdT1cInVuZGlyZWN0ZWRcIj09PW4sYz0hMSxzPWUuX2VkZ2VzLnZhbHVlcygpOyEwIT09KGk9cy5uZXh0KCkpLmRvbmU7KWlmKG89aS52YWx1ZSwhYXx8by51bmRpcmVjdGVkPT09dSl7dmFyIGQ9byxoPWQua2V5LHA9ZC5hdHRyaWJ1dGVzLGY9ZC5zb3VyY2UsbD1kLnRhcmdldDtpZihjPXIoaCxwLGYua2V5LGwua2V5LGYuYXR0cmlidXRlcyxsLmF0dHJpYnV0ZXMsby51bmRpcmVjdGVkKSx0JiZjKXJldHVybiBofX1mdW5jdGlvbiBodCh0LGUpe2lmKDA9PT10LnNpemUpcmV0dXJuIE8uZW1wdHkoKTt2YXIgbj1cIm1peGVkXCIhPT1lJiZlIT09dC50eXBlLHI9XCJ1bmRpcmVjdGVkXCI9PT1lLGk9dC5fZWRnZXMudmFsdWVzKCk7cmV0dXJuIG5ldyBPKChmdW5jdGlvbigpe2Zvcih2YXIgdCxlOzspe2lmKCh0PWkubmV4dCgpKS5kb25lKXJldHVybiB0O2lmKGU9dC52YWx1ZSwhbnx8ZS51bmRpcmVjdGVkPT09cilicmVha31yZXR1cm57dmFsdWU6e2VkZ2U6ZS5rZXksYXR0cmlidXRlczplLmF0dHJpYnV0ZXMsc291cmNlOmUuc291cmNlLmtleSx0YXJnZXQ6ZS50YXJnZXQua2V5LHNvdXJjZUF0dHJpYnV0ZXM6ZS5zb3VyY2UuYXR0cmlidXRlcyx0YXJnZXRBdHRyaWJ1dGVzOmUudGFyZ2V0LmF0dHJpYnV0ZXMsdW5kaXJlY3RlZDplLnVuZGlyZWN0ZWR9LGRvbmU6ITF9fSkpfWZ1bmN0aW9uIHB0KHQsZSxuLHIsaSxvKXt2YXIgYSx1PWU/aXQ6cnQ7aWYoXCJ1bmRpcmVjdGVkXCIhPT1uKXtpZihcIm91dFwiIT09ciYmKGE9dSh0LGkuaW4sbyksdCYmYSkpcmV0dXJuIGE7aWYoXCJpblwiIT09ciYmKGE9dSh0LGkub3V0LG8scj92b2lkIDA6aS5rZXkpLHQmJmEpKXJldHVybiBhfWlmKFwiZGlyZWN0ZWRcIiE9PW4mJihhPXUodCxpLnVuZGlyZWN0ZWQsbyksdCYmYSkpcmV0dXJuIGF9ZnVuY3Rpb24gZnQodCxlLG4scil7dmFyIGk9W107cmV0dXJuIHB0KCExLHQsZSxuLHIsKGZ1bmN0aW9uKHQpe2kucHVzaCh0KX0pKSxpfWZ1bmN0aW9uIGx0KHQsZSxuKXt2YXIgcj1PLmVtcHR5KCk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10JiYoXCJvdXRcIiE9PWUmJnZvaWQgMCE9PW4uaW4mJihyPWV0KHIsb3Qobi5pbikpKSxcImluXCIhPT1lJiZ2b2lkIDAhPT1uLm91dCYmKHI9ZXQocixvdChuLm91dCxlP3ZvaWQgMDpuLmtleSkpKSksXCJkaXJlY3RlZFwiIT09dCYmdm9pZCAwIT09bi51bmRpcmVjdGVkJiYocj1ldChyLG90KG4udW5kaXJlY3RlZCkpKSxyfWZ1bmN0aW9uIGd0KHQsZSxuLHIsaSxvLGEpe3ZhciB1LGM9bj91dDphdDtpZihcInVuZGlyZWN0ZWRcIiE9PWUpe2lmKHZvaWQgMCE9PWkuaW4mJlwib3V0XCIhPT1yJiYodT1jKHQsaS5pbixvLGEpLHQmJnUpKXJldHVybiB1O2lmKHZvaWQgMCE9PWkub3V0JiZcImluXCIhPT1yJiYocnx8aS5rZXkhPT1vKSYmKHU9Yyh0LGkub3V0LG8sYSksdCYmdSkpcmV0dXJuIHV9aWYoXCJkaXJlY3RlZFwiIT09ZSYmdm9pZCAwIT09aS51bmRpcmVjdGVkJiYodT1jKHQsaS51bmRpcmVjdGVkLG8sYSksdCYmdSkpcmV0dXJuIHV9ZnVuY3Rpb24geXQodCxlLG4scixpKXt2YXIgbz1bXTtyZXR1cm4gZ3QoITEsdCxlLG4scixpLChmdW5jdGlvbih0KXtvLnB1c2godCl9KSksb31mdW5jdGlvbiB3dCh0LGUsbixyKXt2YXIgaT1PLmVtcHR5KCk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10JiYodm9pZCAwIT09bi5pbiYmXCJvdXRcIiE9PWUmJnIgaW4gbi5pbiYmKGk9ZXQoaSxjdChuLmluLHIpKSksdm9pZCAwIT09bi5vdXQmJlwiaW5cIiE9PWUmJnIgaW4gbi5vdXQmJihlfHxuLmtleSE9PXIpJiYoaT1ldChpLGN0KG4ub3V0LHIpKSkpLFwiZGlyZWN0ZWRcIiE9PXQmJnZvaWQgMCE9PW4udW5kaXJlY3RlZCYmciBpbiBuLnVuZGlyZWN0ZWQmJihpPWV0KGksY3Qobi51bmRpcmVjdGVkLHIpKSksaX12YXIgdnQ9W3tuYW1lOlwibmVpZ2hib3JzXCIsdHlwZTpcIm1peGVkXCJ9LHtuYW1lOlwiaW5OZWlnaGJvcnNcIix0eXBlOlwiZGlyZWN0ZWRcIixkaXJlY3Rpb246XCJpblwifSx7bmFtZTpcIm91dE5laWdoYm9yc1wiLHR5cGU6XCJkaXJlY3RlZFwiLGRpcmVjdGlvbjpcIm91dFwifSx7bmFtZTpcImluYm91bmROZWlnaGJvcnNcIix0eXBlOlwibWl4ZWRcIixkaXJlY3Rpb246XCJpblwifSx7bmFtZTpcIm91dGJvdW5kTmVpZ2hib3JzXCIsdHlwZTpcIm1peGVkXCIsZGlyZWN0aW9uOlwib3V0XCJ9LHtuYW1lOlwiZGlyZWN0ZWROZWlnaGJvcnNcIix0eXBlOlwiZGlyZWN0ZWRcIn0se25hbWU6XCJ1bmRpcmVjdGVkTmVpZ2hib3JzXCIsdHlwZTpcInVuZGlyZWN0ZWRcIn1dO2Z1bmN0aW9uIGJ0KCl7dGhpcy5BPW51bGwsdGhpcy5CPW51bGx9ZnVuY3Rpb24gbXQodCxlLG4scixpKXtmb3IodmFyIG8gaW4gcil7dmFyIGE9cltvXSx1PWEuc291cmNlLGM9YS50YXJnZXQscz11PT09bj9jOnU7aWYoIWV8fCFlLmhhcyhzLmtleSkpe3ZhciBkPWkocy5rZXkscy5hdHRyaWJ1dGVzKTtpZih0JiZkKXJldHVybiBzLmtleX19fWZ1bmN0aW9uIGt0KHQsZSxuLHIsaSl7aWYoXCJtaXhlZFwiIT09ZSl7aWYoXCJ1bmRpcmVjdGVkXCI9PT1lKXJldHVybiBtdCh0LG51bGwscixyLnVuZGlyZWN0ZWQsaSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIG4pcmV0dXJuIG10KHQsbnVsbCxyLHJbbl0saSl9dmFyIG8sYT1uZXcgYnQ7aWYoXCJ1bmRpcmVjdGVkXCIhPT1lKXtpZihcIm91dFwiIT09bil7aWYobz1tdCh0LG51bGwscixyLmluLGkpLHQmJm8pcmV0dXJuIG87YS53cmFwKHIuaW4pfWlmKFwiaW5cIiE9PW4pe2lmKG89bXQodCxhLHIsci5vdXQsaSksdCYmbylyZXR1cm4gbzthLndyYXAoci5vdXQpfX1pZihcImRpcmVjdGVkXCIhPT1lJiYobz1tdCh0LGEscixyLnVuZGlyZWN0ZWQsaSksdCYmbykpcmV0dXJuIG99ZnVuY3Rpb24gX3QodCxlLG4pe3ZhciByPU9iamVjdC5rZXlzKG4pLGk9ci5sZW5ndGgsbz0wO3JldHVybiBuZXcgTygoZnVuY3Rpb24oKXt2YXIgYT1udWxsO2Rve2lmKG8+PWkpcmV0dXJuIHQmJnQud3JhcChuKSx7ZG9uZTohMH07dmFyIHU9bltyW28rK11dLGM9dS5zb3VyY2Uscz11LnRhcmdldDthPWM9PT1lP3M6Yyx0JiZ0LmhhcyhhLmtleSkmJihhPW51bGwpfXdoaWxlKG51bGw9PT1hKTtyZXR1cm57ZG9uZTohMSx2YWx1ZTp7bmVpZ2hib3I6YS5rZXksYXR0cmlidXRlczphLmF0dHJpYnV0ZXN9fX0pKX1mdW5jdGlvbiBHdCh0LGUpe3ZhciBuPWUubmFtZSxyPWUudHlwZSxpPWUuZGlyZWN0aW9uO3QucHJvdG90eXBlW25dPWZ1bmN0aW9uKHQpe2lmKFwibWl4ZWRcIiE9PXImJlwibWl4ZWRcIiE9PXRoaXMudHlwZSYmciE9PXRoaXMudHlwZSlyZXR1cm5bXTt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChuLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtpZihcIm1peGVkXCIhPT10KXtpZihcInVuZGlyZWN0ZWRcIj09PXQpcmV0dXJuIE9iamVjdC5rZXlzKG4udW5kaXJlY3RlZCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIE9iamVjdC5rZXlzKG5bZV0pfXZhciByPVtdO3JldHVybiBrdCghMSx0LGUsbiwoZnVuY3Rpb24odCl7ci5wdXNoKHQpfSkpLHJ9KFwibWl4ZWRcIj09PXI/dGhpcy50eXBlOnIsaSxlKX19ZnVuY3Rpb24geHQodCxlKXt2YXIgbj1lLm5hbWUscj1lLnR5cGUsaT1lLmRpcmVjdGlvbixvPW4uc2xpY2UoMCwtMSkrXCJFbnRyaWVzXCI7dC5wcm90b3R5cGVbb109ZnVuY3Rpb24odCl7aWYoXCJtaXhlZFwiIT09ciYmXCJtaXhlZFwiIT09dGhpcy50eXBlJiZyIT09dGhpcy50eXBlKXJldHVybiBPLmVtcHR5KCk7dD1cIlwiK3Q7dmFyIGU9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQobywnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiBmdW5jdGlvbih0LGUsbil7aWYoXCJtaXhlZFwiIT09dCl7aWYoXCJ1bmRpcmVjdGVkXCI9PT10KXJldHVybiBfdChudWxsLG4sbi51bmRpcmVjdGVkKTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gX3QobnVsbCxuLG5bZV0pfXZhciByPU8uZW1wdHkoKSxpPW5ldyBidDtyZXR1cm5cInVuZGlyZWN0ZWRcIiE9PXQmJihcIm91dFwiIT09ZSYmKHI9ZXQocixfdChpLG4sbi5pbikpKSxcImluXCIhPT1lJiYocj1ldChyLF90KGksbixuLm91dCkpKSksXCJkaXJlY3RlZFwiIT09dCYmKHI9ZXQocixfdChpLG4sbi51bmRpcmVjdGVkKSkpLHJ9KFwibWl4ZWRcIj09PXI/dGhpcy50eXBlOnIsaSxlKX19ZnVuY3Rpb24gRXQodCxlLG4scixpKXtmb3IodmFyIG8sYSx1LGMscyxkLGgscD1yLl9ub2Rlcy52YWx1ZXMoKSxmPXIudHlwZTshMCE9PShvPXAubmV4dCgpKS5kb25lOyl7dmFyIGw9ITE7aWYoYT1vLnZhbHVlLFwidW5kaXJlY3RlZFwiIT09Zilmb3IodSBpbiBjPWEub3V0KXtzPWNbdV07ZG97aWYoZD1zLnRhcmdldCxsPSEwLGg9aShhLmtleSxkLmtleSxhLmF0dHJpYnV0ZXMsZC5hdHRyaWJ1dGVzLHMua2V5LHMuYXR0cmlidXRlcyxzLnVuZGlyZWN0ZWQpLHQmJmgpcmV0dXJuIHM7cz1zLm5leHR9d2hpbGUocyl9aWYoXCJkaXJlY3RlZFwiIT09Zilmb3IodSBpbiBjPWEudW5kaXJlY3RlZClpZighKGUmJmEua2V5PnUpKXtzPWNbdV07ZG97aWYoKGQ9cy50YXJnZXQpLmtleSE9PXUmJihkPXMuc291cmNlKSxsPSEwLGg9aShhLmtleSxkLmtleSxhLmF0dHJpYnV0ZXMsZC5hdHRyaWJ1dGVzLHMua2V5LHMuYXR0cmlidXRlcyxzLnVuZGlyZWN0ZWQpLHQmJmgpcmV0dXJuIHM7cz1zLm5leHR9d2hpbGUocyl9aWYobiYmIWwmJihoPWkoYS5rZXksbnVsbCxhLmF0dHJpYnV0ZXMsbnVsbCxudWxsLG51bGwsbnVsbCksdCYmaCkpcmV0dXJuIG51bGx9fWZ1bmN0aW9uIEF0KHQpe2lmKCFoKHQpKXRocm93IG5ldyBGKCdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBub2RlLiBBIHNlcmlhbGl6ZWQgbm9kZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwia2V5XCIgcHJvcGVydHkuJyk7aWYoIShcImtleVwiaW4gdCkpdGhyb3cgbmV3IEYoXCJHcmFwaC5pbXBvcnQ6IHNlcmlhbGl6ZWQgbm9kZSBpcyBtaXNzaW5nIGl0cyBrZXkuXCIpO2lmKFwiYXR0cmlidXRlc1wiaW4gdCYmKCFoKHQuYXR0cmlidXRlcyl8fG51bGw9PT10LmF0dHJpYnV0ZXMpKXRocm93IG5ldyBGKFwiR3JhcGguaW1wb3J0OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEF0dHJpYnV0ZXMgc2hvdWxkIGJlIGEgcGxhaW4gb2JqZWN0LCBudWxsIG9yIG9taXR0ZWQuXCIpfWZ1bmN0aW9uIFN0KHQpe2lmKCFoKHQpKXRocm93IG5ldyBGKCdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBlZGdlLiBBIHNlcmlhbGl6ZWQgZWRnZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwic291cmNlXCIgJiBcInRhcmdldFwiIHByb3BlcnR5LicpO2lmKCEoXCJzb3VyY2VcImluIHQpKXRocm93IG5ldyBGKFwiR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIGVkZ2UgaXMgbWlzc2luZyBpdHMgc291cmNlLlwiKTtpZighKFwidGFyZ2V0XCJpbiB0KSl0aHJvdyBuZXcgRihcIkdyYXBoLmltcG9ydDogc2VyaWFsaXplZCBlZGdlIGlzIG1pc3NpbmcgaXRzIHRhcmdldC5cIik7aWYoXCJhdHRyaWJ1dGVzXCJpbiB0JiYoIWgodC5hdHRyaWJ1dGVzKXx8bnVsbD09PXQuYXR0cmlidXRlcykpdGhyb3cgbmV3IEYoXCJHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gQXR0cmlidXRlcyBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3QsIG51bGwgb3Igb21pdHRlZC5cIik7aWYoXCJ1bmRpcmVjdGVkXCJpbiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQudW5kaXJlY3RlZCl0aHJvdyBuZXcgRihcIkdyYXBoLmltcG9ydDogaW52YWxpZCB1bmRpcmVjdGVkbmVzcyBpbmZvcm1hdGlvbi4gVW5kaXJlY3RlZCBzaG91bGQgYmUgYm9vbGVhbiBvciBvbWl0dGVkLlwiKX1idC5wcm90b3R5cGUud3JhcD1mdW5jdGlvbih0KXtudWxsPT09dGhpcy5BP3RoaXMuQT10Om51bGw9PT10aGlzLkImJih0aGlzLkI9dCl9LGJ0LnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10aGlzLkEmJnQgaW4gdGhpcy5BfHxudWxsIT09dGhpcy5CJiZ0IGluIHRoaXMuQn07dmFyIER0LEx0PShEdD0yNTUmTWF0aC5mbG9vcigyNTYqTWF0aC5yYW5kb20oKSksZnVuY3Rpb24oKXtyZXR1cm4gRHQrK30pLFV0PW5ldyBTZXQoW1wiZGlyZWN0ZWRcIixcInVuZGlyZWN0ZWRcIixcIm1peGVkXCJdKSxOdD1uZXcgU2V0KFtcImRvbWFpblwiLFwiX2V2ZW50c1wiLFwiX2V2ZW50c0NvdW50XCIsXCJfbWF4TGlzdGVuZXJzXCJdKSxqdD17YWxsb3dTZWxmTG9vcHM6ITAsbXVsdGk6ITEsdHlwZTpcIm1peGVkXCJ9O2Z1bmN0aW9uIE90KHQsZSxuKXt2YXIgcj1uZXcgdC5Ob2RlRGF0YUNsYXNzKGUsbik7cmV0dXJuIHQuX25vZGVzLnNldChlLHIpLHQuZW1pdChcIm5vZGVBZGRlZFwiLHtrZXk6ZSxhdHRyaWJ1dGVzOm59KSxyfWZ1bmN0aW9uIEN0KHQsZSxuLHIsaSxvLGEsdSl7aWYoIXImJlwidW5kaXJlY3RlZFwiPT09dC50eXBlKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsXCI6IHlvdSBjYW5ub3QgYWRkIGEgZGlyZWN0ZWQgZWRnZSB0byBhbiB1bmRpcmVjdGVkIGdyYXBoLiBVc2UgdGhlICMuYWRkRWRnZSBvciAjLmFkZFVuZGlyZWN0ZWRFZGdlIGluc3RlYWQuXCIpKTtpZihyJiZcImRpcmVjdGVkXCI9PT10LnR5cGUpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogeW91IGNhbm5vdCBhZGQgYW4gdW5kaXJlY3RlZCBlZGdlIHRvIGEgZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5hZGRFZGdlIG9yICMuYWRkRGlyZWN0ZWRFZGdlIGluc3RlYWQuXCIpKTtpZih1JiYhaCh1KSl0aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJykuY29uY2F0KHUsJ1wiJykpO2lmKG89XCJcIitvLGE9XCJcIithLHU9dXx8e30sIXQuYWxsb3dTZWxmTG9vcHMmJm89PT1hKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsJzogc291cmNlICYgdGFyZ2V0IGFyZSB0aGUgc2FtZSAoXCInKS5jb25jYXQobyxcIlxcXCIpLCB0aHVzIGNyZWF0aW5nIGEgbG9vcCBleHBsaWNpdGx5IGZvcmJpZGRlbiBieSB0aGlzIGdyYXBoICdhbGxvd1NlbGZMb29wcycgb3B0aW9uIHNldCB0byBmYWxzZS5cIikpO3ZhciBjPXQuX25vZGVzLmdldChvKSxzPXQuX25vZGVzLmdldChhKTtpZighYyl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IHNvdXJjZSBub2RlIFwiJykuY29uY2F0KG8sJ1wiIG5vdCBmb3VuZC4nKSk7aWYoIXMpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiB0YXJnZXQgbm9kZSBcIicpLmNvbmNhdChhLCdcIiBub3QgZm91bmQuJykpO3ZhciBkPXtrZXk6bnVsbCx1bmRpcmVjdGVkOnIsc291cmNlOm8sdGFyZ2V0OmEsYXR0cmlidXRlczp1fTtpZihuKWk9dC5fZWRnZUtleUdlbmVyYXRvcigpO2Vsc2UgaWYoaT1cIlwiK2ksdC5fZWRnZXMuaGFzKGkpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsJzogdGhlIFwiJykuY29uY2F0KGksJ1wiIGVkZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGdyYXBoLicpKTtpZighdC5tdWx0aSYmKHI/dm9pZCAwIT09Yy51bmRpcmVjdGVkW2FdOnZvaWQgMCE9PWMub3V0W2FdKSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGFuIGVkZ2UgbGlua2luZyBcIicpLmNvbmNhdChvLCdcIiB0byBcIicpLmNvbmNhdChhLFwiXFxcIiBhbHJlYWR5IGV4aXN0cy4gSWYgeW91IHJlYWxseSB3YW50IHRvIGFkZCBtdWx0aXBsZSBlZGdlcyBsaW5raW5nIHRob3NlIG5vZGVzLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG11bHRpIGdyYXBoIGJ5IHVzaW5nIHRoZSAnbXVsdGknIG9wdGlvbi5cIikpO3ZhciBwPW5ldyBIKHIsaSxjLHMsdSk7dC5fZWRnZXMuc2V0KGkscCk7dmFyIGY9bz09PWE7cmV0dXJuIHI/KGMudW5kaXJlY3RlZERlZ3JlZSsrLHMudW5kaXJlY3RlZERlZ3JlZSsrLGYmJnQuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50KyspOihjLm91dERlZ3JlZSsrLHMuaW5EZWdyZWUrKyxmJiZ0Ll9kaXJlY3RlZFNlbGZMb29wQ291bnQrKyksdC5tdWx0aT9wLmF0dGFjaE11bHRpKCk6cC5hdHRhY2goKSxyP3QuX3VuZGlyZWN0ZWRTaXplKys6dC5fZGlyZWN0ZWRTaXplKyssZC5rZXk9aSx0LmVtaXQoXCJlZGdlQWRkZWRcIixkKSxpfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvLGEsdSxzKXtpZighciYmXCJ1bmRpcmVjdGVkXCI9PT10LnR5cGUpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSxcIjogeW91IGNhbm5vdCBtZXJnZS91cGRhdGUgYSBkaXJlY3RlZCBlZGdlIHRvIGFuIHVuZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5tZXJnZUVkZ2UvIy51cGRhdGVFZGdlIG9yICMuYWRkVW5kaXJlY3RlZEVkZ2UgaW5zdGVhZC5cIikpO2lmKHImJlwiZGlyZWN0ZWRcIj09PXQudHlwZSl0aHJvdyBuZXcgWShcIkdyYXBoLlwiLmNvbmNhdChlLFwiOiB5b3UgY2Fubm90IG1lcmdlL3VwZGF0ZSBhbiB1bmRpcmVjdGVkIGVkZ2UgdG8gYSBkaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLm1lcmdlRWRnZS8jLnVwZGF0ZUVkZ2Ugb3IgIy5hZGREaXJlY3RlZEVkZ2UgaW5zdGVhZC5cIikpO2lmKHUpaWYocyl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdSl0aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChlLCc6IGludmFsaWQgdXBkYXRlciBmdW5jdGlvbi4gRXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIicpLmNvbmNhdCh1LCdcIicpKX1lbHNlIGlmKCFoKHUpKXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KGUsJzogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCInKS5jb25jYXQodSwnXCInKSk7dmFyIGQ7aWYobz1cIlwiK28sYT1cIlwiK2EscyYmKGQ9dSx1PXZvaWQgMCksIXQuYWxsb3dTZWxmTG9vcHMmJm89PT1hKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsJzogc291cmNlICYgdGFyZ2V0IGFyZSB0aGUgc2FtZSAoXCInKS5jb25jYXQobyxcIlxcXCIpLCB0aHVzIGNyZWF0aW5nIGEgbG9vcCBleHBsaWNpdGx5IGZvcmJpZGRlbiBieSB0aGlzIGdyYXBoICdhbGxvd1NlbGZMb29wcycgb3B0aW9uIHNldCB0byBmYWxzZS5cIikpO3ZhciBwLGYsbD10Ll9ub2Rlcy5nZXQobyksZz10Ll9ub2Rlcy5nZXQoYSk7aWYoIW4mJihwPXQuX2VkZ2VzLmdldChpKSkpe2lmKCEocC5zb3VyY2Uua2V5PT09byYmcC50YXJnZXQua2V5PT09YXx8ciYmcC5zb3VyY2Uua2V5PT09YSYmcC50YXJnZXQua2V5PT09bykpdGhyb3cgbmV3IFkoXCJHcmFwaC5cIi5jb25jYXQoZSwnOiBpbmNvbnNpc3RlbmN5IGRldGVjdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBtZXJnZSB0aGUgXCInKS5jb25jYXQoaSwnXCIgZWRnZSB3aXRoIFwiJykuY29uY2F0KG8sJ1wiIHNvdXJjZSAmIFwiJykuY29uY2F0KGEsJ1wiIHRhcmdldCB2cy4gKFwiJykuY29uY2F0KHAuc291cmNlLmtleSwnXCIsIFwiJykuY29uY2F0KHAudGFyZ2V0LmtleSwnXCIpLicpKTtmPXB9aWYoZnx8dC5tdWx0aXx8IWx8fChmPXI/bC51bmRpcmVjdGVkW2FdOmwub3V0W2FdKSxmKXt2YXIgeT1bZi5rZXksITEsITEsITFdO2lmKHM/IWQ6IXUpcmV0dXJuIHk7aWYocyl7dmFyIHc9Zi5hdHRyaWJ1dGVzO2YuYXR0cmlidXRlcz1kKHcpLHQuZW1pdChcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLHt0eXBlOlwicmVwbGFjZVwiLGtleTpmLmtleSxhdHRyaWJ1dGVzOmYuYXR0cmlidXRlc30pfWVsc2UgYyhmLmF0dHJpYnV0ZXMsdSksdC5lbWl0KFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIse3R5cGU6XCJtZXJnZVwiLGtleTpmLmtleSxhdHRyaWJ1dGVzOmYuYXR0cmlidXRlcyxkYXRhOnV9KTtyZXR1cm4geX11PXV8fHt9LHMmJmQmJih1PWQodSkpO3ZhciB2PXtrZXk6bnVsbCx1bmRpcmVjdGVkOnIsc291cmNlOm8sdGFyZ2V0OmEsYXR0cmlidXRlczp1fTtpZihuKWk9dC5fZWRnZUtleUdlbmVyYXRvcigpO2Vsc2UgaWYoaT1cIlwiK2ksdC5fZWRnZXMuaGFzKGkpKXRocm93IG5ldyBZKFwiR3JhcGguXCIuY29uY2F0KGUsJzogdGhlIFwiJykuY29uY2F0KGksJ1wiIGVkZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGdyYXBoLicpKTt2YXIgYj0hMSxtPSExO2x8fChsPU90KHQsbyx7fSksYj0hMCxvPT09YSYmKGc9bCxtPSEwKSksZ3x8KGc9T3QodCxhLHt9KSxtPSEwKSxwPW5ldyBIKHIsaSxsLGcsdSksdC5fZWRnZXMuc2V0KGkscCk7dmFyIGs9bz09PWE7cmV0dXJuIHI/KGwudW5kaXJlY3RlZERlZ3JlZSsrLGcudW5kaXJlY3RlZERlZ3JlZSsrLGsmJnQuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50KyspOihsLm91dERlZ3JlZSsrLGcuaW5EZWdyZWUrKyxrJiZ0Ll9kaXJlY3RlZFNlbGZMb29wQ291bnQrKyksdC5tdWx0aT9wLmF0dGFjaE11bHRpKCk6cC5hdHRhY2goKSxyP3QuX3VuZGlyZWN0ZWRTaXplKys6dC5fZGlyZWN0ZWRTaXplKyssdi5rZXk9aSx0LmVtaXQoXCJlZGdlQWRkZWRcIix2KSxbaSwhMCxiLG1dfWZ1bmN0aW9uIE10KHQsZSl7dC5fZWRnZXMuZGVsZXRlKGUua2V5KTt2YXIgbj1lLnNvdXJjZSxyPWUudGFyZ2V0LGk9ZS5hdHRyaWJ1dGVzLG89ZS51bmRpcmVjdGVkLGE9bj09PXI7bz8obi51bmRpcmVjdGVkRGVncmVlLS0sci51bmRpcmVjdGVkRGVncmVlLS0sYSYmdC5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQtLSk6KG4ub3V0RGVncmVlLS0sci5pbkRlZ3JlZS0tLGEmJnQuX2RpcmVjdGVkU2VsZkxvb3BDb3VudC0tKSx0Lm11bHRpP2UuZGV0YWNoTXVsdGkoKTplLmRldGFjaCgpLG8/dC5fdW5kaXJlY3RlZFNpemUtLTp0Ll9kaXJlY3RlZFNpemUtLSx0LmVtaXQoXCJlZGdlRHJvcHBlZFwiLHtrZXk6ZS5rZXksYXR0cmlidXRlczppLHNvdXJjZTpuLmtleSx0YXJnZXQ6ci5rZXksdW5kaXJlY3RlZDpvfSl9dmFyIFd0PWZ1bmN0aW9uKG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU7aWYoZT1uLmNhbGwodGhpcyl8fHRoaXMsXCJib29sZWFuXCIhPXR5cGVvZih0PWMoe30sanQsdCkpLm11bHRpKXRocm93IG5ldyBGKFwiR3JhcGguY29uc3RydWN0b3I6IGludmFsaWQgJ211bHRpJyBvcHRpb24uIEV4cGVjdGluZyBhIGJvb2xlYW4gYnV0IGdvdCBcXFwiXCIuY29uY2F0KHQubXVsdGksJ1wiLicpKTtpZighVXQuaGFzKHQudHlwZSkpdGhyb3cgbmV3IEYoJ0dyYXBoLmNvbnN0cnVjdG9yOiBpbnZhbGlkIFxcJ3R5cGVcXCcgb3B0aW9uLiBTaG91bGQgYmUgb25lIG9mIFwibWl4ZWRcIiwgXCJkaXJlY3RlZFwiIG9yIFwidW5kaXJlY3RlZFwiIGJ1dCBnb3QgXCInLmNvbmNhdCh0LnR5cGUsJ1wiLicpKTtpZihcImJvb2xlYW5cIiE9dHlwZW9mIHQuYWxsb3dTZWxmTG9vcHMpdGhyb3cgbmV3IEYoXCJHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAnYWxsb3dTZWxmTG9vcHMnIG9wdGlvbi4gRXhwZWN0aW5nIGEgYm9vbGVhbiBidXQgZ290IFxcXCJcIi5jb25jYXQodC5hbGxvd1NlbGZMb29wcywnXCIuJykpO3ZhciByPVwibWl4ZWRcIj09PXQudHlwZT9xOlwiZGlyZWN0ZWRcIj09PXQudHlwZT9KOlY7Zih1KGUpLFwiTm9kZURhdGFDbGFzc1wiLHIpO3ZhciBpPVwiZ2VpZF9cIitMdCgpK1wiX1wiLG89MDtyZXR1cm4gZih1KGUpLFwiX2F0dHJpYnV0ZXNcIix7fSksZih1KGUpLFwiX25vZGVzXCIsbmV3IE1hcCksZih1KGUpLFwiX2VkZ2VzXCIsbmV3IE1hcCksZih1KGUpLFwiX2RpcmVjdGVkU2l6ZVwiLDApLGYodShlKSxcIl91bmRpcmVjdGVkU2l6ZVwiLDApLGYodShlKSxcIl9kaXJlY3RlZFNlbGZMb29wQ291bnRcIiwwKSxmKHUoZSksXCJfdW5kaXJlY3RlZFNlbGZMb29wQ291bnRcIiwwKSxmKHUoZSksXCJfZWRnZUtleUdlbmVyYXRvclwiLChmdW5jdGlvbigpe3ZhciB0O2Rve3Q9aStvKyt9d2hpbGUoZS5fZWRnZXMuaGFzKHQpKTtyZXR1cm4gdH0pKSxmKHUoZSksXCJfb3B0aW9uc1wiLHQpLE50LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBmKHUoZSksdCxlW3RdKX0pKSxsKHUoZSksXCJvcmRlclwiLChmdW5jdGlvbigpe3JldHVybiBlLl9ub2Rlcy5zaXplfSkpLGwodShlKSxcInNpemVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZS5fZWRnZXMuc2l6ZX0pKSxsKHUoZSksXCJkaXJlY3RlZFNpemVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZS5fZGlyZWN0ZWRTaXplfSkpLGwodShlKSxcInVuZGlyZWN0ZWRTaXplXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuX3VuZGlyZWN0ZWRTaXplfSkpLGwodShlKSxcInNlbGZMb29wQ291bnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZS5fZGlyZWN0ZWRTZWxmTG9vcENvdW50K2UuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50fSkpLGwodShlKSxcImRpcmVjdGVkU2VsZkxvb3BDb3VudFwiLChmdW5jdGlvbigpe3JldHVybiBlLl9kaXJlY3RlZFNlbGZMb29wQ291bnR9KSksbCh1KGUpLFwidW5kaXJlY3RlZFNlbGZMb29wQ291bnRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZS5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnR9KSksbCh1KGUpLFwibXVsdGlcIixlLl9vcHRpb25zLm11bHRpKSxsKHUoZSksXCJ0eXBlXCIsZS5fb3B0aW9ucy50eXBlKSxsKHUoZSksXCJhbGxvd1NlbGZMb29wc1wiLGUuX29wdGlvbnMuYWxsb3dTZWxmTG9vcHMpLGwodShlKSxcImltcGxlbWVudGF0aW9uXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJncmFwaG9sb2d5XCJ9KSksZX1lKHIsbik7dmFyIGk9ci5wcm90b3R5cGU7cmV0dXJuIGkuX3Jlc2V0SW5zdGFuY2VDb3VudGVycz1mdW5jdGlvbigpe3RoaXMuX2RpcmVjdGVkU2l6ZT0wLHRoaXMuX3VuZGlyZWN0ZWRTaXplPTAsdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50PTAsdGhpcy5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQ9MH0saS5oYXNOb2RlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9ub2Rlcy5oYXMoXCJcIit0KX0saS5oYXNEaXJlY3RlZEVkZ2U9ZnVuY3Rpb24odCxlKXtpZihcInVuZGlyZWN0ZWRcIj09PXRoaXMudHlwZSlyZXR1cm4hMTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49XCJcIit0LHI9dGhpcy5fZWRnZXMuZ2V0KG4pO3JldHVybiEhciYmIXIudW5kaXJlY3RlZH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dD1cIlwiK3QsZT1cIlwiK2U7dmFyIGk9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFpKXJldHVybiExO3ZhciBvPWkub3V0W2VdO3JldHVybiEhbyYmKCF0aGlzLm11bHRpfHwhIW8uc2l6ZSl9dGhyb3cgbmV3IEYoXCJHcmFwaC5oYXNEaXJlY3RlZEVkZ2U6IGludmFsaWQgYXJpdHkgKFwiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoLFwiLCBpbnN0ZWFkIG9mIDEgb3IgMikuIFlvdSBjYW4gZWl0aGVyIGFzayBmb3IgYW4gZWRnZSBpZCBvciBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBlZGdlIGJldHdlZW4gYSBzb3VyY2UgJiBhIHRhcmdldC5cIikpfSxpLmhhc1VuZGlyZWN0ZWRFZGdlPWZ1bmN0aW9uKHQsZSl7aWYoXCJkaXJlY3RlZFwiPT09dGhpcy50eXBlKXJldHVybiExO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1cIlwiK3Qscj10aGlzLl9lZGdlcy5nZXQobik7cmV0dXJuISFyJiZyLnVuZGlyZWN0ZWR9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3Q9XCJcIit0LGU9XCJcIitlO3ZhciBpPXRoaXMuX25vZGVzLmdldCh0KTtpZighaSlyZXR1cm4hMTt2YXIgbz1pLnVuZGlyZWN0ZWRbZV07cmV0dXJuISFvJiYoIXRoaXMubXVsdGl8fCEhby5zaXplKX10aHJvdyBuZXcgRihcIkdyYXBoLmhhc0RpcmVjdGVkRWRnZTogaW52YWxpZCBhcml0eSAoXCIuY29uY2F0KGFyZ3VtZW50cy5sZW5ndGgsXCIsIGluc3RlYWQgb2YgMSBvciAyKS4gWW91IGNhbiBlaXRoZXIgYXNrIGZvciBhbiBlZGdlIGlkIG9yIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIGVkZ2UgYmV0d2VlbiBhIHNvdXJjZSAmIGEgdGFyZ2V0LlwiKSl9LGkuaGFzRWRnZT1mdW5jdGlvbih0LGUpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1cIlwiK3Q7cmV0dXJuIHRoaXMuX2VkZ2VzLmhhcyhuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dD1cIlwiK3QsZT1cIlwiK2U7dmFyIHI9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFyKXJldHVybiExO3ZhciBpPXZvaWQgMCE9PXIub3V0JiZyLm91dFtlXTtyZXR1cm4gaXx8KGk9dm9pZCAwIT09ci51bmRpcmVjdGVkJiZyLnVuZGlyZWN0ZWRbZV0pLCEhaSYmKCF0aGlzLm11bHRpfHwhIWkuc2l6ZSl9dGhyb3cgbmV3IEYoXCJHcmFwaC5oYXNFZGdlOiBpbnZhbGlkIGFyaXR5IChcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCxcIiwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuXCIpKX0saS5kaXJlY3RlZEVkZ2U9ZnVuY3Rpb24odCxlKXtpZihcInVuZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSl7aWYodD1cIlwiK3QsZT1cIlwiK2UsdGhpcy5tdWx0aSl0aHJvdyBuZXcgWShcIkdyYXBoLmRpcmVjdGVkRWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy5kaXJlY3RlZEVkZ2VzIGluc3RlYWQuXCIpO3ZhciBuPXRoaXMuX25vZGVzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGguZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguJykpO2lmKCF0aGlzLl9ub2Rlcy5oYXMoZSkpdGhyb3cgbmV3IEkoJ0dyYXBoLmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQoZSwnXCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLicpKTt2YXIgcj1uLm91dCYmbi5vdXRbZV18fHZvaWQgMDtyZXR1cm4gcj9yLmtleTp2b2lkIDB9fSxpLnVuZGlyZWN0ZWRFZGdlPWZ1bmN0aW9uKHQsZSl7aWYoXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlKXtpZih0PVwiXCIrdCxlPVwiXCIrZSx0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGgudW5kaXJlY3RlZEVkZ2U6IHRoaXMgbWV0aG9kIGlzIGlycmVsZXZhbnQgd2l0aCBtdWx0aWdyYXBocyBzaW5jZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldC4gU2VlICMudW5kaXJlY3RlZEVkZ2VzIGluc3RlYWQuXCIpO3ZhciBuPXRoaXMuX25vZGVzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGgudW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoIXRoaXMuX25vZGVzLmhhcyhlKSl0aHJvdyBuZXcgSSgnR3JhcGgudW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KGUsJ1wiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC4nKSk7dmFyIHI9bi51bmRpcmVjdGVkJiZuLnVuZGlyZWN0ZWRbZV18fHZvaWQgMDtyZXR1cm4gcj9yLmtleTp2b2lkIDB9fSxpLmVkZ2U9ZnVuY3Rpb24odCxlKXtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguZWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy5lZGdlcyBpbnN0ZWFkLlwiKTt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoIXRoaXMuX25vZGVzLmhhcyhlKSl0aHJvdyBuZXcgSSgnR3JhcGguZWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQoZSwnXCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLicpKTt2YXIgcj1uLm91dCYmbi5vdXRbZV18fG4udW5kaXJlY3RlZCYmbi51bmRpcmVjdGVkW2VdfHx2b2lkIDA7aWYocilyZXR1cm4gci5rZXl9LGkuYXJlRGlyZWN0ZWROZWlnaGJvcnM9ZnVuY3Rpb24odCxlKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmFyZURpcmVjdGVkTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUmJihlIGluIG4uaW58fGUgaW4gbi5vdXQpfSxpLmFyZU91dE5laWdoYm9ycz1mdW5jdGlvbih0LGUpe3Q9XCJcIit0LGU9XCJcIitlO3ZhciBuPXRoaXMuX25vZGVzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGguYXJlT3V0TmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUmJmUgaW4gbi5vdXR9LGkuYXJlSW5OZWlnaGJvcnM9ZnVuY3Rpb24odCxlKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmFyZUluTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUmJmUgaW4gbi5pbn0saS5hcmVVbmRpcmVjdGVkTmVpZ2hib3JzPWZ1bmN0aW9uKHQsZSl7dD1cIlwiK3QsZT1cIlwiK2U7dmFyIG49dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBJKCdHcmFwaC5hcmVVbmRpcmVjdGVkTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiZlIGluIG4udW5kaXJlY3RlZH0saS5hcmVOZWlnaGJvcnM9ZnVuY3Rpb24odCxlKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmFyZU5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVyblwidW5kaXJlY3RlZFwiIT09dGhpcy50eXBlJiYoZSBpbiBuLmlufHxlIGluIG4ub3V0KXx8XCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiZlIGluIG4udW5kaXJlY3RlZH0saS5hcmVJbmJvdW5kTmVpZ2hib3JzPWZ1bmN0aW9uKHQsZSl7dD1cIlwiK3QsZT1cIlwiK2U7dmFyIG49dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBJKCdHcmFwaC5hcmVJbmJvdW5kTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUmJmUgaW4gbi5pbnx8XCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiZlIGluIG4udW5kaXJlY3RlZH0saS5hcmVPdXRib3VuZE5laWdoYm9ycz1mdW5jdGlvbih0LGUpe3Q9XCJcIit0LGU9XCJcIitlO3ZhciBuPXRoaXMuX25vZGVzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGguYXJlT3V0Ym91bmROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIG5vZGUgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm5cInVuZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmZSBpbiBuLm91dHx8XCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiZlIGluIG4udW5kaXJlY3RlZH0saS5pbkRlZ3JlZT1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLmluRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuXCJ1bmRpcmVjdGVkXCI9PT10aGlzLnR5cGU/MDplLmluRGVncmVlfSxpLm91dERlZ3JlZT1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLm91dERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVyblwidW5kaXJlY3RlZFwiPT09dGhpcy50eXBlPzA6ZS5vdXREZWdyZWV9LGkuZGlyZWN0ZWREZWdyZWU9ZnVuY3Rpb24odCl7dD1cIlwiK3Q7dmFyIGU9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFlKXRocm93IG5ldyBJKCdHcmFwaC5kaXJlY3RlZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVyblwidW5kaXJlY3RlZFwiPT09dGhpcy50eXBlPzA6ZS5pbkRlZ3JlZStlLm91dERlZ3JlZX0saS51bmRpcmVjdGVkRGVncmVlPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX25vZGVzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGgudW5kaXJlY3RlZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVyblwiZGlyZWN0ZWRcIj09PXRoaXMudHlwZT8wOmUudW5kaXJlY3RlZERlZ3JlZX0saS5pbmJvdW5kRGVncmVlPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX25vZGVzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGguaW5ib3VuZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3ZhciBuPTA7cmV0dXJuXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiYobis9ZS51bmRpcmVjdGVkRGVncmVlKSxcInVuZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmKG4rPWUuaW5EZWdyZWUpLG59LGkub3V0Ym91bmREZWdyZWU9ZnVuY3Rpb24odCl7dD1cIlwiK3Q7dmFyIGU9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFlKXRocm93IG5ldyBJKCdHcmFwaC5vdXRib3VuZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3ZhciBuPTA7cmV0dXJuXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiYobis9ZS51bmRpcmVjdGVkRGVncmVlKSxcInVuZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmKG4rPWUub3V0RGVncmVlKSxufSxpLmRlZ3JlZT1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLmRlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3ZhciBuPTA7cmV0dXJuXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiYobis9ZS51bmRpcmVjdGVkRGVncmVlKSxcInVuZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmKG4rPWUuaW5EZWdyZWUrZS5vdXREZWdyZWUpLG59LGkuaW5EZWdyZWVXaXRob3V0U2VsZkxvb3BzPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX25vZGVzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGguaW5EZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoXCJ1bmRpcmVjdGVkXCI9PT10aGlzLnR5cGUpcmV0dXJuIDA7dmFyIG49ZS5pblt0XSxyPW4/dGhpcy5tdWx0aT9uLnNpemU6MTowO3JldHVybiBlLmluRGVncmVlLXJ9LGkub3V0RGVncmVlV2l0aG91dFNlbGZMb29wcz1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLm91dERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIG5vZGUgaW4gdGhlIGdyYXBoLicpKTtpZihcInVuZGlyZWN0ZWRcIj09PXRoaXMudHlwZSlyZXR1cm4gMDt2YXIgbj1lLm91dFt0XSxyPW4/dGhpcy5tdWx0aT9uLnNpemU6MTowO3JldHVybiBlLm91dERlZ3JlZS1yfSxpLmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wcz1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO2lmKFwidW5kaXJlY3RlZFwiPT09dGhpcy50eXBlKXJldHVybiAwO3ZhciBuPWUub3V0W3RdLHI9bj90aGlzLm11bHRpP24uc2l6ZToxOjA7cmV0dXJuIGUuaW5EZWdyZWUrZS5vdXREZWdyZWUtMipyfSxpLnVuZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX25vZGVzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGgudW5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIG5vZGUgaW4gdGhlIGdyYXBoLicpKTtpZihcImRpcmVjdGVkXCI9PT10aGlzLnR5cGUpcmV0dXJuIDA7dmFyIG49ZS51bmRpcmVjdGVkW3RdLHI9bj90aGlzLm11bHRpP24uc2l6ZToxOjA7cmV0dXJuIGUudW5kaXJlY3RlZERlZ3JlZS0yKnJ9LGkuaW5ib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM9ZnVuY3Rpb24odCl7dD1cIlwiK3Q7dmFyIGUsbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmluYm91bmREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7dmFyIHI9MCxpPTA7cmV0dXJuXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlJiYocis9bi51bmRpcmVjdGVkRGVncmVlLGkrPTIqKChlPW4udW5kaXJlY3RlZFt0XSk/dGhpcy5tdWx0aT9lLnNpemU6MTowKSksXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUmJihyKz1uLmluRGVncmVlLGkrPShlPW4ub3V0W3RdKT90aGlzLm11bHRpP2Uuc2l6ZToxOjApLHItaX0saS5vdXRib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM9ZnVuY3Rpb24odCl7dD1cIlwiK3Q7dmFyIGUsbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLm91dGJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3ZhciByPTAsaT0wO3JldHVyblwiZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmKHIrPW4udW5kaXJlY3RlZERlZ3JlZSxpKz0yKigoZT1uLnVuZGlyZWN0ZWRbdF0pP3RoaXMubXVsdGk/ZS5zaXplOjE6MCkpLFwidW5kaXJlY3RlZFwiIT09dGhpcy50eXBlJiYocis9bi5vdXREZWdyZWUsaSs9KGU9bi5pblt0XSk/dGhpcy5tdWx0aT9lLnNpemU6MTowKSxyLWl9LGkuZGVncmVlV2l0aG91dFNlbGZMb29wcz1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZSxuPXRoaXMuX25vZGVzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGguZGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3ZhciByPTAsaT0wO3JldHVyblwiZGlyZWN0ZWRcIiE9PXRoaXMudHlwZSYmKHIrPW4udW5kaXJlY3RlZERlZ3JlZSxpKz0yKigoZT1uLnVuZGlyZWN0ZWRbdF0pP3RoaXMubXVsdGk/ZS5zaXplOjE6MCkpLFwidW5kaXJlY3RlZFwiIT09dGhpcy50eXBlJiYocis9bi5pbkRlZ3JlZStuLm91dERlZ3JlZSxpKz0yKigoZT1uLm91dFt0XSk/dGhpcy5tdWx0aT9lLnNpemU6MTowKSksci1pfSxpLnNvdXJjZT1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9lZGdlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLnNvdXJjZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiBlLnNvdXJjZS5rZXl9LGkudGFyZ2V0PWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX2VkZ2VzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGgudGFyZ2V0OiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIGUudGFyZ2V0LmtleX0saS5leHRyZW1pdGllcz1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9lZGdlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLmV4dHJlbWl0aWVzOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuW2Uuc291cmNlLmtleSxlLnRhcmdldC5rZXldfSxpLm9wcG9zaXRlPWZ1bmN0aW9uKHQsZSl7dD1cIlwiK3QsZT1cIlwiK2U7dmFyIG49dGhpcy5fZWRnZXMuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBJKCdHcmFwaC5vcHBvc2l0ZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQoZSwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpO3ZhciByPW4uc291cmNlLmtleSxpPW4udGFyZ2V0LmtleTtpZih0PT09cilyZXR1cm4gaTtpZih0PT09aSlyZXR1cm4gcjt0aHJvdyBuZXcgSSgnR3JhcGgub3Bwb3NpdGU6IHRoZSBcIicuY29uY2F0KHQsJ1wiIG5vZGUgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBcIicpLmNvbmNhdChlLCdcIiBlZGdlICgnKS5jb25jYXQocixcIiwgXCIpLmNvbmNhdChpLFwiKS5cIikpfSxpLmhhc0V4dHJlbWl0eT1mdW5jdGlvbih0LGUpe3Q9XCJcIit0LGU9XCJcIitlO3ZhciBuPXRoaXMuX2VkZ2VzLmdldCh0KTtpZighbil0aHJvdyBuZXcgSSgnR3JhcGguaGFzRXh0cmVtaXR5OiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIG4uc291cmNlLmtleT09PWV8fG4udGFyZ2V0LmtleT09PWV9LGkuaXNVbmRpcmVjdGVkPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX2VkZ2VzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGguaXNVbmRpcmVjdGVkOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIGUudW5kaXJlY3RlZH0saS5pc0RpcmVjdGVkPWZ1bmN0aW9uKHQpe3Q9XCJcIit0O3ZhciBlPXRoaXMuX2VkZ2VzLmdldCh0KTtpZighZSl0aHJvdyBuZXcgSSgnR3JhcGguaXNEaXJlY3RlZDogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQodCwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiFlLnVuZGlyZWN0ZWR9LGkuaXNTZWxmTG9vcD1mdW5jdGlvbih0KXt0PVwiXCIrdDt2YXIgZT10aGlzLl9lZGdlcy5nZXQodCk7aWYoIWUpdGhyb3cgbmV3IEkoJ0dyYXBoLmlzU2VsZkxvb3A6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicuY29uY2F0KHQsJ1wiIGVkZ2UgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm4gZS5zb3VyY2U9PT1lLnRhcmdldH0saS5hZGROb2RlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZnVuY3Rpb24odCxlLG4pe2lmKG4mJiFoKG4pKXRocm93IG5ldyBGKCdHcmFwaC5hZGROb2RlOiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIicuY29uY2F0KG4sJ1wiJykpO2lmKGU9XCJcIitlLG49bnx8e30sdC5fbm9kZXMuaGFzKGUpKXRocm93IG5ldyBZKCdHcmFwaC5hZGROb2RlOiB0aGUgXCInLmNvbmNhdChlLCdcIiBub2RlIGFscmVhZHkgZXhpc3QgaW4gdGhlIGdyYXBoLicpKTt2YXIgcj1uZXcgdC5Ob2RlRGF0YUNsYXNzKGUsbik7cmV0dXJuIHQuX25vZGVzLnNldChlLHIpLHQuZW1pdChcIm5vZGVBZGRlZFwiLHtrZXk6ZSxhdHRyaWJ1dGVzOm59KSxyfSh0aGlzLHQsZSk7cmV0dXJuIG4ua2V5fSxpLm1lcmdlTm9kZT1mdW5jdGlvbih0LGUpe2lmKGUmJiFoKGUpKXRocm93IG5ldyBGKCdHcmFwaC5tZXJnZU5vZGU6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJy5jb25jYXQoZSwnXCInKSk7dD1cIlwiK3QsZT1lfHx7fTt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7cmV0dXJuIG4/KGUmJihjKG4uYXR0cmlidXRlcyxlKSx0aGlzLmVtaXQoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7dHlwZTpcIm1lcmdlXCIsa2V5OnQsYXR0cmlidXRlczpuLmF0dHJpYnV0ZXMsZGF0YTplfSkpLFt0LCExXSk6KG49bmV3IHRoaXMuTm9kZURhdGFDbGFzcyh0LGUpLHRoaXMuX25vZGVzLnNldCh0LG4pLHRoaXMuZW1pdChcIm5vZGVBZGRlZFwiLHtrZXk6dCxhdHRyaWJ1dGVzOmV9KSxbdCwhMF0pfSxpLnVwZGF0ZU5vZGU9ZnVuY3Rpb24odCxlKXtpZihlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBGKCdHcmFwaC51cGRhdGVOb2RlOiBpbnZhbGlkIHVwZGF0ZXIgZnVuY3Rpb24uIEV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCInLmNvbmNhdChlLCdcIicpKTt0PVwiXCIrdDt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYobil7aWYoZSl7dmFyIHI9bi5hdHRyaWJ1dGVzO24uYXR0cmlidXRlcz1lKHIpLHRoaXMuZW1pdChcIm5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLHt0eXBlOlwicmVwbGFjZVwiLGtleTp0LGF0dHJpYnV0ZXM6bi5hdHRyaWJ1dGVzfSl9cmV0dXJuW3QsITFdfXZhciBpPWU/ZSh7fSk6e307cmV0dXJuIG49bmV3IHRoaXMuTm9kZURhdGFDbGFzcyh0LGkpLHRoaXMuX25vZGVzLnNldCh0LG4pLHRoaXMuZW1pdChcIm5vZGVBZGRlZFwiLHtrZXk6dCxhdHRyaWJ1dGVzOml9KSxbdCwhMF19LGkuZHJvcE5vZGU9ZnVuY3Rpb24odCl7dD1cIlwiK3Q7dmFyIGUsbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmRyb3BOb2RlOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoXCJ1bmRpcmVjdGVkXCIhPT10aGlzLnR5cGUpe2Zvcih2YXIgciBpbiBuLm91dCl7ZT1uLm91dFtyXTtkb3tNdCh0aGlzLGUpLGU9ZS5uZXh0fXdoaWxlKGUpfWZvcih2YXIgaSBpbiBuLmluKXtlPW4uaW5baV07ZG97TXQodGhpcyxlKSxlPWUubmV4dH13aGlsZShlKX19aWYoXCJkaXJlY3RlZFwiIT09dGhpcy50eXBlKWZvcih2YXIgbyBpbiBuLnVuZGlyZWN0ZWQpe2U9bi51bmRpcmVjdGVkW29dO2Rve010KHRoaXMsZSksZT1lLm5leHR9d2hpbGUoZSl9dGhpcy5fbm9kZXMuZGVsZXRlKHQpLHRoaXMuZW1pdChcIm5vZGVEcm9wcGVkXCIse2tleTp0LGF0dHJpYnV0ZXM6bi5hdHRyaWJ1dGVzfSl9LGkuZHJvcEVkZ2U9ZnVuY3Rpb24odCl7dmFyIGU7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXt2YXIgbj1cIlwiK2FyZ3VtZW50c1swXSxyPVwiXCIrYXJndW1lbnRzWzFdO2lmKCEoZT1zKHRoaXMsbixyLHRoaXMudHlwZSkpKXRocm93IG5ldyBJKCdHcmFwaC5kcm9wRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJy5jb25jYXQobiwnXCIgLT4gXCInKS5jb25jYXQociwnXCIgZWRnZSBpbiB0aGUgZ3JhcGguJykpfWVsc2UgaWYodD1cIlwiK3QsIShlPXRoaXMuX2VkZ2VzLmdldCh0KSkpdGhyb3cgbmV3IEkoJ0dyYXBoLmRyb3BFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCInLmNvbmNhdCh0LCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIE10KHRoaXMsZSksdGhpc30saS5kcm9wRGlyZWN0ZWRFZGdlPWZ1bmN0aW9uKHQsZSl7aWYoYXJndW1lbnRzLmxlbmd0aDwyKXRocm93IG5ldyBZKFwiR3JhcGguZHJvcERpcmVjdGVkRWRnZTogaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byB0cnkgYW5kIGRyb3AgYSBkaXJlY3RlZCBlZGdlIGJ5IGtleS4gV2hhdCBpZiB0aGUgZWRnZSB3aXRoIHRoaXMga2V5IGlzIHVuZGlyZWN0ZWQ/IFVzZSAjLmRyb3BFZGdlIGZvciB0aGlzIHB1cnBvc2UgaW5zdGVhZC5cIik7aWYodGhpcy5tdWx0aSl0aHJvdyBuZXcgWShcIkdyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBkcm9wcGluZyBhbiBlZGdlIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCB0byBkZWxldGUgYXMgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgb25lcy5cIik7dmFyIG49cyh0aGlzLHQ9XCJcIit0LGU9XCJcIitlLFwiZGlyZWN0ZWRcIik7aWYoIW4pdGhyb3cgbmV3IEkoJ0dyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIGEgXCInLmNvbmNhdCh0LCdcIiAtPiBcIicpLmNvbmNhdChlLCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIE10KHRoaXMsbiksdGhpc30saS5kcm9wVW5kaXJlY3RlZEVkZ2U9ZnVuY3Rpb24odCxlKXtpZihhcmd1bWVudHMubGVuZ3RoPDIpdGhyb3cgbmV3IFkoXCJHcmFwaC5kcm9wVW5kaXJlY3RlZEVkZ2U6IGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gZHJvcCBhIGRpcmVjdGVkIGVkZ2UgYnkga2V5LiBXaGF0IGlmIHRoZSBlZGdlIHdpdGggdGhpcyBrZXkgaXMgdW5kaXJlY3RlZD8gVXNlICMuZHJvcEVkZ2UgZm9yIHRoaXMgcHVycG9zZSBpbnN0ZWFkLlwiKTtpZih0aGlzLm11bHRpKXRocm93IG5ldyBZKFwiR3JhcGguZHJvcFVuZGlyZWN0ZWRFZGdlOiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gZHJvcHBpbmcgYW4gZWRnZSBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgdG8gZGVsZXRlIGFzIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG9uZXMuXCIpO3ZhciBuPXModGhpcyx0LGUsXCJ1bmRpcmVjdGVkXCIpO2lmKCFuKXRocm93IG5ldyBJKCdHcmFwaC5kcm9wVW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIGEgXCInLmNvbmNhdCh0LCdcIiAtPiBcIicpLmNvbmNhdChlLCdcIiBlZGdlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIE10KHRoaXMsbiksdGhpc30saS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX2VkZ2VzLmNsZWFyKCksdGhpcy5fbm9kZXMuY2xlYXIoKSx0aGlzLl9yZXNldEluc3RhbmNlQ291bnRlcnMoKSx0aGlzLmVtaXQoXCJjbGVhcmVkXCIpfSxpLmNsZWFyRWRnZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQsZT10aGlzLl9ub2Rlcy52YWx1ZXMoKTshMCE9PSh0PWUubmV4dCgpKS5kb25lOyl0LnZhbHVlLmNsZWFyKCk7dGhpcy5fZWRnZXMuY2xlYXIoKSx0aGlzLl9yZXNldEluc3RhbmNlQ291bnRlcnMoKSx0aGlzLmVtaXQoXCJlZGdlc0NsZWFyZWRcIil9LGkuZ2V0QXR0cmlidXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzW3RdfSxpLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXR0cmlidXRlc30saS5oYXNBdHRyaWJ1dGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkodCl9LGkuc2V0QXR0cmlidXRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbdF09ZSx0aGlzLmVtaXQoXCJhdHRyaWJ1dGVzVXBkYXRlZFwiLHt0eXBlOlwic2V0XCIsYXR0cmlidXRlczp0aGlzLl9hdHRyaWJ1dGVzLG5hbWU6dH0pLHRoaXN9LGkudXBkYXRlQXR0cmlidXRlPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRihcIkdyYXBoLnVwZGF0ZUF0dHJpYnV0ZTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7dmFyIG49dGhpcy5fYXR0cmlidXRlc1t0XTtyZXR1cm4gdGhpcy5fYXR0cmlidXRlc1t0XT1lKG4pLHRoaXMuZW1pdChcImF0dHJpYnV0ZXNVcGRhdGVkXCIse3R5cGU6XCJzZXRcIixhdHRyaWJ1dGVzOnRoaXMuX2F0dHJpYnV0ZXMsbmFtZTp0fSksdGhpc30saS5yZW1vdmVBdHRyaWJ1dGU9ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9hdHRyaWJ1dGVzW3RdLHRoaXMuZW1pdChcImF0dHJpYnV0ZXNVcGRhdGVkXCIse3R5cGU6XCJyZW1vdmVcIixhdHRyaWJ1dGVzOnRoaXMuX2F0dHJpYnV0ZXMsbmFtZTp0fSksdGhpc30saS5yZXBsYWNlQXR0cmlidXRlcz1mdW5jdGlvbih0KXtpZighaCh0KSl0aHJvdyBuZXcgRihcIkdyYXBoLnJlcGxhY2VBdHRyaWJ1dGVzOiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXCIpO3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzPXQsdGhpcy5lbWl0KFwiYXR0cmlidXRlc1VwZGF0ZWRcIix7dHlwZTpcInJlcGxhY2VcIixhdHRyaWJ1dGVzOnRoaXMuX2F0dHJpYnV0ZXN9KSx0aGlzfSxpLm1lcmdlQXR0cmlidXRlcz1mdW5jdGlvbih0KXtpZighaCh0KSl0aHJvdyBuZXcgRihcIkdyYXBoLm1lcmdlQXR0cmlidXRlczogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LlwiKTtyZXR1cm4gYyh0aGlzLl9hdHRyaWJ1dGVzLHQpLHRoaXMuZW1pdChcImF0dHJpYnV0ZXNVcGRhdGVkXCIse3R5cGU6XCJtZXJnZVwiLGF0dHJpYnV0ZXM6dGhpcy5fYXR0cmlidXRlcyxkYXRhOnR9KSx0aGlzfSxpLnVwZGF0ZUF0dHJpYnV0ZXM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRihcIkdyYXBoLnVwZGF0ZUF0dHJpYnV0ZXM6IHByb3ZpZGVkIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uXCIpO3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzPXQodGhpcy5fYXR0cmlidXRlcyksdGhpcy5lbWl0KFwiYXR0cmlidXRlc1VwZGF0ZWRcIix7dHlwZTpcInVwZGF0ZVwiLGF0dHJpYnV0ZXM6dGhpcy5fYXR0cmlidXRlc30pLHRoaXN9LGkudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRihcIkdyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlczogZXhwZWN0aW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXCIpO2lmKGUmJiFnKGUpKXRocm93IG5ldyBGKFwiR3JhcGgudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzOiBpbnZhbGlkIGhpbnRzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGhhdmluZyB0aGUgZm9sbG93aW5nIHNoYXBlOiB7YXR0cmlidXRlcz86IFtzdHJpbmddfVwiKTtmb3IodmFyIG4scixpPXRoaXMuX25vZGVzLnZhbHVlcygpOyEwIT09KG49aS5uZXh0KCkpLmRvbmU7KShyPW4udmFsdWUpLmF0dHJpYnV0ZXM9dChyLmtleSxyLmF0dHJpYnV0ZXMpO3RoaXMuZW1pdChcImVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRcIix7aGludHM6ZXx8bnVsbH0pfSxpLnVwZGF0ZUVhY2hFZGdlQXR0cmlidXRlcz1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEYoXCJHcmFwaC51cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXM6IGV4cGVjdGluZyBhbiB1cGRhdGVyIGZ1bmN0aW9uLlwiKTtpZihlJiYhZyhlKSl0aHJvdyBuZXcgRihcIkdyYXBoLnVwZGF0ZUVhY2hFZGdlQXR0cmlidXRlczogaW52YWxpZCBoaW50cy4gRXhwZWN0aW5nIGFuIG9iamVjdCBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaGFwZToge2F0dHJpYnV0ZXM/OiBbc3RyaW5nXX1cIik7Zm9yKHZhciBuLHIsaSxvLGE9dGhpcy5fZWRnZXMudmFsdWVzKCk7ITAhPT0obj1hLm5leHQoKSkuZG9uZTspaT0ocj1uLnZhbHVlKS5zb3VyY2Usbz1yLnRhcmdldCxyLmF0dHJpYnV0ZXM9dChyLmtleSxyLmF0dHJpYnV0ZXMsaS5rZXksby5rZXksaS5hdHRyaWJ1dGVzLG8uYXR0cmlidXRlcyxyLnVuZGlyZWN0ZWQpO3RoaXMuZW1pdChcImVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRcIix7aGludHM6ZXx8bnVsbH0pfSxpLmZvckVhY2hBZGphY2VuY3lFbnRyeT1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZm9yRWFjaEFkamFjZW5jeUVudHJ5OiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7RXQoITEsITEsITEsdGhpcyx0KX0saS5mb3JFYWNoQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFucz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZm9yRWFjaEFkamFjZW5jeUVudHJ5V2l0aE9ycGhhbnM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLlwiKTtFdCghMSwhMSwhMCx0aGlzLHQpfSxpLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnk9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRihcIkdyYXBoLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnk6IGV4cGVjdGluZyBhIGNhbGxiYWNrLlwiKTtFdCghMSwhMCwhMSx0aGlzLHQpfSxpLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFucz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zOiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7RXQoITEsITAsITAsdGhpcyx0KX0saS5ub2Rlcz1mdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5LmZyb20/QXJyYXkuZnJvbSh0aGlzLl9ub2Rlcy5rZXlzKCkpOlQodGhpcy5fbm9kZXMua2V5cygpLHRoaXMuX25vZGVzLnNpemUpfSxpLmZvckVhY2hOb2RlPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEYoXCJHcmFwaC5mb3JFYWNoTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suXCIpO2Zvcih2YXIgZSxuLHI9dGhpcy5fbm9kZXMudmFsdWVzKCk7ITAhPT0oZT1yLm5leHQoKSkuZG9uZTspdCgobj1lLnZhbHVlKS5rZXksbi5hdHRyaWJ1dGVzKX0saS5maW5kTm9kZT1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZmluZE5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLlwiKTtmb3IodmFyIGUsbixyPXRoaXMuX25vZGVzLnZhbHVlcygpOyEwIT09KGU9ci5uZXh0KCkpLmRvbmU7KWlmKHQoKG49ZS52YWx1ZSkua2V5LG4uYXR0cmlidXRlcykpcmV0dXJuIG4ua2V5fSxpLm1hcE5vZGVzPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEYoXCJHcmFwaC5tYXBOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7Zm9yKHZhciBlLG4scj10aGlzLl9ub2Rlcy52YWx1ZXMoKSxpPW5ldyBBcnJheSh0aGlzLm9yZGVyKSxvPTA7ITAhPT0oZT1yLm5leHQoKSkuZG9uZTspbj1lLnZhbHVlLGlbbysrXT10KG4ua2V5LG4uYXR0cmlidXRlcyk7cmV0dXJuIGl9LGkuc29tZU5vZGU9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgRihcIkdyYXBoLnNvbWVOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7Zm9yKHZhciBlLG4scj10aGlzLl9ub2Rlcy52YWx1ZXMoKTshMCE9PShlPXIubmV4dCgpKS5kb25lOylpZih0KChuPWUudmFsdWUpLmtleSxuLmF0dHJpYnV0ZXMpKXJldHVybiEwO3JldHVybiExfSxpLmV2ZXJ5Tm9kZT1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZXZlcnlOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7Zm9yKHZhciBlLG4scj10aGlzLl9ub2Rlcy52YWx1ZXMoKTshMCE9PShlPXIubmV4dCgpKS5kb25lOylpZighdCgobj1lLnZhbHVlKS5rZXksbi5hdHRyaWJ1dGVzKSlyZXR1cm4hMTtyZXR1cm4hMH0saS5maWx0ZXJOb2Rlcz1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBGKFwiR3JhcGguZmlsdGVyTm9kZXM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLlwiKTtmb3IodmFyIGUsbixyPXRoaXMuX25vZGVzLnZhbHVlcygpLGk9W107ITAhPT0oZT1yLm5leHQoKSkuZG9uZTspdCgobj1lLnZhbHVlKS5rZXksbi5hdHRyaWJ1dGVzKSYmaS5wdXNoKG4ua2V5KTtyZXR1cm4gaX0saS5yZWR1Y2VOb2Rlcz1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEYoXCJHcmFwaC5yZWR1Y2VOb2RlczogZXhwZWN0aW5nIGEgY2FsbGJhY2suXCIpO2lmKGFyZ3VtZW50cy5sZW5ndGg8Mil0aHJvdyBuZXcgRihcIkdyYXBoLnJlZHVjZU5vZGVzOiBtaXNzaW5nIGluaXRpYWwgdmFsdWUuIFlvdSBtdXN0IHByb3ZpZGUgaXQgYmVjYXVzZSB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBhbmQgd2UgY2Fubm90IGluZmVyIHRoZSBpbml0aWFsIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYXMgeW91IGNvdWxkIHdpdGggYSBzaW1wbGUgYXJyYXkuXCIpO2Zvcih2YXIgbixyLGk9ZSxvPXRoaXMuX25vZGVzLnZhbHVlcygpOyEwIT09KG49by5uZXh0KCkpLmRvbmU7KWk9dChpLChyPW4udmFsdWUpLmtleSxyLmF0dHJpYnV0ZXMpO3JldHVybiBpfSxpLm5vZGVFbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbm9kZXMudmFsdWVzKCk7cmV0dXJuIG5ldyBPKChmdW5jdGlvbigpe3ZhciBlPXQubmV4dCgpO2lmKGUuZG9uZSlyZXR1cm4gZTt2YXIgbj1lLnZhbHVlO3JldHVybnt2YWx1ZTp7bm9kZTpuLmtleSxhdHRyaWJ1dGVzOm4uYXR0cmlidXRlc30sZG9uZTohMX19KSl9LGkuZXhwb3J0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEFycmF5KHRoaXMuX25vZGVzLnNpemUpLGU9MDt0aGlzLl9ub2Rlcy5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3RbZSsrXT1mdW5jdGlvbih0LGUpe3ZhciBuPXtrZXk6dH07cmV0dXJuIHAoZS5hdHRyaWJ1dGVzKXx8KG4uYXR0cmlidXRlcz1jKHt9LGUuYXR0cmlidXRlcykpLG59KHIsbil9KSk7dmFyIG49bmV3IEFycmF5KHRoaXMuX2VkZ2VzLnNpemUpO3JldHVybiBlPTAsdGhpcy5fZWRnZXMuZm9yRWFjaCgoZnVuY3Rpb24odCxyKXtuW2UrK109ZnVuY3Rpb24odCxlKXt2YXIgbj17a2V5OnQsc291cmNlOmUuc291cmNlLmtleSx0YXJnZXQ6ZS50YXJnZXQua2V5fTtyZXR1cm4gcChlLmF0dHJpYnV0ZXMpfHwobi5hdHRyaWJ1dGVzPWMoe30sZS5hdHRyaWJ1dGVzKSksZS51bmRpcmVjdGVkJiYobi51bmRpcmVjdGVkPSEwKSxufShyLHQpfSkpLHtvcHRpb25zOnt0eXBlOnRoaXMudHlwZSxtdWx0aTp0aGlzLm11bHRpLGFsbG93U2VsZkxvb3BzOnRoaXMuYWxsb3dTZWxmTG9vcHN9LGF0dHJpYnV0ZXM6dGhpcy5nZXRBdHRyaWJ1dGVzKCksbm9kZXM6dCxlZGdlczpufX0saS5pbXBvcnQ9ZnVuY3Rpb24odCl7dmFyIGUsbixyLGksbyxhPXRoaXMsdT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO2lmKGQodCkpcmV0dXJuIHQuZm9yRWFjaE5vZGUoKGZ1bmN0aW9uKHQsZSl7dT9hLm1lcmdlTm9kZSh0LGUpOmEuYWRkTm9kZSh0LGUpfSkpLHQuZm9yRWFjaEVkZ2UoKGZ1bmN0aW9uKHQsZSxuLHIsaSxvLGMpe3U/Yz9hLm1lcmdlVW5kaXJlY3RlZEVkZ2VXaXRoS2V5KHQsbixyLGUpOmEubWVyZ2VEaXJlY3RlZEVkZ2VXaXRoS2V5KHQsbixyLGUpOmM/YS5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXkodCxuLHIsZSk6YS5hZGREaXJlY3RlZEVkZ2VXaXRoS2V5KHQsbixyLGUpfSkpLHRoaXM7aWYoIWgodCkpdGhyb3cgbmV3IEYoXCJHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXJndW1lbnQuIEV4cGVjdGluZyBhIHNlcmlhbGl6ZWQgZ3JhcGggb3IsIGFsdGVybmF0aXZlbHksIGEgR3JhcGggaW5zdGFuY2UuXCIpO2lmKHQuYXR0cmlidXRlcyl7aWYoIWgodC5hdHRyaWJ1dGVzKSl0aHJvdyBuZXcgRihcIkdyYXBoLmltcG9ydDogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYSBwbGFpbiBvYmplY3QuXCIpO3U/dGhpcy5tZXJnZUF0dHJpYnV0ZXModC5hdHRyaWJ1dGVzKTp0aGlzLnJlcGxhY2VBdHRyaWJ1dGVzKHQuYXR0cmlidXRlcyl9aWYodC5ub2Rlcyl7aWYocj10Lm5vZGVzLCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBGKFwiR3JhcGguaW1wb3J0OiBpbnZhbGlkIG5vZGVzLiBFeHBlY3RpbmcgYW4gYXJyYXkuXCIpO2ZvcihlPTAsbj1yLmxlbmd0aDtlPG47ZSsrKXtBdChpPXJbZV0pO3ZhciBjPWkscz1jLmtleSxwPWMuYXR0cmlidXRlczt1P3RoaXMubWVyZ2VOb2RlKHMscCk6dGhpcy5hZGROb2RlKHMscCl9fWlmKHQuZWRnZXMpe2lmKHI9dC5lZGdlcywhQXJyYXkuaXNBcnJheShyKSl0aHJvdyBuZXcgRihcIkdyYXBoLmltcG9ydDogaW52YWxpZCBlZGdlcy4gRXhwZWN0aW5nIGFuIGFycmF5LlwiKTtmb3IoZT0wLG49ci5sZW5ndGg7ZTxuO2UrKyl7U3Qobz1yW2VdKTt2YXIgZj1vLGw9Zi5zb3VyY2UsZz1mLnRhcmdldCx5PWYuYXR0cmlidXRlcyx3PWYudW5kaXJlY3RlZCx2PXZvaWQgMCE9PXcmJnc7XCJrZXlcImluIG8/KHU/dj90aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VXaXRoS2V5OnRoaXMubWVyZ2VEaXJlY3RlZEVkZ2VXaXRoS2V5OnY/dGhpcy5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXk6dGhpcy5hZGREaXJlY3RlZEVkZ2VXaXRoS2V5KS5jYWxsKHRoaXMsby5rZXksbCxnLHkpOih1P3Y/dGhpcy5tZXJnZVVuZGlyZWN0ZWRFZGdlOnRoaXMubWVyZ2VEaXJlY3RlZEVkZ2U6dj90aGlzLmFkZFVuZGlyZWN0ZWRFZGdlOnRoaXMuYWRkRGlyZWN0ZWRFZGdlKS5jYWxsKHRoaXMsbCxnLHkpfX1yZXR1cm4gdGhpc30saS5udWxsQ29weT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgcihjKHt9LHRoaXMuX29wdGlvbnMsdCkpO3JldHVybiBlLnJlcGxhY2VBdHRyaWJ1dGVzKGMoe30sdGhpcy5nZXRBdHRyaWJ1dGVzKCkpKSxlfSxpLmVtcHR5Q29weT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm51bGxDb3B5KHQpO3JldHVybiB0aGlzLl9ub2Rlcy5mb3JFYWNoKChmdW5jdGlvbih0LG4pe3ZhciByPWMoe30sdC5hdHRyaWJ1dGVzKTt0PW5ldyBlLk5vZGVEYXRhQ2xhc3MobixyKSxlLl9ub2Rlcy5zZXQobix0KX0pKSxlfSxpLmNvcHk9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mKHQ9dHx8e30pLnR5cGUmJnQudHlwZSE9PXRoaXMudHlwZSYmXCJtaXhlZFwiIT09dC50eXBlKXRocm93IG5ldyBZKCdHcmFwaC5jb3B5OiBjYW5ub3QgY3JlYXRlIGFuIGluY29tcGF0aWJsZSBjb3B5IGZyb20gXCInLmNvbmNhdCh0aGlzLnR5cGUsJ1wiIHR5cGUgdG8gXCInKS5jb25jYXQodC50eXBlLCdcIiBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguJykpO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgdC5tdWx0aSYmdC5tdWx0aSE9PXRoaXMubXVsdGkmJiEwIT09dC5tdWx0aSl0aHJvdyBuZXcgWShcIkdyYXBoLmNvcHk6IGNhbm5vdCBjcmVhdGUgYW4gaW5jb21wYXRpYmxlIGNvcHkgYnkgZG93bmdyYWRpbmcgYSBtdWx0aSBncmFwaCB0byBhIHNpbXBsZSBvbmUgYmVjYXVzZSB0aGlzIHdvdWxkIG1lYW4gbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGdyYXBoLlwiKTtpZihcImJvb2xlYW5cIj09dHlwZW9mIHQuYWxsb3dTZWxmTG9vcHMmJnQuYWxsb3dTZWxmTG9vcHMhPT10aGlzLmFsbG93U2VsZkxvb3BzJiYhMCE9PXQuYWxsb3dTZWxmTG9vcHMpdGhyb3cgbmV3IFkoXCJHcmFwaC5jb3B5OiBjYW5ub3QgY3JlYXRlIGFuIGluY29tcGF0aWJsZSBjb3B5IGZyb20gYSBncmFwaCBhbGxvd2luZyBzZWxmIGxvb3BzIHRvIG9uZSB0aGF0IGRvZXMgbm90IGJlY2F1c2UgdGhpcyB3b3VsZCBtZWFuIGxvc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBncmFwaC5cIik7Zm9yKHZhciBlLG4scj10aGlzLmVtcHR5Q29weSh0KSxpPXRoaXMuX2VkZ2VzLnZhbHVlcygpOyEwIT09KGU9aS5uZXh0KCkpLmRvbmU7KUN0KHIsXCJjb3B5XCIsITEsKG49ZS52YWx1ZSkudW5kaXJlY3RlZCxuLmtleSxuLnNvdXJjZS5rZXksbi50YXJnZXQua2V5LGMoe30sbi5hdHRyaWJ1dGVzKSk7cmV0dXJuIHJ9LGkudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhwb3J0KCl9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgR3JhcGhdXCJ9LGkuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBlPXRoaXMsbj17fTt0aGlzLl9ub2Rlcy5mb3JFYWNoKChmdW5jdGlvbih0LGUpe25bZV09dC5hdHRyaWJ1dGVzfSkpO3ZhciByPXt9LGk9e307dGhpcy5fZWRnZXMuZm9yRWFjaCgoZnVuY3Rpb24odCxuKXt2YXIgbyxhPXQudW5kaXJlY3RlZD9cIi0tXCI6XCItPlwiLHU9XCJcIixjPXQuc291cmNlLmtleSxzPXQudGFyZ2V0LmtleTt0LnVuZGlyZWN0ZWQmJmM+cyYmKG89YyxjPXMscz1vKTt2YXIgZD1cIihcIi5jb25jYXQoYyxcIilcIikuY29uY2F0KGEsXCIoXCIpLmNvbmNhdChzLFwiKVwiKTtuLnN0YXJ0c1dpdGgoXCJnZWlkX1wiKT9lLm11bHRpJiYodm9pZCAwPT09aVtkXT9pW2RdPTA6aVtkXSsrLHUrPVwiXCIuY29uY2F0KGlbZF0sXCIuIFwiKSk6dSs9XCJbXCIuY29uY2F0KG4sXCJdOiBcIiksclt1Kz1kXT10LmF0dHJpYnV0ZXN9KSk7dmFyIG89e307Zm9yKHZhciBhIGluIHRoaXMpdGhpcy5oYXNPd25Qcm9wZXJ0eShhKSYmIU50LmhhcyhhKSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdGhpc1thXSYmXCJzeW1ib2xcIiE9PXQoYSkmJihvW2FdPXRoaXNbYV0pO3JldHVybiBvLmF0dHJpYnV0ZXM9dGhpcy5fYXR0cmlidXRlcyxvLm5vZGVzPW4sby5lZGdlcz1yLGYobyxcImNvbnN0cnVjdG9yXCIsdGhpcy5jb25zdHJ1Y3Rvciksb30scn0ody5leHBvcnRzLkV2ZW50RW1pdHRlcik7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmKFd0LnByb3RvdHlwZVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildPVd0LnByb3RvdHlwZS5pbnNwZWN0KSxbe25hbWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJcIi5jb25jYXQodCxcIkVkZ2VcIil9LGdlbmVyYXRlS2V5OiEwfSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cIlwiLmNvbmNhdCh0LFwiRGlyZWN0ZWRFZGdlXCIpfSxnZW5lcmF0ZUtleTohMCx0eXBlOlwiZGlyZWN0ZWRcIn0se25hbWU6ZnVuY3Rpb24odCl7cmV0dXJuXCJcIi5jb25jYXQodCxcIlVuZGlyZWN0ZWRFZGdlXCIpfSxnZW5lcmF0ZUtleTohMCx0eXBlOlwidW5kaXJlY3RlZFwifSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cIlwiLmNvbmNhdCh0LFwiRWRnZVdpdGhLZXlcIil9fSx7bmFtZTpmdW5jdGlvbih0KXtyZXR1cm5cIlwiLmNvbmNhdCh0LFwiRGlyZWN0ZWRFZGdlV2l0aEtleVwiKX0sdHlwZTpcImRpcmVjdGVkXCJ9LHtuYW1lOmZ1bmN0aW9uKHQpe3JldHVyblwiXCIuY29uY2F0KHQsXCJVbmRpcmVjdGVkRWRnZVdpdGhLZXlcIil9LHR5cGU6XCJ1bmRpcmVjdGVkXCJ9XS5mb3JFYWNoKChmdW5jdGlvbih0KXtbXCJhZGRcIixcIm1lcmdlXCIsXCJ1cGRhdGVcIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49dC5uYW1lKGUpLHI9XCJhZGRcIj09PWU/Q3Q6enQ7dC5nZW5lcmF0ZUtleT9XdC5wcm90b3R5cGVbbl09ZnVuY3Rpb24oaSxvLGEpe3JldHVybiByKHRoaXMsbiwhMCxcInVuZGlyZWN0ZWRcIj09PSh0LnR5cGV8fHRoaXMudHlwZSksbnVsbCxpLG8sYSxcInVwZGF0ZVwiPT09ZSl9Old0LnByb3RvdHlwZVtuXT1mdW5jdGlvbihpLG8sYSx1KXtyZXR1cm4gcih0aGlzLG4sITEsXCJ1bmRpcmVjdGVkXCI9PT0odC50eXBlfHx0aGlzLnR5cGUpLGksbyxhLHUsXCJ1cGRhdGVcIj09PWUpfX0pKX0pKSxmdW5jdGlvbih0KXtYLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUubmFtZSxyPWUuYXR0YWNoZXI7cih0LG4oXCJOb2RlXCIpLDApLHIodCxuKFwiU291cmNlXCIpLDEpLHIodCxuKFwiVGFyZ2V0XCIpLDIpLHIodCxuKFwiT3Bwb3NpdGVcIiksMyl9KSl9KFd0KSxmdW5jdGlvbih0KXtaLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUubmFtZSxyPWUuYXR0YWNoZXI7cih0LG4oXCJFZGdlXCIpLFwibWl4ZWRcIikscih0LG4oXCJEaXJlY3RlZEVkZ2VcIiksXCJkaXJlY3RlZFwiKSxyKHQsbihcIlVuZGlyZWN0ZWRFZGdlXCIpLFwidW5kaXJlY3RlZFwiKX0pKX0oV3QpLGZ1bmN0aW9uKHQpe250LmZvckVhY2goKGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0LGUpe3ZhciBuPWUubmFtZSxyPWUudHlwZSxpPWUuZGlyZWN0aW9uO3QucHJvdG90eXBlW25dPWZ1bmN0aW9uKHQsZSl7aWYoXCJtaXhlZFwiIT09ciYmXCJtaXhlZFwiIT09dGhpcy50eXBlJiZyIT09dGhpcy50eXBlKXJldHVybltdO2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiBzdCh0aGlzLHIpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt0PVwiXCIrdDt2YXIgbz10aGlzLl9ub2Rlcy5nZXQodCk7aWYodm9pZCAwPT09byl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChuLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIGZ0KHRoaXMubXVsdGksXCJtaXhlZFwiPT09cj90aGlzLnR5cGU6cixpLG8pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgYT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQobiwnOiAgY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoIXRoaXMuX25vZGVzLmhhcyhlKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChuLCc6ICBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQoZSwnXCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm4geXQocix0aGlzLm11bHRpLGksYSxlKX10aHJvdyBuZXcgRihcIkdyYXBoLlwiLmNvbmNhdChuLFwiOiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAwLCAxIG9yIDIgYW5kIGdvdCBcIikuY29uY2F0KGFyZ3VtZW50cy5sZW5ndGgsXCIpLlwiKSl9fSh0LGUpLGZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5uYW1lLHI9ZS50eXBlLGk9ZS5kaXJlY3Rpb24sbz1cImZvckVhY2hcIituWzBdLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxLC0xKTt0LnByb3RvdHlwZVtvXT1mdW5jdGlvbih0LGUsbil7aWYoXCJtaXhlZFwiPT09cnx8XCJtaXhlZFwiPT09dGhpcy50eXBlfHxyPT09dGhpcy50eXBlKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZHQoITEsdGhpcyxyLG49dCk7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3Q9XCJcIit0LG49ZTt2YXIgYT10aGlzLl9ub2Rlcy5nZXQodCk7aWYodm9pZCAwPT09YSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChvLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7cmV0dXJuIHB0KCExLHRoaXMubXVsdGksXCJtaXhlZFwiPT09cj90aGlzLnR5cGU6cixpLGEsbil9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3Q9XCJcIit0LGU9XCJcIitlO3ZhciB1PXRoaXMuX25vZGVzLmdldCh0KTtpZighdSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChvLCc6ICBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLicpKTtpZighdGhpcy5fbm9kZXMuaGFzKGUpKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KG8sJzogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdChlLCdcIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiBndCghMSxyLHRoaXMubXVsdGksaSx1LGUsbil9dGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQobyxcIjogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMSwgMiBvciAzIGFuZCBnb3QgXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoLFwiKS5cIikpfX07dmFyIGE9XCJtYXBcIituWzBdLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKTt0LnByb3RvdHlwZVthXT1mdW5jdGlvbigpe3ZhciB0LGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPWUucG9wKCk7aWYoMD09PWUubGVuZ3RoKXt2YXIgaT0wO1wiZGlyZWN0ZWRcIiE9PXImJihpKz10aGlzLnVuZGlyZWN0ZWRTaXplKSxcInVuZGlyZWN0ZWRcIiE9PXImJihpKz10aGlzLmRpcmVjdGVkU2l6ZSksdD1uZXcgQXJyYXkoaSk7dmFyIGE9MDtlLnB1c2goKGZ1bmN0aW9uKGUscixpLG8sdSxjLHMpe3RbYSsrXT1uKGUscixpLG8sdSxjLHMpfSkpfWVsc2UgdD1bXSxlLnB1c2goKGZ1bmN0aW9uKGUscixpLG8sYSx1LGMpe3QucHVzaChuKGUscixpLG8sYSx1LGMpKX0pKTtyZXR1cm4gdGhpc1tvXS5hcHBseSh0aGlzLGUpLHR9O3ZhciB1PVwiZmlsdGVyXCIrblswXS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSk7dC5wcm90b3R5cGVbdV09ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGU9dC5wb3AoKSxuPVtdO3JldHVybiB0LnB1c2goKGZ1bmN0aW9uKHQscixpLG8sYSx1LGMpe2UodCxyLGksbyxhLHUsYykmJm4ucHVzaCh0KX0pKSx0aGlzW29dLmFwcGx5KHRoaXMsdCksbn07dmFyIGM9XCJyZWR1Y2VcIituWzBdLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKTt0LnByb3RvdHlwZVtjXT1mdW5jdGlvbigpe3ZhciB0LGUsbj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO2lmKG4ubGVuZ3RoPDJ8fG4ubGVuZ3RoPjQpdGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQoYyxcIjogaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIChleHBlY3RpbmcgMiwgMyBvciA0IGFuZCBnb3QgXCIpLmNvbmNhdChuLmxlbmd0aCxcIikuXCIpKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuW24ubGVuZ3RoLTFdJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBuW24ubGVuZ3RoLTJdKXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KGMsXCI6IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS5cIikpOzI9PT1uLmxlbmd0aD8odD1uWzBdLGU9blsxXSxuPVtdKTozPT09bi5sZW5ndGg/KHQ9blsxXSxlPW5bMl0sbj1bblswXV0pOjQ9PT1uLmxlbmd0aCYmKHQ9blsyXSxlPW5bM10sbj1bblswXSxuWzFdXSk7dmFyIHI9ZTtyZXR1cm4gbi5wdXNoKChmdW5jdGlvbihlLG4saSxvLGEsdSxjKXtyPXQocixlLG4saSxvLGEsdSxjKX0pKSx0aGlzW29dLmFwcGx5KHRoaXMsbikscn19KHQsZSksZnVuY3Rpb24odCxlKXt2YXIgbj1lLm5hbWUscj1lLnR5cGUsaT1lLmRpcmVjdGlvbixvPVwiZmluZFwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEsLTEpO3QucHJvdG90eXBlW29dPWZ1bmN0aW9uKHQsZSxuKXtpZihcIm1peGVkXCIhPT1yJiZcIm1peGVkXCIhPT10aGlzLnR5cGUmJnIhPT10aGlzLnR5cGUpcmV0dXJuITE7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGR0KCEwLHRoaXMscixuPXQpO2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt0PVwiXCIrdCxuPWU7dmFyIGE9dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQobywnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiBwdCghMCx0aGlzLm11bHRpLFwibWl4ZWRcIj09PXI/dGhpcy50eXBlOnIsaSxhLG4pfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgdT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIXUpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQobywnOiAgY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoIXRoaXMuX25vZGVzLmhhcyhlKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChvLCc6ICBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQoZSwnXCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm4gZ3QoITAscix0aGlzLm11bHRpLGksdSxlLG4pfXRocm93IG5ldyBGKFwiR3JhcGguXCIuY29uY2F0KG8sXCI6IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDEsIDIgb3IgMyBhbmQgZ290IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCxcIikuXCIpKX07dmFyIGE9XCJzb21lXCIrblswXS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSwtMSk7dC5wcm90b3R5cGVbYV09ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGU9dC5wb3AoKTtyZXR1cm4gdC5wdXNoKChmdW5jdGlvbih0LG4scixpLG8sYSx1KXtyZXR1cm4gZSh0LG4scixpLG8sYSx1KX0pKSwhIXRoaXNbb10uYXBwbHkodGhpcyx0KX07dmFyIHU9XCJldmVyeVwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEsLTEpO3QucHJvdG90eXBlW3VdPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxlPXQucG9wKCk7cmV0dXJuIHQucHVzaCgoZnVuY3Rpb24odCxuLHIsaSxvLGEsdSl7cmV0dXJuIWUodCxuLHIsaSxvLGEsdSl9KSksIXRoaXNbb10uYXBwbHkodGhpcyx0KX19KHQsZSksZnVuY3Rpb24odCxlKXt2YXIgbj1lLm5hbWUscj1lLnR5cGUsaT1lLmRpcmVjdGlvbixvPW4uc2xpY2UoMCwtMSkrXCJFbnRyaWVzXCI7dC5wcm90b3R5cGVbb109ZnVuY3Rpb24odCxlKXtpZihcIm1peGVkXCIhPT1yJiZcIm1peGVkXCIhPT10aGlzLnR5cGUmJnIhPT10aGlzLnR5cGUpcmV0dXJuIE8uZW1wdHkoKTtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaHQodGhpcyxyKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dD1cIlwiK3Q7dmFyIG49dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBJKFwiR3JhcGguXCIuY29uY2F0KG8sJzogY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIG5vZGUgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm4gbHQocixpLG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt0PVwiXCIrdCxlPVwiXCIrZTt2YXIgYT10aGlzLl9ub2Rlcy5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQobywnOiAgY291bGQgbm90IGZpbmQgdGhlIFwiJykuY29uY2F0KHQsJ1wiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC4nKSk7aWYoIXRoaXMuX25vZGVzLmhhcyhlKSl0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChvLCc6ICBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQoZSwnXCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLicpKTtyZXR1cm4gd3QocixpLGEsZSl9dGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQobyxcIjogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMCwgMSBvciAyIGFuZCBnb3QgXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoLFwiKS5cIikpfX0odCxlKX0pKX0oV3QpLGZ1bmN0aW9uKHQpe3Z0LmZvckVhY2goKGZ1bmN0aW9uKGUpe0d0KHQsZSksZnVuY3Rpb24odCxlKXt2YXIgbj1lLm5hbWUscj1lLnR5cGUsaT1lLmRpcmVjdGlvbixvPVwiZm9yRWFjaFwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEsLTEpO3QucHJvdG90eXBlW29dPWZ1bmN0aW9uKHQsZSl7aWYoXCJtaXhlZFwiPT09cnx8XCJtaXhlZFwiPT09dGhpcy50eXBlfHxyPT09dGhpcy50eXBlKXt0PVwiXCIrdDt2YXIgbj10aGlzLl9ub2Rlcy5nZXQodCk7aWYodm9pZCAwPT09bil0aHJvdyBuZXcgSShcIkdyYXBoLlwiLmNvbmNhdChvLCc6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIicpLmNvbmNhdCh0LCdcIiBub2RlIGluIHRoZSBncmFwaC4nKSk7a3QoITEsXCJtaXhlZFwiPT09cj90aGlzLnR5cGU6cixpLG4sZSl9fTt2YXIgYT1cIm1hcFwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEpO3QucHJvdG90eXBlW2FdPWZ1bmN0aW9uKHQsZSl7dmFyIG49W107cmV0dXJuIHRoaXNbb10odCwoZnVuY3Rpb24odCxyKXtuLnB1c2goZSh0LHIpKX0pKSxufTt2YXIgdT1cImZpbHRlclwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEpO3QucHJvdG90eXBlW3VdPWZ1bmN0aW9uKHQsZSl7dmFyIG49W107cmV0dXJuIHRoaXNbb10odCwoZnVuY3Rpb24odCxyKXtlKHQscikmJm4ucHVzaCh0KX0pKSxufTt2YXIgYz1cInJlZHVjZVwiK25bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEpO3QucHJvdG90eXBlW2NdPWZ1bmN0aW9uKHQsZSxuKXtpZihhcmd1bWVudHMubGVuZ3RoPDMpdGhyb3cgbmV3IEYoXCJHcmFwaC5cIi5jb25jYXQoYyxcIjogbWlzc2luZyBpbml0aWFsIHZhbHVlLiBZb3UgbXVzdCBwcm92aWRlIGl0IGJlY2F1c2UgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgYW5kIHdlIGNhbm5vdCBpbmZlciB0aGUgaW5pdGlhbCB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVyYXRpb24sIGFzIHlvdSBjb3VsZCB3aXRoIGEgc2ltcGxlIGFycmF5LlwiKSk7dmFyIHI9bjtyZXR1cm4gdGhpc1tvXSh0LChmdW5jdGlvbih0LG4pe3I9ZShyLHQsbil9KSkscn19KHQsZSksZnVuY3Rpb24odCxlKXt2YXIgbj1lLm5hbWUscj1lLnR5cGUsaT1lLmRpcmVjdGlvbixvPW5bMF0udG9VcHBlckNhc2UoKStuLnNsaWNlKDEsLTEpLGE9XCJmaW5kXCIrbzt0LnByb3RvdHlwZVthXT1mdW5jdGlvbih0LGUpe2lmKFwibWl4ZWRcIj09PXJ8fFwibWl4ZWRcIj09PXRoaXMudHlwZXx8cj09PXRoaXMudHlwZSl7dD1cIlwiK3Q7dmFyIG49dGhpcy5fbm9kZXMuZ2V0KHQpO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IEkoXCJHcmFwaC5cIi5jb25jYXQoYSwnOiBjb3VsZCBub3QgZmluZCB0aGUgXCInKS5jb25jYXQodCwnXCIgbm9kZSBpbiB0aGUgZ3JhcGguJykpO3JldHVybiBrdCghMCxcIm1peGVkXCI9PT1yP3RoaXMudHlwZTpyLGksbixlKX19O3ZhciB1PVwic29tZVwiK287dC5wcm90b3R5cGVbdV09ZnVuY3Rpb24odCxlKXtyZXR1cm4hIXRoaXNbYV0odCxlKX07dmFyIGM9XCJldmVyeVwiK287dC5wcm90b3R5cGVbY109ZnVuY3Rpb24odCxlKXtyZXR1cm4hdGhpc1thXSh0LChmdW5jdGlvbih0LG4pe3JldHVybiFlKHQsbil9KSl9fSh0LGUpLHh0KHQsZSl9KSl9KFd0KTt2YXIgUHQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlKXt2YXIgbj1jKHt0eXBlOlwiZGlyZWN0ZWRcIn0sZSk7aWYoXCJtdWx0aVwiaW4gbiYmITEhPT1uLm11bHRpKXRocm93IG5ldyBGKFwiRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgbXVsdGkgaW4gZ2l2ZW4gb3B0aW9ucyFcIik7aWYoXCJkaXJlY3RlZFwiIT09bi50eXBlKXRocm93IG5ldyBGKCdEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicrbi50eXBlKydcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJyk7cmV0dXJuIHQuY2FsbCh0aGlzLG4pfHx0aGlzfXJldHVybiBlKG4sdCksbn0oV3QpLFJ0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7dmFyIG49Yyh7dHlwZTpcInVuZGlyZWN0ZWRcIn0sZSk7aWYoXCJtdWx0aVwiaW4gbiYmITEhPT1uLm11bHRpKXRocm93IG5ldyBGKFwiVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBtdWx0aSBpbiBnaXZlbiBvcHRpb25zIVwiKTtpZihcInVuZGlyZWN0ZWRcIiE9PW4udHlwZSl0aHJvdyBuZXcgRignVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicrbi50eXBlKydcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJyk7cmV0dXJuIHQuY2FsbCh0aGlzLG4pfHx0aGlzfXJldHVybiBlKG4sdCksbn0oV3QpLEt0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7dmFyIG49Yyh7bXVsdGk6ITB9LGUpO2lmKFwibXVsdGlcImluIG4mJiEwIT09bi5tdWx0aSl0aHJvdyBuZXcgRihcIk11bHRpR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIHNpbXBsZSBpbiBnaXZlbiBvcHRpb25zIVwiKTtyZXR1cm4gdC5jYWxsKHRoaXMsbil8fHRoaXN9cmV0dXJuIGUobix0KSxufShXdCksVHQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlKXt2YXIgbj1jKHt0eXBlOlwiZGlyZWN0ZWRcIixtdWx0aTohMH0sZSk7aWYoXCJtdWx0aVwiaW4gbiYmITAhPT1uLm11bHRpKXRocm93IG5ldyBGKFwiTXVsdGlEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBzaW1wbGUgaW4gZ2l2ZW4gb3B0aW9ucyFcIik7aWYoXCJkaXJlY3RlZFwiIT09bi50eXBlKXRocm93IG5ldyBGKCdNdWx0aURpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJytuLnR5cGUrJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnKTtyZXR1cm4gdC5jYWxsKHRoaXMsbil8fHRoaXN9cmV0dXJuIGUobix0KSxufShXdCksQnQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlKXt2YXIgbj1jKHt0eXBlOlwidW5kaXJlY3RlZFwiLG11bHRpOiEwfSxlKTtpZihcIm11bHRpXCJpbiBuJiYhMCE9PW4ubXVsdGkpdGhyb3cgbmV3IEYoXCJNdWx0aVVuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhXCIpO2lmKFwidW5kaXJlY3RlZFwiIT09bi50eXBlKXRocm93IG5ldyBGKCdNdWx0aVVuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInK24udHlwZSsnXCIgdHlwZSBpbiBnaXZlbiBvcHRpb25zIScpO3JldHVybiB0LmNhbGwodGhpcyxuKXx8dGhpc31yZXR1cm4gZShuLHQpLG59KFd0KTtmdW5jdGlvbiBGdCh0KXt0LmZyb209ZnVuY3Rpb24oZSxuKXt2YXIgcj1jKHt9LGUub3B0aW9ucyxuKSxpPW5ldyB0KHIpO3JldHVybiBpLmltcG9ydChlKSxpfX1yZXR1cm4gRnQoV3QpLEZ0KFB0KSxGdChSdCksRnQoS3QpLEZ0KFR0KSxGdChCdCksV3QuR3JhcGg9V3QsV3QuRGlyZWN0ZWRHcmFwaD1QdCxXdC5VbmRpcmVjdGVkR3JhcGg9UnQsV3QuTXVsdGlHcmFwaD1LdCxXdC5NdWx0aURpcmVjdGVkR3JhcGg9VHQsV3QuTXVsdGlVbmRpcmVjdGVkR3JhcGg9QnQsV3QuSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3I9RixXdC5Ob3RGb3VuZEdyYXBoRXJyb3I9SSxXdC5Vc2FnZUdyYXBoRXJyb3I9WSxXdH0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBob2xvZ3kudW1kLm1pbi5qcy5tYXBcbiIsIi8qKlxuICogUGFuZGVtb25pdW0gUmFuZG9tXG4gKiA9PT09PT09PT09PT09PT09PT09XG4gKlxuICogUmFuZG9tIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQ3JlYXRpbmcgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSByYW5kb20gaW50ZWdlciBzdWNoIGFzIGEgPD0gTiA8PSBiLlxuICpcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBybmcgLSBSTkcgZnVuY3Rpb24gcmV0dXJuaW5nIHVuaWZvcm0gcmFuZG9tLlxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAtIFRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5kb20ocm5nKSB7XG5cbiAgLyoqXG4gICAqIFJhbmRvbSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBhIC0gRnJvbS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBiIC0gVG8uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBNYXRoLmZsb29yKHJuZygpICogKGIgLSBhICsgMSkpO1xuICB9O1xufVxuXG4vKipcbiAqIERlZmF1bHQgcmFuZG9tIHVzaW5nIGBNYXRoLnJhbmRvbWAuXG4gKi9cbnZhciByYW5kb20gPSBjcmVhdGVSYW5kb20oTWF0aC5yYW5kb20pO1xuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xucmFuZG9tLmNyZWF0ZVJhbmRvbSA9IGNyZWF0ZVJhbmRvbTtcbm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuIiwiLyoqXG4gKiBQYW5kZW1vbml1bSBTaHVmZmxlIEluIFBsYWNlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFNodWZmbGUgZnVuY3Rpb24gYXBwbHlpbmcgdGhlIEZpc2hlci1ZYXRlcyBhbGdvcml0aG0gdG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICovXG52YXIgY3JlYXRlUmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20uanMnKS5jcmVhdGVSYW5kb207XG5cbi8qKlxuICogQ3JlYXRpbmcgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGdpdmVuIGFycmF5IHNodWZmbGVkLlxuICpcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBybmcgLSBUaGUgUk5HIHRvIHVzZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgLSBUaGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2h1ZmZsZUluUGxhY2Uocm5nKSB7XG4gIHZhciBjdXN0b21SYW5kb20gPSBjcmVhdGVSYW5kb20ocm5nKTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzaHVmZmxlZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBzZXF1ZW5jZSAtIFRhcmdldCBzZXF1ZW5jZS5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAtIFRoZSBzaHVmZmxlZCBzZXF1ZW5jZS5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbihzZXF1ZW5jZSkge1xuICAgIHZhciBsZW5ndGggPSBzZXF1ZW5jZS5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgciA9IGN1c3RvbVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICB2YWx1ZSA9IHNlcXVlbmNlW3JdO1xuXG4gICAgICBzZXF1ZW5jZVtyXSA9IHNlcXVlbmNlW2luZGV4XTtcbiAgICAgIHNlcXVlbmNlW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHNodWZmbGUgaW4gcGxhY2UgdXNpbmcgYE1hdGgucmFuZG9tYC5cbiAqL1xudmFyIHNodWZmbGVJblBsYWNlID0gY3JlYXRlU2h1ZmZsZUluUGxhY2UoTWF0aC5yYW5kb20pO1xuXG4vKipcbiAqIEV4cG9ydGluZy5cbiAqL1xuc2h1ZmZsZUluUGxhY2UuY3JlYXRlU2h1ZmZsZUluUGxhY2UgPSBjcmVhdGVTaHVmZmxlSW5QbGFjZTtcbm1vZHVsZS5leHBvcnRzID0gc2h1ZmZsZUluUGxhY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNpZ21hLmpzIENhbWVyYSBDbGFzc1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENsYXNzIGRlc2lnbmVkIHRvIHN0b3JlIGNhbWVyYSBpbmZvcm1hdGlvbiAmIHVzZWQgdG8gdXBkYXRlIGl0LlxuICogQG1vZHVsZVxuICovXG52YXIgYW5pbWF0ZV8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2FuaW1hdGVcIik7XG52YXIgZWFzaW5nc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9lYXNpbmdzXCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG4vKipcbiAqIERlZmF1bHRzLlxuICovXG52YXIgREVGQVVMVF9aT09NSU5HX1JBVElPID0gMS41O1xuLyoqXG4gKiBDYW1lcmEgY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENhbWVyYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FtZXJhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbWVyYSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IDAuNTtcbiAgICAgICAgX3RoaXMueSA9IDAuNTtcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAwO1xuICAgICAgICBfdGhpcy5yYXRpbyA9IDE7XG4gICAgICAgIF90aGlzLm1pblJhdGlvID0gbnVsbDtcbiAgICAgICAgX3RoaXMubWF4UmF0aW8gPSBudWxsO1xuICAgICAgICBfdGhpcy5uZXh0RnJhbWUgPSBudWxsO1xuICAgICAgICBfdGhpcy5wcmV2aW91c1N0YXRlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIF90aGlzLnByZXZpb3VzU3RhdGUgPSBfdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdXNlZCB0byBjcmVhdGUgYSBDYW1lcmEgb2JqZWN0IHdpdGggYSBnaXZlbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgICBDYW1lcmEuZnJvbSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgICByZXR1cm4gY2FtZXJhLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGVuYWJsZSB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Q2FtZXJhfVxuICAgICAqL1xuICAgIENhbWVyYS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGRpc2FibGUgdGhlIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBjdXJyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIENhbWVyYS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGhhcyB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5oYXNTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBzdGF0ZS54ICYmIHRoaXMueSA9PT0gc3RhdGUueSAmJiB0aGlzLnJhdGlvID09PSBzdGF0ZS5yYXRpbyAmJiB0aGlzLmFuZ2xlID09PSBzdGF0ZS5hbmdsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLmdldFByZXZpb3VzU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucHJldmlvdXNTdGF0ZTtcbiAgICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogc3RhdGUueCxcbiAgICAgICAgICAgIHk6IHN0YXRlLnksXG4gICAgICAgICAgICBhbmdsZTogc3RhdGUuYW5nbGUsXG4gICAgICAgICAgICByYXRpbzogc3RhdGUucmF0aW8sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayBtaW5SYXRpbyBhbmQgbWF4UmF0aW8gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhdGlvXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIENhbWVyYS5wcm90b3R5cGUuZ2V0Qm91bmRlZFJhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XG4gICAgICAgIHZhciByID0gcmF0aW87XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5taW5SYXRpbyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHIgPSBNYXRoLm1heChyLCB0aGlzLm1pblJhdGlvKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1heFJhdGlvID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgciA9IE1hdGgubWluKHIsIHRoaXMubWF4UmF0aW8pO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIHZhcmlvdXMgdGhpbmdzIHRvIHJldHVybiBhIGxlZ2l0IHN0YXRlIGNhbmRpZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLnZhbGlkYXRlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRlZFN0YXRlID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHZhbGlkYXRlZFN0YXRlLnggPSBzdGF0ZS54O1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlLnkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB2YWxpZGF0ZWRTdGF0ZS55ID0gc3RhdGUueTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHZhbGlkYXRlZFN0YXRlLmFuZ2xlID0gc3RhdGUuYW5nbGU7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB2YWxpZGF0ZWRTdGF0ZS5yYXRpbyA9IHRoaXMuZ2V0Qm91bmRlZFJhdGlvKHN0YXRlLnJhdGlvKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZFN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5pc0FuaW1hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm5leHRGcmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IHN0YXRlIC0gTmV3IHN0YXRlLlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBieSBmdW5jdGlvblxuICAgICAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIGxhc3Qgc3RhdGVcbiAgICAgICAgdGhpcy5wcmV2aW91c1N0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgdmFsaWRTdGF0ZSA9IHRoaXMudmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhpcy54ID0gdmFsaWRTdGF0ZS54O1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMueSA9IHZhbGlkU3RhdGUueTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhpcy5hbmdsZSA9IHZhbGlkU3RhdGUuYW5nbGU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5yYXRpbyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMucmF0aW8gPSB2YWxpZFN0YXRlLnJhdGlvO1xuICAgICAgICAvLyBFbWl0dGluZ1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3RhdGUodGhpcy5wcmV2aW91c1N0YXRlKSlcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZWRcIiwgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBhbmltYXRlIHRoZSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgIC0gU3RhdGUgdG8gcmVhY2ggZXZlbnR1YWxseS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBvcHRzICAgICAgIC0gT3B0aW9uczpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uIC0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmcgfCBudW1iZXIgPT4gbnVtYmVyfSAgIGVhc2luZyAgIC0gRWFzaW5nIGZ1bmN0aW9uIG9yIG5hbWUgb2YgYW4gZXhpc3Rpbmcgb25lXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgICAtIENhbGxiYWNrXG4gICAgICovXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKHN0YXRlLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhbmltYXRlXzEuQU5JTUFURV9ERUZBVUxUUywgb3B0cyk7XG4gICAgICAgIHZhciB2YWxpZFN0YXRlID0gdGhpcy52YWxpZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgdmFyIGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5lYXNpbmcgOiBlYXNpbmdzXzEuZGVmYXVsdFtvcHRpb25zLmVhc2luZ107XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCksIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgLy8gRnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICAgICAgLy8gVGhlIGFuaW1hdGlvbiBpcyBvdmVyOlxuICAgICAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5leHRGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUodmFsaWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbkNhbGxiYWNrLmNhbGwobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbkNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSBlYXNpbmcodCk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnggPSBpbml0aWFsU3RhdGUueCArICh2YWxpZFN0YXRlLnggLSBpbml0aWFsU3RhdGUueCkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnkgPSBpbml0aWFsU3RhdGUueSArICh2YWxpZFN0YXRlLnkgLSBpbml0aWFsU3RhdGUueSkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5hbmdsZSA9IGluaXRpYWxTdGF0ZS5hbmdsZSArICh2YWxpZFN0YXRlLmFuZ2xlIC0gaW5pdGlhbFN0YXRlLmFuZ2xlKSAqIGNvZWZmaWNpZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnJhdGlvID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnJhdGlvID0gaW5pdGlhbFN0YXRlLnJhdGlvICsgKHZhbGlkU3RhdGUucmF0aW8gLSBpbml0aWFsU3RhdGUucmF0aW8pICogY29lZmZpY2llbnQ7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICBfdGhpcy5uZXh0RnJhbWUgPSAoMCwgdXRpbHNfMS5yZXF1ZXN0RnJhbWUpKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubmV4dEZyYW1lKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5jYW5jZWxGcmFtZSkodGhpcy5uZXh0RnJhbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25DYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5uZXh0RnJhbWUgPSAoMCwgdXRpbHNfMS5yZXF1ZXN0RnJhbWUpKGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gem9vbSB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfG9iamVjdH0gZmFjdG9yT3JPcHRpb25zIC0gRmFjdG9yIG9yIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5hbmltYXRlZFpvb20gPSBmdW5jdGlvbiAoZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICAgIGlmICghZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoeyByYXRpbzogdGhpcy5yYXRpbyAvIERFRkFVTFRfWk9PTUlOR19SQVRJTyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjdG9yT3JPcHRpb25zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoeyByYXRpbzogdGhpcy5yYXRpbyAvIGZhY3Rvck9yT3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAvIChmYWN0b3JPck9wdGlvbnMuZmFjdG9yIHx8IERFRkFVTFRfWk9PTUlOR19SQVRJTyksXG4gICAgICAgICAgICAgICAgfSwgZmFjdG9yT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdW56b29tIHRoZSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ8b2JqZWN0fSBmYWN0b3JPck9wdGlvbnMgLSBGYWN0b3Igb3Igb3B0aW9ucy5cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLmFuaW1hdGVkVW56b29tID0gZnVuY3Rpb24gKGZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgICBpZiAoIWZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlKHsgcmF0aW86IHRoaXMucmF0aW8gKiBERUZBVUxUX1pPT01JTkdfUkFUSU8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZhY3Rvck9yT3B0aW9ucyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHsgcmF0aW86IHRoaXMucmF0aW8gKiBmYWN0b3JPck9wdGlvbnMgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiAoZmFjdG9yT3JPcHRpb25zLmZhY3RvciB8fCBERUZBVUxUX1pPT01JTkdfUkFUSU8pLFxuICAgICAgICAgICAgICAgIH0sIGZhY3Rvck9yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlc2V0IHRoZSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zLlxuICAgICAqL1xuICAgIENhbWVyYS5wcm90b3R5cGUuYW5pbWF0ZWRSZXNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgICB5OiAwLjUsXG4gICAgICAgICAgICByYXRpbzogMSxcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgQ2FtZXJhIGluc3RhbmNlLCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFzIHRoZSBjdXJyZW50IGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgICBDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYW1lcmEuZnJvbSh0aGlzLmdldFN0YXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYTtcbn0odHlwZXNfMS5UeXBlZEV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2FtZXJhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0V2hlZWxEZWx0YSA9IGV4cG9ydHMuZ2V0VG91Y2hDb29yZHMgPSBleHBvcnRzLmdldFRvdWNoZXNBcnJheSA9IGV4cG9ydHMuZ2V0V2hlZWxDb29yZHMgPSBleHBvcnRzLmdldE1vdXNlQ29vcmRzID0gZXhwb3J0cy5nZXRQb3NpdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogU2lnbWEuanMgQ2FwdG9yIENsYXNzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKiBAbW9kdWxlXG4gKi9cbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuLyoqXG4gKiBDYXB0b3IgdXRpbHMgZnVuY3Rpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogRXh0cmFjdCB0aGUgbG9jYWwgWCBhbmQgWSBjb29yZGluYXRlcyBmcm9tIGEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LiBJZlxuICogYSBET00gZWxlbWVudCBpcyBnaXZlbiwgaXQgdXNlcyB0aGlzIGVsZW1lbnQncyBvZmZzZXQgdG8gY29tcHV0ZSB0aGUgcG9zaXRpb25cbiAqICh0aGlzIGFsbG93cyB1c2luZyBldmVudHMgdGhhdCBhcmUgbm90IGJvdW5kIHRvIHRoZSBjb250YWluZXIgaXRzZWxmIGFuZFxuICogc3RpbGwgaGF2ZSBhIHByb3BlciBwb3NpdGlvbikuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgLSBBIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICovXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihlLCBkb20pIHtcbiAgICB2YXIgYmJveCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBlLmNsaWVudFggLSBiYm94LmxlZnQsXG4gICAgICAgIHk6IGUuY2xpZW50WSAtIGJib3gudG9wLFxuICAgIH07XG59XG5leHBvcnRzLmdldFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4vKipcbiAqIENvbnZlcnQgbW91c2UgY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb3VzZUNvb3JkcyhlLCBkb20pIHtcbiAgICB2YXIgcmVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldFBvc2l0aW9uKGUsIGRvbSkpLCB7IHNpZ21hRGVmYXVsdFByZXZlbnRlZDogZmFsc2UsIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB9LCBvcmlnaW5hbDogZSB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5nZXRNb3VzZUNvb3JkcyA9IGdldE1vdXNlQ29vcmRzO1xuLyoqXG4gKiBDb252ZXJ0IG1vdXNlIHdoZWVsIGV2ZW50IGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgd2hlZWwgbW91c2UgZXZlbnQuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRXaGVlbENvb3JkcyhlLCBkb20pIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldE1vdXNlQ29vcmRzKGUsIGRvbSkpLCB7IGRlbHRhOiBnZXRXaGVlbERlbHRhKGUpIH0pO1xufVxuZXhwb3J0cy5nZXRXaGVlbENvb3JkcyA9IGdldFdoZWVsQ29vcmRzO1xudmFyIE1BWF9UT1VDSEVTID0gMjtcbmZ1bmN0aW9uIGdldFRvdWNoZXNBcnJheSh0b3VjaGVzKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4odG91Y2hlcy5sZW5ndGgsIE1BWF9UT1VDSEVTKTsgaSA8IGw7IGkrKylcbiAgICAgICAgYXJyLnB1c2godG91Y2hlc1tpXSk7XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuZ2V0VG91Y2hlc0FycmF5ID0gZ2V0VG91Y2hlc0FycmF5O1xuLyoqXG4gKiBDb252ZXJ0IHRvdWNoIGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgdG91Y2ggZXZlbnQuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaENvb3JkcyhlLCBkb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3VjaGVzOiBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKS5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7IHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgZG9tKTsgfSksXG4gICAgICAgIG9yaWdpbmFsOiBlLFxuICAgIH07XG59XG5leHBvcnRzLmdldFRvdWNoQ29vcmRzID0gZ2V0VG91Y2hDb29yZHM7XG4vKipcbiAqIEV4dHJhY3QgdGhlIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICBlIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBUaGUgd2hlZWwgZGVsdGEgb2YgdGhlIG1vdXNlLlxuICovXG5mdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcbiAgICAvLyBUT0RPOiBjaGVjayB0aG9zZSByYXRpb3MgYWdhaW4gdG8gZW5zdXJlIGEgY2xlYW4gQ2hyb21lL0ZpcmVmb3ggY29tcGF0XG4gICAgaWYgKHR5cGVvZiBlLmRlbHRhWSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIChlLmRlbHRhWSAqIC0zKSAvIDM2MDtcbiAgICBpZiAodHlwZW9mIGUuZGV0YWlsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZS5kZXRhaWwgLyAtOTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYXB0b3I6IGNvdWxkIG5vdCBleHRyYWN0IGRlbHRhIGZyb20gZXZlbnQuXCIpO1xufVxuZXhwb3J0cy5nZXRXaGVlbERlbHRhID0gZ2V0V2hlZWxEZWx0YTtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgcmVwcmVzZW50aW5nIGEgY2FwdG9yIGxpa2UgdGhlIHVzZXIncyBtb3VzZSBvciB0b3VjaCBjb250cm9scy5cbiAqL1xudmFyIENhcHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FwdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBfdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDYXB0b3I7XG59KHR5cGVzXzEuVHlwZWRFdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENhcHRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhcHRvcl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NhcHRvclwiKSk7XG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xudmFyIERSQUdfVElNRU9VVCA9IDEwMDtcbnZhciBEUkFHR0VEX0VWRU5UU19UT0xFUkFOQ0UgPSAzO1xudmFyIE1PVVNFX0lORVJUSUFfRFVSQVRJT04gPSAyMDA7XG52YXIgTU9VU0VfSU5FUlRJQV9SQVRJTyA9IDM7XG52YXIgTU9VU0VfWk9PTV9EVVJBVElPTiA9IDI1MDtcbnZhciBaT09NSU5HX1JBVElPID0gMS43O1xudmFyIERPVUJMRV9DTElDS19USU1FT1VUID0gMzAwO1xudmFyIERPVUJMRV9DTElDS19aT09NSU5HX1JBVElPID0gMi4yO1xudmFyIERPVUJMRV9DTElDS19aT09NSU5HX0RVUkFUSU9OID0gMjAwO1xuLyoqXG4gKiBNb3VzZSBjYXB0b3IgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNb3VzZUNhcHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW91c2VDYXB0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW91c2VDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250YWluZXIsIHJlbmRlcmVyKSB8fCB0aGlzO1xuICAgICAgICAvLyBTdGF0ZVxuICAgICAgICBfdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuZHJhZ2dlZEV2ZW50cyA9IDA7XG4gICAgICAgIF90aGlzLmRvd25TdGFydFRpbWUgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0TW91c2VYID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdE1vdXNlWSA9IG51bGw7XG4gICAgICAgIF90aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm1vdmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdGFydENhbWVyYVN0YXRlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY2xpY2tzID0gMDtcbiAgICAgICAgX3RoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gMDtcbiAgICAgICAgLy8gQmluZGluZyBtZXRob2RzXG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrID0gX3RoaXMuaGFuZGxlQ2xpY2suYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2sgPSBfdGhpcy5oYW5kbGVSaWdodENsaWNrLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5oYW5kbGVEb3duID0gX3RoaXMuaGFuZGxlRG93bi5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlVXAgPSBfdGhpcy5oYW5kbGVVcC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW92ZSA9IF90aGlzLmhhbmRsZU1vdmUuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmhhbmRsZVdoZWVsID0gX3RoaXMuaGFuZGxlV2hlZWwuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmhhbmRsZU91dCA9IF90aGlzLmhhbmRsZU91dC5iaW5kKF90aGlzKTtcbiAgICAgICAgLy8gQmluZGluZyBldmVudHNcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfdGhpcy5oYW5kbGVDbGljaywgZmFsc2UpO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2ssIGZhbHNlKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMuaGFuZGxlRG93biwgZmFsc2UpO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIF90aGlzLmhhbmRsZVdoZWVsLCBmYWxzZSk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgX3RoaXMuaGFuZGxlT3V0LCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMuaGFuZGxlTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5oYW5kbGVVcCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vdXNlQ2FwdG9yLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5oYW5kbGVSaWdodENsaWNrKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVEb3duKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLmhhbmRsZVdoZWVsKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLmhhbmRsZU91dCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVVcCk7XG4gICAgfTtcbiAgICBNb3VzZUNhcHRvci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGlja3MrKztcbiAgICAgICAgaWYgKHRoaXMuY2xpY2tzID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrcyA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEb3VibGVDbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsaWNrcyA9IDA7XG4gICAgICAgICAgICBfdGhpcy5kb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCBET1VCTEVfQ0xJQ0tfVElNRU9VVCk7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgaXMgaGVyZSB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyBvbiBkcmFnXG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRFdmVudHMgPCBEUkFHR0VEX0VWRU5UU19UT0xFUkFOQ0UpXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbGlja1wiLCAoMCwgY2FwdG9yXzEuZ2V0TW91c2VDb29yZHMpKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfTtcbiAgICBNb3VzZUNhcHRvci5wcm90b3R5cGUuaGFuZGxlUmlnaHRDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVtaXQoXCJyaWdodENsaWNrXCIsICgwLCBjYXB0b3JfMS5nZXRNb3VzZUNvb3JkcykoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9O1xuICAgIE1vdXNlQ2FwdG9yLnByb3RvdHlwZS5oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBtb3VzZUNvb3JkcyA9ICgwLCBjYXB0b3JfMS5nZXRNb3VzZUNvb3JkcykoZSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJkb3VibGVDbGlja1wiLCBtb3VzZUNvb3Jkcyk7XG4gICAgICAgIGlmIChtb3VzZUNvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIHZhciBuZXdSYXRpbyA9IGNhbWVyYS5nZXRCb3VuZGVkUmF0aW8oY2FtZXJhLmdldFN0YXRlKCkucmF0aW8gLyBET1VCTEVfQ0xJQ0tfWk9PTUlOR19SQVRJTyk7XG4gICAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZSgoMCwgY2FwdG9yXzEuZ2V0UG9zaXRpb24pKGUsIHRoaXMuY29udGFpbmVyKSwgbmV3UmF0aW8pLCB7XG4gICAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgICAgIGR1cmF0aW9uOiBET1VCTEVfQ0xJQ0tfWk9PTUlOR19EVVJBVElPTixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb3VzZUNhcHRvci5wcm90b3R5cGUuaGFuZGxlRG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBfYSA9ICgwLCBjYXB0b3JfMS5nZXRQb3NpdGlvbikoZSwgdGhpcy5jb250YWluZXIpLCB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWCA9IHg7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWSA9IHk7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuZG93blN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIFRPRE86IGRpc3BhdGNoIGV2ZW50c1xuICAgICAgICAvLyBMZWZ0IGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgIHRoaXMuaXNNb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJtb3VzZWRvd25cIiwgKDAsIGNhcHRvcl8xLmdldE1vdXNlQ29vcmRzKShlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH07XG4gICAgTW91c2VDYXB0b3IucHJvdG90eXBlLmhhbmRsZVVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuaXNNb3VzZURvd24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICB0aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tb3ZpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gKDAsIGNhcHRvcl8xLmdldFBvc2l0aW9uKShlLCB0aGlzLmNvbnRhaW5lciksIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCksIHByZXZpb3VzQ2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0UHJldmlvdXNTdGF0ZSgpIHx8IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBpZiAodGhpcy5pc01vdmluZykge1xuICAgICAgICAgICAgY2FtZXJhLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLnggKyBNT1VTRV9JTkVSVElBX1JBVElPICogKGNhbWVyYVN0YXRlLnggLSBwcmV2aW91c0NhbWVyYVN0YXRlLngpLFxuICAgICAgICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnkgKyBNT1VTRV9JTkVSVElBX1JBVElPICogKGNhbWVyYVN0YXRlLnkgLSBwcmV2aW91c0NhbWVyYVN0YXRlLnkpLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBNT1VTRV9JTkVSVElBX0RVUkFUSU9OLFxuICAgICAgICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGFzdE1vdXNlWCAhPT0geCB8fCB0aGlzLmxhc3RNb3VzZVkgIT09IHkpIHtcbiAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgeDogY2FtZXJhU3RhdGUueCxcbiAgICAgICAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnZWRFdmVudHMgPSAwO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIucmVmcmVzaCgpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGhpcy5lbWl0KFwibW91c2V1cFwiLCAoMCwgY2FwdG9yXzEuZ2V0TW91c2VDb29yZHMpKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfTtcbiAgICBNb3VzZUNhcHRvci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbW91c2VDb29yZHMgPSAoMCwgY2FwdG9yXzEuZ2V0TW91c2VDb29yZHMpKGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgLy8gQWx3YXlzIHRyaWdnZXIgYSBcIm1vdXNlbW92ZWJvZHlcIiBldmVudCwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkZXZlbG9wXG4gICAgICAgIC8vIGEgZHJhZy1hbmQtZHJvcCBlZmZlY3QgdGhhdCB3b3JrcyBldmVuIHdoZW4gdGhlIG1vdXNlIGlzIG91dCBvZiB0aGVcbiAgICAgICAgLy8gY29udGFpbmVyOlxuICAgICAgICB0aGlzLmVtaXQoXCJtb3VzZW1vdmVib2R5XCIsIG1vdXNlQ29vcmRzKTtcbiAgICAgICAgLy8gT25seSB0cmlnZ2VyIHRoZSBcIm1vdXNlbW92ZVwiIGV2ZW50IHdoZW4gdGhlIG1vdXNlIGlzIGFjdHVhbGx5IGhvdmVyaW5nXG4gICAgICAgIC8vIHRoZSBjb250YWluZXIsIHRvIGF2b2lkIHdlaXJkbHkgaG92ZXJpbmcgbm9kZXMgYW5kL29yIGVkZ2VzIHdoZW4gdGhlXG4gICAgICAgIC8vIG1vdXNlIGlzIG5vdCBob3ZlciB0aGUgY29udGFpbmVyOlxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJtb3VzZW1vdmVcIiwgbW91c2VDb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VzZUNvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIFwiaXNNb3VzZURvd25cIiBhbGwgdGhlIHRpbWUsIHRvIGFsbG93IGRyYWdnaW5nIHRoZVxuICAgICAgICAvLyBzdGFnZSB3aGlsZSB0aGUgbW91c2UgaXMgbm90IGhvdmVyIHRoZSBjb250YWluZXI6XG4gICAgICAgIGlmICh0aGlzLmlzTW91c2VEb3duKSB7XG4gICAgICAgICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZEV2ZW50cysrO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1vdmluZ1RpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3ZpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgRFJBR19USU1FT1VUKTtcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgdmFyIF9hID0gKDAsIGNhcHRvcl8xLmdldFBvc2l0aW9uKShlLCB0aGlzLmNvbnRhaW5lciksIGVYID0gX2EueCwgZVkgPSBfYS55O1xuICAgICAgICAgICAgdmFyIGxhc3RNb3VzZSA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmxhc3RNb3VzZVgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5sYXN0TW91c2VZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7IHg6IGVYLCB5OiBlWSB9KTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRYID0gbGFzdE1vdXNlLnggLSBtb3VzZS54LCBvZmZzZXRZID0gbGFzdE1vdXNlLnkgLSBtb3VzZS55O1xuICAgICAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB2YXIgeCA9IGNhbWVyYVN0YXRlLnggKyBvZmZzZXRYLCB5ID0gY2FtZXJhU3RhdGUueSArIG9mZnNldFk7XG4gICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUoeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0TW91c2VYID0gZVg7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSBlWTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vdXNlQ2FwdG9yLnByb3RvdHlwZS5oYW5kbGVXaGVlbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBkZWx0YSA9ICgwLCBjYXB0b3JfMS5nZXRXaGVlbERlbHRhKShlKTtcbiAgICAgICAgaWYgKCFkZWx0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHdoZWVsQ29vcmRzID0gKDAsIGNhcHRvcl8xLmdldFdoZWVsQ29vcmRzKShlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZW1pdChcIndoZWVsXCIsIHdoZWVsQ29vcmRzKTtcbiAgICAgICAgaWYgKHdoZWVsQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvclxuICAgICAgICB2YXIgcmF0aW9EaWZmID0gZGVsdGEgPiAwID8gMSAvIFpPT01JTkdfUkFUSU8gOiBaT09NSU5HX1JBVElPO1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhjYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAqIHJhdGlvRGlmZik7XG4gICAgICAgIHZhciB3aGVlbERpcmVjdGlvbiA9IGRlbHRhID4gMCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIENhbmNlbCBldmVudHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvbyBlYWNoIG90aGVyIGFuZCBpbiB0aGUgc2FtZSBkaXJlY3Rpb246XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9PT0gd2hlZWxEaXJlY3Rpb24gJiZcbiAgICAgICAgICAgIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgJiZcbiAgICAgICAgICAgIG5vdyAtIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgPCBNT1VTRV9aT09NX0RVUkFUSU9OIC8gNSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZSgoMCwgY2FwdG9yXzEuZ2V0UG9zaXRpb24pKGUsIHRoaXMuY29udGFpbmVyKSwgbmV3UmF0aW8pLCB7XG4gICAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCIsXG4gICAgICAgICAgICBkdXJhdGlvbjogTU9VU0VfWk9PTV9EVVJBVElPTixcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gd2hlZWxEaXJlY3Rpb247XG4gICAgICAgIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgPSBub3c7XG4gICAgfTtcbiAgICBNb3VzZUNhcHRvci5wcm90b3R5cGUuaGFuZGxlT3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBkaXNwYXRjaCBldmVudFxuICAgIH07XG4gICAgcmV0dXJuIE1vdXNlQ2FwdG9yO1xufShjYXB0b3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNb3VzZUNhcHRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhcHRvcl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NhcHRvclwiKSk7XG52YXIgRFJBR19USU1FT1VUID0gMjAwO1xudmFyIFRPVUNIX0lORVJUSUFfUkFUSU8gPSAzO1xudmFyIFRPVUNIX0lORVJUSUFfRFVSQVRJT04gPSAyMDA7XG4vKipcbiAqIFRvdWNoIGNhcHRvciBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRvdWNoQ2FwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb3VjaENhcHRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb3VjaENhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lciwgcmVuZGVyZXIpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50b3VjaE1vZGUgPSAwOyAvLyBudW1iZXIgb2YgdG91Y2hlcyBkb3duXG4gICAgICAgIC8vIEJpbmRpbmcgbWV0aG9kczpcbiAgICAgICAgX3RoaXMuaGFuZGxlU3RhcnQgPSBfdGhpcy5oYW5kbGVTdGFydC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTGVhdmUgPSBfdGhpcy5oYW5kbGVMZWF2ZS5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW92ZSA9IF90aGlzLmhhbmRsZU1vdmUuYmluZChfdGhpcyk7XG4gICAgICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5oYW5kbGVTdGFydCwgZmFsc2UpO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmhhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMuaGFuZGxlTW92ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRvdWNoQ2FwdG9yLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLmhhbmRsZVN0YXJ0KTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5oYW5kbGVNb3ZlKTtcbiAgICB9O1xuICAgIFRvdWNoQ2FwdG9yLnByb3RvdHlwZS5nZXREaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUb3VjaENhcHRvci5wcm90b3R5cGUuZGlzcGF0Y2hSZWxhdGVkTW91c2VFdmVudCA9IGZ1bmN0aW9uICh0eXBlLCBlLCBwb3NpdGlvbiwgZW1pdHRlcikge1xuICAgICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICgwLCBjYXB0b3JfMS5nZXRQb3NpdGlvbikoZS50b3VjaGVzWzBdLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHZhciBtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgY2xpZW50WDogbW91c2VQb3NpdGlvbi54LFxuICAgICAgICAgICAgY2xpZW50WTogbW91c2VQb3NpdGlvbi55LFxuICAgICAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAgICAgICAgfSk7XG4gICAgICAgIG1vdXNlRXZlbnQuaXNGYWtlU2lnbWFNb3VzZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgKGVtaXR0ZXIgfHwgdGhpcy5jb250YWluZXIpLmRpc3BhdGNoRXZlbnQobW91c2VFdmVudCk7XG4gICAgfTtcbiAgICBUb3VjaENhcHRvci5wcm90b3R5cGUuaGFuZGxlU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvcnMuLi5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyAuLi5idXQgc2ltdWxhdGUgbW91c2UgYmVoYXZpb3IgYW55d2F5LCB0byBnZXQgdGhlIE1vdXNlQ2FwdG9yIHdvcmtpbmcgYXMgd2VsbDpcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoUmVsYXRlZE1vdXNlRXZlbnQoXCJtb3VzZWRvd25cIiwgZSk7XG4gICAgICAgIHZhciB0b3VjaGVzID0gKDAsIGNhcHRvcl8xLmdldFRvdWNoZXNBcnJheSkoZS50b3VjaGVzKTtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudG91Y2hNb2RlID0gdG91Y2hlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCkuZ2V0U3RhdGUoKTtcbiAgICAgICAgdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHsgcmV0dXJuICgwLCBjYXB0b3JfMS5nZXRQb3NpdGlvbikodG91Y2gsIF90aGlzLmNvbnRhaW5lcik7IH0pO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnM7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIHR3byB0b3VjaGVzIGRvd24sIGxldCdzIHJlY29yZCBkaXN0YW5jZSBhbmQgYW5nbGUgYXMgd2VsbDpcbiAgICAgICAgaWYgKHRoaXMudG91Y2hNb2RlID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMsIDIpLCBfYiA9IF9hWzBdLCB4MCA9IF9iLngsIHkwID0gX2IueSwgX2MgPSBfYVsxXSwgeDEgPSBfYy54LCB5MSA9IF9jLnk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VG91Y2hlc0FuZ2xlID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwidG91Y2hkb3duXCIsICgwLCBjYXB0b3JfMS5nZXRUb3VjaENvb3JkcykoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9O1xuICAgIFRvdWNoQ2FwdG9yLnByb3RvdHlwZS5oYW5kbGVMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgdG8gYXZvaWQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9ycy4uLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIC4uLmJ1dCBzaW11bGF0ZSBtb3VzZSBiZWhhdmlvciBhbnl3YXksIHRvIGdldCB0aGUgTW91c2VDYXB0b3Igd29ya2luZyBhcyB3ZWxsOlxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zICYmIHRoaXMubGFzdFRvdWNoZXNQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoUmVsYXRlZE1vdXNlRXZlbnQoXCJtb3VzZXVwXCIsIGUsIHRoaXMubGFzdFRvdWNoZXNQb3NpdGlvbnNbMF0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hSZWxhdGVkTW91c2VFdmVudChcImNsaWNrXCIsIGUsIHRoaXMubGFzdFRvdWNoZXNQb3NpdGlvbnNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vdmluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy50b3VjaE1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01vdmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCksIHByZXZpb3VzQ2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0UHJldmlvdXNTdGF0ZSgpIHx8IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgICAgICAgICBjYW1lcmEuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54ICsgVE9VQ0hfSU5FUlRJQV9SQVRJTyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnkgKyBUT1VDSF9JTkVSVElBX1JBVElPICogKGNhbWVyYVN0YXRlLnkgLSBwcmV2aW91c0NhbWVyYVN0YXRlLnkpLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogVE9VQ0hfSU5FUlRJQV9EVVJBVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoTW9kZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwidG91Y2h1cFwiLCAoMCwgY2FwdG9yXzEuZ2V0VG91Y2hDb29yZHMpKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfTtcbiAgICBUb3VjaENhcHRvci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCB0byBhdm9pZCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JzLi4uXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gLi4uYnV0IHNpbXVsYXRlIG1vdXNlIGJlaGF2aW9yIGFueXdheSwgdG8gZ2V0IHRoZSBNb3VzZUNhcHRvciB3b3JraW5nIGFzIHdlbGw6XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFJlbGF0ZWRNb3VzZUV2ZW50KFwibW91c2Vtb3ZlXCIsIGUpO1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgdmFyIHN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGU7XG4gICAgICAgIHZhciB0b3VjaGVzID0gKDAsIGNhcHRvcl8xLmdldFRvdWNoZXNBcnJheSkoZS50b3VjaGVzKTtcbiAgICAgICAgdmFyIHRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHsgcmV0dXJuICgwLCBjYXB0b3JfMS5nZXRQb3NpdGlvbikodG91Y2gsIF90aGlzLmNvbnRhaW5lcik7IH0pO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdG91Y2hlc1Bvc2l0aW9ucztcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1vdmluZ1RpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgRFJBR19USU1FT1VUKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRvdWNoTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSksIHhTdGFydCA9IF9iLngsIHlTdGFydCA9IF9iLnk7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgodG91Y2hlc1Bvc2l0aW9uc1swXSksIHggPSBfYy54LCB5ID0gX2MueTtcbiAgICAgICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB4OiBzdGFydENhbWVyYVN0YXRlLnggKyB4U3RhcnQgLSB4LFxuICAgICAgICAgICAgICAgICAgICB5OiBzdGFydENhbWVyYVN0YXRlLnkgKyB5U3RhcnQgLSB5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSGVyZSBpcyB0aGUgdGhpbmtpbmcgaGVyZTpcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIDEuIFdlIGNhbiBmaW5kIHRoZSBuZXcgYW5nbGUgYW5kIHJhdGlvLCBieSBjb21wYXJpbmcgdGhlIHZlY3RvciBmcm9tIFwidG91Y2ggb25lXCIgdG8gXCJ0b3VjaCB0d29cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgKiAgICBvZiB0aGUgZCduJ2QgYW5kIG5vd1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogMi4gV2UgY2FuIHVzZSBgQ2FtZXJhI3ZpZXdwb3J0VG9HcmFwaGAgaW5zaWRlIGZvcm11bGEgdG8gcmV0cmlldmUgdGhlIG5ldyBjYW1lcmEgcG9zaXRpb24sIHVzaW5nIHRoZSBncmFwaFxuICAgICAgICAgICAgICAgICAqICAgIHBvc2l0aW9uIG9mIGEgdG91Y2ggYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZCduJ2QgKHVzaW5nIGBzdGFydENhbWVyYS52aWV3cG9ydFRvR3JhcGhgKSBhbmQgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICogICAgcG9zaXRpb24gb2YgdGhpcyBzYW1lIHRvdWNoIG5vd1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBuZXdDYW1lcmFTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IHRvdWNoZXNQb3NpdGlvbnNbMF0sIHgwID0gX2QueCwgeTAgPSBfZC55O1xuICAgICAgICAgICAgICAgIHZhciBfZSA9IHRvdWNoZXNQb3NpdGlvbnNbMV0sIHgxID0gX2UueCwgeTEgPSBfZS55O1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZURpZmYgPSBNYXRoLmF0YW4yKHkxIC0geTAsIHgxIC0geDApIC0gdGhpcy5zdGFydFRvdWNoZXNBbmdsZTtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW9EaWZmID0gTWF0aC5oeXBvdCh5MSAtIHkwLCB4MSAtIHgwKSAvIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gMS5cbiAgICAgICAgICAgICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKHN0YXJ0Q2FtZXJhU3RhdGUucmF0aW8gLyByYXRpb0RpZmYpO1xuICAgICAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnJhdGlvID0gbmV3UmF0aW87XG4gICAgICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUuYW5nbGUgPSBzdGFydENhbWVyYVN0YXRlLmFuZ2xlICsgYW5nbGVEaWZmO1xuICAgICAgICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2hHcmFwaFBvc2l0aW9uID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSwgeyBjYW1lcmFTdGF0ZTogc3RhcnRDYW1lcmFTdGF0ZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbihkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gc21hbGxlc3REaW1lbnNpb24gLyBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHNtYWxsZXN0RGltZW5zaW9uIC8gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gbmV3UmF0aW8gLyBzbWFsbGVzdERpbWVuc2lvbjtcbiAgICAgICAgICAgICAgICAvLyBBbGlnbiB3aXRoIGNlbnRlciBvZiB0aGUgZ3JhcGg6XG4gICAgICAgICAgICAgICAgdmFyIHggPSB4MCAtIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGR4O1xuICAgICAgICAgICAgICAgIHZhciB5ID0geTAgLSBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBkeTtcbiAgICAgICAgICAgICAgICAvLyBSb3RhdGU6XG4gICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoW1xuICAgICAgICAgICAgICAgICAgICB4ICogTWF0aC5jb3MoLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSAtIHkgKiBNYXRoLnNpbigtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICB5ICogTWF0aC5jb3MoLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSArIHggKiBNYXRoLnNpbigtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpLFxuICAgICAgICAgICAgICAgIF0sIDIpLCB4ID0gX2FbMF0sIHkgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS54ID0gdG91Y2hHcmFwaFBvc2l0aW9uLnggLSB4ICogcmF0aW87XG4gICAgICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUueSA9IHRvdWNoR3JhcGhQb3NpdGlvbi55ICsgeSAqIHJhdGlvO1xuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwidG91Y2htb3ZlXCIsICgwLCBjYXB0b3JfMS5nZXRUb3VjaENvb3JkcykoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUb3VjaENhcHRvcjtcbn0oY2FwdG9yXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG91Y2hDYXB0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2RlcyA9IGV4cG9ydHMuTGFiZWxHcmlkID0gdm9pZCAwO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzaW5nbGUgY2FuZGlkYXRlIGZvciB0aGUgbGFiZWwgZ3JpZCBzZWxlY3Rpb24uXG4gKlxuICogSXQgYWxzbyBkZXNjcmliZXMgYSBkZXRlcm1pbmlzdGljIHdheSB0byBjb21wYXJlIHR3byBjYW5kaWRhdGVzIHRvIGFzc2Vzc1xuICogd2hpY2ggb25lIGlzIGJldHRlci5cbiAqL1xudmFyIExhYmVsQ2FuZGlkYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhYmVsQ2FuZGlkYXRlKGtleSwgc2l6ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgTGFiZWxDYW5kaWRhdGUuY29tcGFyZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNvbXBhcmUgYnkgc2l6ZVxuICAgICAgICBpZiAoZmlyc3Quc2l6ZSA+IHNlY29uZC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoZmlyc3Quc2l6ZSA8IHNlY29uZC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vIFRoZW4gc2luY2Ugbm8gdHdvIG5vZGVzIGNhbiBoYXZlIHRoZSBzYW1lIGtleSwgd2UgdXNlIGl0IHRvXG4gICAgICAgIC8vIGRldGVybWluaXN0aWNhbGx5IHRpZS1icmVhayBieSBrZXlcbiAgICAgICAgaWYgKGZpcnN0LmtleSA+IHNlY29uZC5rZXkpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gTk9URTogdGhpcyBjb21wYXJhdG9yIGNhbm5vdCByZXR1cm4gMFxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gTGFiZWxDYW5kaWRhdGU7XG59KCkpO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAyRCBzcGF0aWFsIGdyaWQgZGl2aWRlZCBpbnRvIGNvbnN0YW50LXNpemUgY2VsbHMuXG4gKi9cbnZhciBMYWJlbEdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFiZWxHcmlkKCkge1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmNlbGxTaXplID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gMDtcbiAgICAgICAgdGhpcy5yb3dzID0gMDtcbiAgICAgICAgdGhpcy5jZWxscyA9IHt9O1xuICAgIH1cbiAgICBMYWJlbEdyaWQucHJvdG90eXBlLnJlc2l6ZUFuZENsZWFyID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNlbGxTaXplKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNlbGxTaXplID0gY2VsbFNpemU7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IE1hdGguY2VpbChkaW1lbnNpb25zLndpZHRoIC8gY2VsbFNpemUpO1xuICAgICAgICB0aGlzLnJvd3MgPSBNYXRoLmNlaWwoZGltZW5zaW9ucy5oZWlnaHQgLyBjZWxsU2l6ZSk7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB7fTtcbiAgICB9O1xuICAgIExhYmVsR3JpZC5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciB4SW5kZXggPSBNYXRoLmZsb29yKHBvcy54IC8gdGhpcy5jZWxsU2l6ZSk7XG4gICAgICAgIHZhciB5SW5kZXggPSBNYXRoLmZsb29yKHBvcy55IC8gdGhpcy5jZWxsU2l6ZSk7XG4gICAgICAgIHJldHVybiB5SW5kZXggKiB0aGlzLmNvbHVtbnMgKyB4SW5kZXg7XG4gICAgfTtcbiAgICBMYWJlbEdyaWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXksIHNpemUsIHBvcykge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gbmV3IExhYmVsQ2FuZGlkYXRlKGtleSwgc2l6ZSk7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgocG9zKTtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICBjZWxsID0gW107XG4gICAgICAgICAgICB0aGlzLmNlbGxzW2luZGV4XSA9IGNlbGw7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbC5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfTtcbiAgICBMYWJlbEdyaWQucHJvdG90eXBlLm9yZ2FuaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1trXTtcbiAgICAgICAgICAgIGNlbGwuc29ydChMYWJlbENhbmRpZGF0ZS5jb21wYXJlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGFiZWxHcmlkLnByb3RvdHlwZS5nZXRMYWJlbHNUb0Rpc3BsYXkgPSBmdW5jdGlvbiAocmF0aW8sIGRlbnNpdHkpIHtcbiAgICAgICAgLy8gVE9ETzogd29yayBvbiB2aXNpYmxlIG5vZGVzIHRvIG9wdGltaXplPyBeIC0+IHRocmVzaG9sZCBvdXRzaWRlIHNvIHRoYXQgbWVtb2l6YXRpb24gd29ya3M/XG4gICAgICAgIC8vIFRPRE86IGFkanVzdCB0aHJlc2hvbGQgbG93ZXIsIGJ1dCBpbmNyZWFzZSBjZWxscyBhIGJpdD9cbiAgICAgICAgLy8gVE9ETzogaHVudCBmb3IgZ2VvbSBpc3N1ZSBpbiBkaXNndWlzZVxuICAgICAgICAvLyBUT0RPOiBtZW1vaXplIHdoaWxlIHJhdGlvIGRvZXMgbm90IG1vdmUuIG1ldGhvZCB0byBmb3JjZSByZWNvbXB1dGVcbiAgICAgICAgdmFyIGNlbGxBcmVhID0gdGhpcy5jZWxsU2l6ZSAqIHRoaXMuY2VsbFNpemU7XG4gICAgICAgIHZhciBzY2FsZWRDZWxsQXJlYSA9IGNlbGxBcmVhIC8gcmF0aW8gLyByYXRpbztcbiAgICAgICAgdmFyIHNjYWxlZERlbnNpdHkgPSAoc2NhbGVkQ2VsbEFyZWEgKiBkZW5zaXR5KSAvIGNlbGxBcmVhO1xuICAgICAgICB2YXIgbGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCA9IE1hdGguY2VpbChzY2FsZWREZW5zaXR5KTtcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1trXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4obGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCwgY2VsbC5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaChjZWxsW2ldLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9O1xuICAgIHJldHVybiBMYWJlbEdyaWQ7XG59KCkpO1xuZXhwb3J0cy5MYWJlbEdyaWQgPSBMYWJlbEdyaWQ7XG4vKipcbiAqIExhYmVsIGhldXJpc3RpYyBzZWxlY3RpbmcgZWRnZSBsYWJlbHMgdG8gZGlzcGxheSwgYmFzZWQgb24gZGlzcGxheWVkIG5vZGVcbiAqIGxhYmVsc1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICAgICAgICAgICAgICAgICAtIFBhcmFtZXRlcnM6XG4gKiBAcGFyYW0gIHtTZXR9ICAgICAgZGlzcGxheWVkTm9kZUxhYmVscyAgLSBDdXJyZW50bHkgZGlzcGxheWVkIG5vZGUgbGFiZWxzLlxuICogQHBhcmFtICB7U2V0fSAgICAgIGhpZ2hsaWdodGVkTm9kZXMgICAgIC0gSGlnaGxpZ2h0ZWQgbm9kZXMuXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggICAgICAgICAgICAgICAgLSBUaGUgcmVuZGVyZWQgZ3JhcGguXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgaG92ZXJlZE5vZGUgICAgICAgICAgLSBIb3ZlcmVkIG5vZGUgKG9wdGlvbmFsKVxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIHNlbGVjdGVkIGxhYmVscy5cbiAqL1xuZnVuY3Rpb24gZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2RlcyhwYXJhbXMpIHtcbiAgICB2YXIgZ3JhcGggPSBwYXJhbXMuZ3JhcGgsIGhvdmVyZWROb2RlID0gcGFyYW1zLmhvdmVyZWROb2RlLCBoaWdobGlnaHRlZE5vZGVzID0gcGFyYW1zLmhpZ2hsaWdodGVkTm9kZXMsIGRpc3BsYXllZE5vZGVMYWJlbHMgPSBwYXJhbXMuZGlzcGxheWVkTm9kZUxhYmVscztcbiAgICB2YXIgd29ydGh5RWRnZXMgPSBbXTtcbiAgICAvLyBUT0RPOiB0aGUgY29kZSBiZWxvdyBjYW4gYmUgb3B0aW1pemVkIHVzaW5nICMuZm9yRWFjaCBhbmQgYmF0Y2hpbmcgdGhlIGNvZGUgcGVyIGFkalxuICAgIC8vIFdlIHNob3VsZCBkaXNwbGF5IGFuIGVkZ2UncyBsYWJlbCBpZjpcbiAgICAvLyAgIC0gQW55IG9mIGl0cyBleHRyZW1pdGllcyBpcyBoaWdobGlnaHRlZCBvciBob3ZlcmVkXG4gICAgLy8gICAtIEJvdGggb2YgaXRzIGV4dHJlbWl0aWVzIGhhcyBpdHMgbGFiZWwgc2hvd25cbiAgICBncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgXywgc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gaG92ZXJlZE5vZGUgfHxcbiAgICAgICAgICAgIHRhcmdldCA9PT0gaG92ZXJlZE5vZGUgfHxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkTm9kZXMuaGFzKHNvdXJjZSkgfHxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkTm9kZXMuaGFzKHRhcmdldCkgfHxcbiAgICAgICAgICAgIChkaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyhzb3VyY2UpICYmIGRpc3BsYXllZE5vZGVMYWJlbHMuaGFzKHRhcmdldCkpKSB7XG4gICAgICAgICAgICB3b3J0aHlFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdvcnRoeUVkZ2VzO1xufVxuZXhwb3J0cy5lZGdlTGFiZWxzVG9EaXNwbGF5RnJvbU5vZGVzID0gZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2RlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWN0YW5nbGVDb2xsaWRlc1dpdGhRdWFkID0gZXhwb3J0cy5zcXVhcmVDb2xsaWRlc1dpdGhRdWFkID0gZXhwb3J0cy5nZXRDaXJjdW1zY3JpYmVkQWxpZ25lZFJlY3RhbmdsZSA9IGV4cG9ydHMuaXNSZWN0YW5nbGVBbGlnbmVkID0gdm9pZCAwO1xuLyoqXG4gKiBTaWdtYS5qcyBRdWFkIFRyZWUgQ2xhc3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBDbGFzcyBpbXBsZW1lbnRpbmcgdGhlIHF1YWQgdHJlZSBkYXRhIHN0cnVjdHVyZSB1c2VkIHRvIHNvbHZlIGhvdmVycyBhbmRcbiAqIGRldGVybWluZSB3aGljaCBlbGVtZW50cyBhcmUgY3VycmVudGx5IGluIHRoZSBzY29wZSBvZiB0aGUgY2FtZXJhIHNvIHRoYXRcbiAqIHdlIGRvbid0IHdhc3RlIHRpbWUgcmVuZGVyaW5nIHRoaW5ncyB0aGUgdXNlciBjYW5ub3Qgc2VlIGFueXdheS5cbiAqIEBtb2R1bGVcbiAqL1xuLyogZXNsaW50IG5vLW5lc3RlZC10ZXJuYXJ5OiAwICovXG4vKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOiAwICovXG52YXIgZXh0ZW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkB5b21ndWl0aGVyZWFsL2hlbHBlcnMvZXh0ZW5kXCIpKTtcbi8vIFRPRE86IHNob3VsZCBub3QgYXNrIHRoZSBxdWFkdHJlZSB3aGVuIHRoZSBjYW1lcmEgaGFzIHRoZSB3aG9sZSBncmFwaCBpblxuLy8gc2lnaHQuXG4vLyBUT0RPOiBhIHNxdWFyZSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgdG9wbGVmdCArIHdpZHRoLCBzYXlpbmcgZm9yIHRoZSBxdWFkIGJsb2NrcyAocmVkdWNlIG1lbSlcbi8vIFRPRE86IGpzZG9jXG4vLyBUT0RPOiBiZSBzdXJlIHdlIGNhbiBoYW5kbGUgY2FzZXMgb3ZlcmNvbWluZyBib3VuZGFyaWVzIChiZWNhdXNlIG9mIHNpemUpIG9yIHVzZSBhIG1heGVkIHNpemVcbi8vIFRPRE86IGZpbHRlcmluZyB1bndhbnRlZCBsYWJlbHMgYmVmb3JlaGFuZCB0aHJvdWdoIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbi8vIE5PVEU6IHRoaXMgaXMgYmFzaWNhbGx5IGEgTVgtQ0lGIFF1YWR0cmVlIGF0IHRoaXMgcG9pbnRcbi8vIE5PVEU6IG5lZWQgdG8gZXhwbG9yZSBSLVRyZWVzIGZvciBlZGdlc1xuLy8gTk9URTogbmVlZCB0byBleHBsb3JlIDJkIHNlZ21lbnQgdHJlZSBmb3IgZWRnZXNcbi8vIE5PVEU6IHByb2JhYmx5IGNhbiBkbyBmYXN0ZXIgdXNpbmcgc3BhdGlhbCBoYXNoaW5nXG4vKipcbiAqIENvbnN0YW50cy5cbiAqXG4gKiBOb3RlIHRoYXQgc2luY2Ugd2UgYXJlIHJlcHJlc2VudGluZyBhIHN0YXRpYyA0LWFyeSB0cmVlLCB0aGUgaW5kaWNlcyBvZiB0aGVcbiAqIHF1YWRyYW50cyBhcmUgdGhlIGZvbGxvd2luZzpcbiAqICAgLSBUT1BfTEVGVDogICAgIDRpICsgYlxuICogICAtIFRPUF9SSUdIVDogICAgNGkgKyAyYlxuICogICAtIEJPVFRPTV9MRUZUOiAgNGkgKyAzYlxuICogICAtIEJPVFRPTV9SSUdIVDogNGkgKyA0YlxuICovXG52YXIgQkxPQ0tTID0gNCwgTUFYX0xFVkVMID0gNTtcbnZhciBPVVRTSURFX0JMT0NLID0gXCJvdXRzaWRlXCI7XG52YXIgWF9PRkZTRVQgPSAwLCBZX09GRlNFVCA9IDEsIFdJRFRIX09GRlNFVCA9IDIsIEhFSUdIVF9PRkZTRVQgPSAzO1xudmFyIFRPUF9MRUZUID0gMSwgVE9QX1JJR0hUID0gMiwgQk9UVE9NX0xFRlQgPSAzLCBCT1RUT01fUklHSFQgPSA0O1xudmFyIGhhc1dhcm5lZFRvb011Y2hPdXRzaWRlID0gZmFsc2U7XG4vKipcbiAqIEdlb21ldHJ5IGhlbHBlcnMuXG4gKi9cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gKlxuICogQHBhcmFtICB7UmVjdGFuZ2xlfSByZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlY3RhbmdsZUFsaWduZWQocmVjdCkge1xuICAgIHJldHVybiByZWN0LngxID09PSByZWN0LngyIHx8IHJlY3QueTEgPT09IHJlY3QueTI7XG59XG5leHBvcnRzLmlzUmVjdGFuZ2xlQWxpZ25lZCA9IGlzUmVjdGFuZ2xlQWxpZ25lZDtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBzbWFsbGVzdCByZWN0YW5nbGUgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLCBhbmQgdGhhdCBpcyBhbGlnbmVkIHdpdGggdGhlIGF4aXMuXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2lyY3Vtc2NyaWJlZEFsaWduZWRSZWN0YW5nbGUocmVjdCkge1xuICAgIHZhciB3aWR0aCA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0LngyIC0gcmVjdC54MSwgMikgKyBNYXRoLnBvdyhyZWN0LnkyIC0gcmVjdC55MSwgMikpO1xuICAgIHZhciBoZWlnaHRWZWN0b3IgPSB7XG4gICAgICAgIHg6ICgocmVjdC55MSAtIHJlY3QueTIpICogcmVjdC5oZWlnaHQpIC8gd2lkdGgsXG4gICAgICAgIHk6ICgocmVjdC54MiAtIHJlY3QueDEpICogcmVjdC5oZWlnaHQpIC8gd2lkdGgsXG4gICAgfTtcbiAgICAvLyBDb21wdXRlIGFsbCBjb3JuZXJzOlxuICAgIHZhciB0bCA9IHsgeDogcmVjdC54MSwgeTogcmVjdC55MSB9O1xuICAgIHZhciB0ciA9IHsgeDogcmVjdC54MiwgeTogcmVjdC55MiB9O1xuICAgIHZhciBibCA9IHtcbiAgICAgICAgeDogcmVjdC54MSArIGhlaWdodFZlY3Rvci54LFxuICAgICAgICB5OiByZWN0LnkxICsgaGVpZ2h0VmVjdG9yLnksXG4gICAgfTtcbiAgICB2YXIgYnIgPSB7XG4gICAgICAgIHg6IHJlY3QueDIgKyBoZWlnaHRWZWN0b3IueCxcbiAgICAgICAgeTogcmVjdC55MiArIGhlaWdodFZlY3Rvci55LFxuICAgIH07XG4gICAgdmFyIHhMID0gTWF0aC5taW4odGwueCwgdHIueCwgYmwueCwgYnIueCk7XG4gICAgdmFyIHhSID0gTWF0aC5tYXgodGwueCwgdHIueCwgYmwueCwgYnIueCk7XG4gICAgdmFyIHlUID0gTWF0aC5taW4odGwueSwgdHIueSwgYmwueSwgYnIueSk7XG4gICAgdmFyIHlCID0gTWF0aC5tYXgodGwueSwgdHIueSwgYmwueSwgYnIueSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHhMLFxuICAgICAgICB5MTogeVQsXG4gICAgICAgIHgyOiB4UixcbiAgICAgICAgeTI6IHlULFxuICAgICAgICBoZWlnaHQ6IHlCIC0geVQsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0Q2lyY3Vtc2NyaWJlZEFsaWduZWRSZWN0YW5nbGUgPSBnZXRDaXJjdW1zY3JpYmVkQWxpZ25lZFJlY3RhbmdsZTtcbi8qKlxuICpcbiAqIEBwYXJhbSB4MVxuICogQHBhcmFtIHkxXG4gKiBAcGFyYW0gd1xuICogQHBhcmFtIHF4XG4gKiBAcGFyYW0gcXlcbiAqIEBwYXJhbSBxd1xuICogQHBhcmFtIHFoXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZUNvbGxpZGVzV2l0aFF1YWQoeDEsIHkxLCB3LCBxeCwgcXksIHF3LCBxaCkge1xuICAgIHJldHVybiB4MSA8IHF4ICsgcXcgJiYgeDEgKyB3ID4gcXggJiYgeTEgPCBxeSArIHFoICYmIHkxICsgdyA+IHF5O1xufVxuZXhwb3J0cy5zcXVhcmVDb2xsaWRlc1dpdGhRdWFkID0gc3F1YXJlQ29sbGlkZXNXaXRoUXVhZDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUNvbGxpZGVzV2l0aFF1YWQoeDEsIHkxLCB3LCBoLCBxeCwgcXksIHF3LCBxaCkge1xuICAgIHJldHVybiB4MSA8IHF4ICsgcXcgJiYgeDEgKyB3ID4gcXggJiYgeTEgPCBxeSArIHFoICYmIHkxICsgaCA+IHF5O1xufVxuZXhwb3J0cy5yZWN0YW5nbGVDb2xsaWRlc1dpdGhRdWFkID0gcmVjdGFuZ2xlQ29sbGlkZXNXaXRoUXVhZDtcbmZ1bmN0aW9uIHBvaW50SXNJblF1YWQoeCwgeSwgcXgsIHF5LCBxdywgcWgpIHtcbiAgICB2YXIgeG1wID0gcXggKyBxdyAvIDIsIHltcCA9IHF5ICsgcWggLyAyLCB0b3AgPSB5IDwgeW1wLCBsZWZ0ID0geCA8IHhtcDtcbiAgICByZXR1cm4gdG9wID8gKGxlZnQgPyBUT1BfTEVGVCA6IFRPUF9SSUdIVCkgOiBsZWZ0ID8gQk9UVE9NX0xFRlQgOiBCT1RUT01fUklHSFQ7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdGhhdCBhcmUgbm90IGJvdW5kIHRvIHRoZSBjbGFzcyBzbyBhbiBleHRlcm5hbCB1c2VyXG4gKiBjYW5ub3QgbWVzcyB3aXRoIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUXVhZHJhbnRzKG1heExldmVsLCBkYXRhKSB7XG4gICAgLy8gW2Jsb2NrLCBsZXZlbF1cbiAgICB2YXIgc3RhY2sgPSBbMCwgMF07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBzdGFjay5wb3AoKSwgYmxvY2sgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHRvcExlZnRCbG9jayA9IDQgKiBibG9jayArIEJMT0NLUywgdG9wUmlnaHRCbG9jayA9IDQgKiBibG9jayArIDIgKiBCTE9DS1MsIGJvdHRvbUxlZnRCbG9jayA9IDQgKiBibG9jayArIDMgKiBCTE9DS1MsIGJvdHRvbVJpZ2h0QmxvY2sgPSA0ICogYmxvY2sgKyA0ICogQkxPQ0tTO1xuICAgICAgICB2YXIgeCA9IGRhdGFbYmxvY2sgKyBYX09GRlNFVF0sIHkgPSBkYXRhW2Jsb2NrICsgWV9PRkZTRVRdLCB3aWR0aCA9IGRhdGFbYmxvY2sgKyBXSURUSF9PRkZTRVRdLCBoZWlnaHQgPSBkYXRhW2Jsb2NrICsgSEVJR0hUX09GRlNFVF0sIGh3ID0gd2lkdGggLyAyLCBoaCA9IGhlaWdodCAvIDI7XG4gICAgICAgIGRhdGFbdG9wTGVmdEJsb2NrICsgWF9PRkZTRVRdID0geDtcbiAgICAgICAgZGF0YVt0b3BMZWZ0QmxvY2sgKyBZX09GRlNFVF0gPSB5O1xuICAgICAgICBkYXRhW3RvcExlZnRCbG9jayArIFdJRFRIX09GRlNFVF0gPSBodztcbiAgICAgICAgZGF0YVt0b3BMZWZ0QmxvY2sgKyBIRUlHSFRfT0ZGU0VUXSA9IGhoO1xuICAgICAgICBkYXRhW3RvcFJpZ2h0QmxvY2sgKyBYX09GRlNFVF0gPSB4ICsgaHc7XG4gICAgICAgIGRhdGFbdG9wUmlnaHRCbG9jayArIFlfT0ZGU0VUXSA9IHk7XG4gICAgICAgIGRhdGFbdG9wUmlnaHRCbG9jayArIFdJRFRIX09GRlNFVF0gPSBodztcbiAgICAgICAgZGF0YVt0b3BSaWdodEJsb2NrICsgSEVJR0hUX09GRlNFVF0gPSBoaDtcbiAgICAgICAgZGF0YVtib3R0b21MZWZ0QmxvY2sgKyBYX09GRlNFVF0gPSB4O1xuICAgICAgICBkYXRhW2JvdHRvbUxlZnRCbG9jayArIFlfT0ZGU0VUXSA9IHkgKyBoaDtcbiAgICAgICAgZGF0YVtib3R0b21MZWZ0QmxvY2sgKyBXSURUSF9PRkZTRVRdID0gaHc7XG4gICAgICAgIGRhdGFbYm90dG9tTGVmdEJsb2NrICsgSEVJR0hUX09GRlNFVF0gPSBoaDtcbiAgICAgICAgZGF0YVtib3R0b21SaWdodEJsb2NrICsgWF9PRkZTRVRdID0geCArIGh3O1xuICAgICAgICBkYXRhW2JvdHRvbVJpZ2h0QmxvY2sgKyBZX09GRlNFVF0gPSB5ICsgaGg7XG4gICAgICAgIGRhdGFbYm90dG9tUmlnaHRCbG9jayArIFdJRFRIX09GRlNFVF0gPSBodztcbiAgICAgICAgZGF0YVtib3R0b21SaWdodEJsb2NrICsgSEVJR0hUX09GRlNFVF0gPSBoaDtcbiAgICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwgLSAxKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGJvdHRvbVJpZ2h0QmxvY2ssIGxldmVsICsgMSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGJvdHRvbUxlZnRCbG9jaywgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9wUmlnaHRCbG9jaywgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9wTGVmdEJsb2NrLCBsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShtYXhMZXZlbCwgZGF0YSwgY29udGFpbmVycywga2V5LCB4LCB5LCBzaXplKSB7XG4gICAgdmFyIHgxID0geCAtIHNpemUsIHkxID0geSAtIHNpemUsIHcgPSBzaXplICogMjtcbiAgICB2YXIgbGV2ZWwgPSAwLCBibG9jayA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBtYXggbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsID49IG1heExldmVsKSB7XG4gICAgICAgICAgICBjb250YWluZXJzW2Jsb2NrXSA9IGNvbnRhaW5lcnNbYmxvY2tdIHx8IFtdO1xuICAgICAgICAgICAgY29udGFpbmVyc1tibG9ja10ucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3BMZWZ0QmxvY2sgPSA0ICogYmxvY2sgKyBCTE9DS1MsIHRvcFJpZ2h0QmxvY2sgPSA0ICogYmxvY2sgKyAyICogQkxPQ0tTLCBib3R0b21MZWZ0QmxvY2sgPSA0ICogYmxvY2sgKyAzICogQkxPQ0tTLCBib3R0b21SaWdodEJsb2NrID0gNCAqIGJsb2NrICsgNCAqIEJMT0NLUztcbiAgICAgICAgdmFyIGNvbGxpZGluZ1dpdGhUb3BMZWZ0ID0gc3F1YXJlQ29sbGlkZXNXaXRoUXVhZCh4MSwgeTEsIHcsIGRhdGFbdG9wTGVmdEJsb2NrICsgWF9PRkZTRVRdLCBkYXRhW3RvcExlZnRCbG9jayArIFlfT0ZGU0VUXSwgZGF0YVt0b3BMZWZ0QmxvY2sgKyBXSURUSF9PRkZTRVRdLCBkYXRhW3RvcExlZnRCbG9jayArIEhFSUdIVF9PRkZTRVRdKTtcbiAgICAgICAgdmFyIGNvbGxpZGluZ1dpdGhUb3BSaWdodCA9IHNxdWFyZUNvbGxpZGVzV2l0aFF1YWQoeDEsIHkxLCB3LCBkYXRhW3RvcFJpZ2h0QmxvY2sgKyBYX09GRlNFVF0sIGRhdGFbdG9wUmlnaHRCbG9jayArIFlfT0ZGU0VUXSwgZGF0YVt0b3BSaWdodEJsb2NrICsgV0lEVEhfT0ZGU0VUXSwgZGF0YVt0b3BSaWdodEJsb2NrICsgSEVJR0hUX09GRlNFVF0pO1xuICAgICAgICB2YXIgY29sbGlkaW5nV2l0aEJvdHRvbUxlZnQgPSBzcXVhcmVDb2xsaWRlc1dpdGhRdWFkKHgxLCB5MSwgdywgZGF0YVtib3R0b21MZWZ0QmxvY2sgKyBYX09GRlNFVF0sIGRhdGFbYm90dG9tTGVmdEJsb2NrICsgWV9PRkZTRVRdLCBkYXRhW2JvdHRvbUxlZnRCbG9jayArIFdJRFRIX09GRlNFVF0sIGRhdGFbYm90dG9tTGVmdEJsb2NrICsgSEVJR0hUX09GRlNFVF0pO1xuICAgICAgICB2YXIgY29sbGlkaW5nV2l0aEJvdHRvbVJpZ2h0ID0gc3F1YXJlQ29sbGlkZXNXaXRoUXVhZCh4MSwgeTEsIHcsIGRhdGFbYm90dG9tUmlnaHRCbG9jayArIFhfT0ZGU0VUXSwgZGF0YVtib3R0b21SaWdodEJsb2NrICsgWV9PRkZTRVRdLCBkYXRhW2JvdHRvbVJpZ2h0QmxvY2sgKyBXSURUSF9PRkZTRVRdLCBkYXRhW2JvdHRvbVJpZ2h0QmxvY2sgKyBIRUlHSFRfT0ZGU0VUXSk7XG4gICAgICAgIHZhciBjb2xsaXNpb25zID0gW1xuICAgICAgICAgICAgY29sbGlkaW5nV2l0aFRvcExlZnQsXG4gICAgICAgICAgICBjb2xsaWRpbmdXaXRoVG9wUmlnaHQsXG4gICAgICAgICAgICBjb2xsaWRpbmdXaXRoQm90dG9tTGVmdCxcbiAgICAgICAgICAgIGNvbGxpZGluZ1dpdGhCb3R0b21SaWdodCxcbiAgICAgICAgXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gY29sbGlzaW9uIGF0IHJvb3QgbGV2ZWwsIGluamVjdCBub2RlIGluIHRoZSBvdXRzaWRlIGJsb2NrXG4gICAgICAgIGlmIChjb2xsaXNpb25zID09PSAwICYmIGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBjb250YWluZXJzW09VVFNJREVfQkxPQ0tdLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkVG9vTXVjaE91dHNpZGUgJiYgY29udGFpbmVyc1tPVVRTSURFX0JMT0NLXS5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgICAgIGhhc1dhcm5lZFRvb011Y2hPdXRzaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWdtYS9xdWFkdHJlZS5pbnNlcnROb2RlOiBBdCBsZWFzdCA1IG5vZGVzIGFyZSBvdXRzaWRlIHRoZSBnbG9iYWwgcXVhZHRyZWUgem9uZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIllvdSBtaWdodCBoYXZlIGEgcHJvYmxlbSB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGZ1bmN0aW9uIG9yIHRoZSBjdXN0b20gYm91bmRpbmcgYm94LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGF0IGxlYXN0IGEgY29sbGlzaW9uIGJ1dCBkZWVwZXIsIHRoZXJlIGlzIGFuIGlzc3VlXG4gICAgICAgIGlmIChjb2xsaXNpb25zID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbWEvcXVhZHRyZWUuaW5zZXJ0Tm9kZTogbm8gY29sbGlzaW9uIChsZXZlbDogXCIuY29uY2F0KGxldmVsLCBcIiwga2V5OiBcIikuY29uY2F0KGtleSwgXCIsIHg6IFwiKS5jb25jYXQoeCwgXCIsIHk6IFwiKS5jb25jYXQoeSwgXCIsIHNpemU6IFwiKS5jb25jYXQoc2l6ZSwgXCIpLlwiKSk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgMyBjb2xsaXNpb25zLCB3ZSBoYXZlIGEgZ2VvbWV0cnkgcHJvYmxlbSBvYnZpb3VzbHlcbiAgICAgICAgaWYgKGNvbGxpc2lvbnMgPT09IDMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWdtYS9xdWFkdHJlZS5pbnNlcnROb2RlOiAzIGltcG9zc2libGUgY29sbGlzaW9ucyAobGV2ZWw6IFwiLmNvbmNhdChsZXZlbCwgXCIsIGtleTogXCIpLmNvbmNhdChrZXksIFwiLCB4OiBcIikuY29uY2F0KHgsIFwiLCB5OiBcIikuY29uY2F0KHksIFwiLCBzaXplOiBcIikuY29uY2F0KHNpemUsIFwiKS5cIikpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhdCBvbmUgY29sbGlzaW9uLCB3ZSBzdG9wIGhlcmUgYW5kIHN0b3JlIHRoZSBub2RlXG4gICAgICAgIC8vIGluIHRoZSByZWxldmFudCBjb250YWluZXJzXG4gICAgICAgIGlmIChjb2xsaXNpb25zID4gMSkge1xuICAgICAgICAgICAgY29udGFpbmVyc1tibG9ja10gPSBjb250YWluZXJzW2Jsb2NrXSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnRhaW5lcnNbYmxvY2tdLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB3ZSByZWN1cnNlIGludG8gdGhlIGNvcnJlY3QgcXVhZHNcbiAgICAgICAgaWYgKGNvbGxpZGluZ1dpdGhUb3BMZWZ0KVxuICAgICAgICAgICAgYmxvY2sgPSB0b3BMZWZ0QmxvY2s7XG4gICAgICAgIGlmIChjb2xsaWRpbmdXaXRoVG9wUmlnaHQpXG4gICAgICAgICAgICBibG9jayA9IHRvcFJpZ2h0QmxvY2s7XG4gICAgICAgIGlmIChjb2xsaWRpbmdXaXRoQm90dG9tTGVmdClcbiAgICAgICAgICAgIGJsb2NrID0gYm90dG9tTGVmdEJsb2NrO1xuICAgICAgICBpZiAoY29sbGlkaW5nV2l0aEJvdHRvbVJpZ2h0KVxuICAgICAgICAgICAgYmxvY2sgPSBib3R0b21SaWdodEJsb2NrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE5vZGVzSW5BeGlzQWxpZ25lZFJlY3RhbmdsZUFyZWEobWF4TGV2ZWwsIGRhdGEsIGNvbnRhaW5lcnMsIHgxLCB5MSwgdywgaCkge1xuICAgIC8vIFtibG9jaywgbGV2ZWxdXG4gICAgdmFyIHN0YWNrID0gWzAsIDBdO1xuICAgIHZhciBjb2xsZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb250YWluZXI7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBzdGFjay5wb3AoKSwgYmxvY2sgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgLy8gQ29sbGVjdGluZyBub2Rlc1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJzW2Jsb2NrXTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgICAgICgwLCBleHRlbmRfMS5kZWZhdWx0KShjb2xsZWN0ZWROb2RlcywgY29udGFpbmVyKTtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBtYXggbGV2ZWxcbiAgICAgICAgaWYgKGxldmVsID49IG1heExldmVsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciB0b3BMZWZ0QmxvY2sgPSA0ICogYmxvY2sgKyBCTE9DS1MsIHRvcFJpZ2h0QmxvY2sgPSA0ICogYmxvY2sgKyAyICogQkxPQ0tTLCBib3R0b21MZWZ0QmxvY2sgPSA0ICogYmxvY2sgKyAzICogQkxPQ0tTLCBib3R0b21SaWdodEJsb2NrID0gNCAqIGJsb2NrICsgNCAqIEJMT0NLUztcbiAgICAgICAgdmFyIGNvbGxpZGluZ1dpdGhUb3BMZWZ0ID0gcmVjdGFuZ2xlQ29sbGlkZXNXaXRoUXVhZCh4MSwgeTEsIHcsIGgsIGRhdGFbdG9wTGVmdEJsb2NrICsgWF9PRkZTRVRdLCBkYXRhW3RvcExlZnRCbG9jayArIFlfT0ZGU0VUXSwgZGF0YVt0b3BMZWZ0QmxvY2sgKyBXSURUSF9PRkZTRVRdLCBkYXRhW3RvcExlZnRCbG9jayArIEhFSUdIVF9PRkZTRVRdKTtcbiAgICAgICAgdmFyIGNvbGxpZGluZ1dpdGhUb3BSaWdodCA9IHJlY3RhbmdsZUNvbGxpZGVzV2l0aFF1YWQoeDEsIHkxLCB3LCBoLCBkYXRhW3RvcFJpZ2h0QmxvY2sgKyBYX09GRlNFVF0sIGRhdGFbdG9wUmlnaHRCbG9jayArIFlfT0ZGU0VUXSwgZGF0YVt0b3BSaWdodEJsb2NrICsgV0lEVEhfT0ZGU0VUXSwgZGF0YVt0b3BSaWdodEJsb2NrICsgSEVJR0hUX09GRlNFVF0pO1xuICAgICAgICB2YXIgY29sbGlkaW5nV2l0aEJvdHRvbUxlZnQgPSByZWN0YW5nbGVDb2xsaWRlc1dpdGhRdWFkKHgxLCB5MSwgdywgaCwgZGF0YVtib3R0b21MZWZ0QmxvY2sgKyBYX09GRlNFVF0sIGRhdGFbYm90dG9tTGVmdEJsb2NrICsgWV9PRkZTRVRdLCBkYXRhW2JvdHRvbUxlZnRCbG9jayArIFdJRFRIX09GRlNFVF0sIGRhdGFbYm90dG9tTGVmdEJsb2NrICsgSEVJR0hUX09GRlNFVF0pO1xuICAgICAgICB2YXIgY29sbGlkaW5nV2l0aEJvdHRvbVJpZ2h0ID0gcmVjdGFuZ2xlQ29sbGlkZXNXaXRoUXVhZCh4MSwgeTEsIHcsIGgsIGRhdGFbYm90dG9tUmlnaHRCbG9jayArIFhfT0ZGU0VUXSwgZGF0YVtib3R0b21SaWdodEJsb2NrICsgWV9PRkZTRVRdLCBkYXRhW2JvdHRvbVJpZ2h0QmxvY2sgKyBXSURUSF9PRkZTRVRdLCBkYXRhW2JvdHRvbVJpZ2h0QmxvY2sgKyBIRUlHSFRfT0ZGU0VUXSk7XG4gICAgICAgIGlmIChjb2xsaWRpbmdXaXRoVG9wTGVmdClcbiAgICAgICAgICAgIHN0YWNrLnB1c2godG9wTGVmdEJsb2NrLCBsZXZlbCArIDEpO1xuICAgICAgICBpZiAoY29sbGlkaW5nV2l0aFRvcFJpZ2h0KVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0b3BSaWdodEJsb2NrLCBsZXZlbCArIDEpO1xuICAgICAgICBpZiAoY29sbGlkaW5nV2l0aEJvdHRvbUxlZnQpXG4gICAgICAgICAgICBzdGFjay5wdXNoKGJvdHRvbUxlZnRCbG9jaywgbGV2ZWwgKyAxKTtcbiAgICAgICAgaWYgKGNvbGxpZGluZ1dpdGhCb3R0b21SaWdodClcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYm90dG9tUmlnaHRCbG9jaywgbGV2ZWwgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3RlZE5vZGVzO1xufVxuLyoqXG4gKiBRdWFkVHJlZSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZGFyaWVzIC0gVGhlIGdyYXBoIGJvdW5kYXJpZXMuXG4gKi9cbnZhciBRdWFkVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWFkVHJlZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgdGhpcy5jb250YWluZXJzID0gKF9hID0ge30sIF9hW09VVFNJREVfQkxPQ0tdID0gW10sIF9hKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFJlY3RhbmdsZSA9IG51bGw7XG4gICAgICAgIC8vIEFsbG9jYXRpbmcgdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheVxuICAgICAgICB2YXIgTCA9IE1hdGgucG93KDQsIE1BWF9MRVZFTCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoQkxPQ0tTICogKCg0ICogTCAtIDEpIC8gMykpO1xuICAgICAgICBpZiAocGFyYW1zLmJvdW5kYXJpZXMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShwYXJhbXMuYm91bmRhcmllcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIFF1YWRUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5LCB4LCB5LCBzaXplKSB7XG4gICAgICAgIGluc2VydE5vZGUoTUFYX0xFVkVMLCB0aGlzLmRhdGEsIHRoaXMuY29udGFpbmVycywga2V5LCB4LCB5LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBRdWFkVHJlZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGJvdW5kYXJpZXMpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAvLyBCdWlsZGluZyB0aGUgcXVhZHJhbnRzXG4gICAgICAgIHRoaXMuZGF0YVtYX09GRlNFVF0gPSBib3VuZGFyaWVzLng7XG4gICAgICAgIHRoaXMuZGF0YVtZX09GRlNFVF0gPSBib3VuZGFyaWVzLnk7XG4gICAgICAgIHRoaXMuZGF0YVtXSURUSF9PRkZTRVRdID0gYm91bmRhcmllcy53aWR0aDtcbiAgICAgICAgdGhpcy5kYXRhW0hFSUdIVF9PRkZTRVRdID0gYm91bmRhcmllcy5oZWlnaHQ7XG4gICAgICAgIGJ1aWxkUXVhZHJhbnRzKE1BWF9MRVZFTCwgdGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIFF1YWRUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNvbnRhaW5lcnMgPSAoX2EgPSB7fSwgX2FbT1VUU0lERV9CTE9DS10gPSBbXSwgX2EpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFF1YWRUcmVlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuY29udGFpbmVyc1tPVVRTSURFX0JMT0NLXTtcbiAgICAgICAgdmFyIGJsb2NrID0gMCwgbGV2ZWwgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXJzW2Jsb2NrXSlcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodGhpcy5jb250YWluZXJzW2Jsb2NrXSksIGZhbHNlKSk7XG4gICAgICAgICAgICB2YXIgcXVhZCA9IHBvaW50SXNJblF1YWQoeCwgeSwgdGhpcy5kYXRhW2Jsb2NrICsgWF9PRkZTRVRdLCB0aGlzLmRhdGFbYmxvY2sgKyBZX09GRlNFVF0sIHRoaXMuZGF0YVtibG9jayArIFdJRFRIX09GRlNFVF0sIHRoaXMuZGF0YVtibG9jayArIEhFSUdIVF9PRkZTRVRdKTtcbiAgICAgICAgICAgIGJsb2NrID0gNCAqIGJsb2NrICsgcXVhZCAqIEJMT0NLUztcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH0gd2hpbGUgKGxldmVsIDw9IE1BWF9MRVZFTCk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIFF1YWRUcmVlLnByb3RvdHlwZS5yZWN0YW5nbGUgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIGhlaWdodCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBsciA9IHRoaXMubGFzdFJlY3RhbmdsZTtcbiAgICAgICAgaWYgKGxyICYmIHgxID09PSBsci54MSAmJiB4MiA9PT0gbHIueDIgJiYgeTEgPT09IGxyLnkxICYmIHkyID09PSBsci55MiAmJiBoZWlnaHQgPT09IGxyLmhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0UmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHRoZSByZWN0YW5nbGUgaXMgc2hpZnRlZCwgd2UgdXNlIHRoZSBzbWFsbGVzdCBhbGlnbmVkIHJlY3RhbmdsZSB0aGF0IGNvbnRhaW5zIHRoZSBzaGlmdGVkIG9uZTpcbiAgICAgICAgaWYgKCFpc1JlY3RhbmdsZUFsaWduZWQodGhpcy5sYXN0UmVjdGFuZ2xlKSlcbiAgICAgICAgICAgIHRoaXMubGFzdFJlY3RhbmdsZSA9IGdldENpcmN1bXNjcmliZWRBbGlnbmVkUmVjdGFuZ2xlKHRoaXMubGFzdFJlY3RhbmdsZSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBnZXROb2Rlc0luQXhpc0FsaWduZWRSZWN0YW5nbGVBcmVhKE1BWF9MRVZFTCwgdGhpcy5kYXRhLCB0aGlzLmNvbnRhaW5lcnMsIHgxLCB5MSwgTWF0aC5hYnMoeDEgLSB4MikgfHwgTWF0aC5hYnMoeTEgLSB5MiksIGhlaWdodCk7XG4gICAgICAgIC8vIEFkZCBhbGwgdGhlIG5vZGVzIGluIHRoZSBvdXRzaWRlIGJsb2NrLCBzaW5jZSB0aGV5IG1pZ2h0IGJlIHJlbGV2YW50LCBhbmQgc2luY2UgdGhleSBzaG91bGQgYmUgdmVyeSBmZXc6XG4gICAgICAgIChfYSA9IHRoaXMuY2FjaGUpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLmNvbnRhaW5lcnNbT1VUU0lERV9CTE9DS10pLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgICB9O1xuICAgIHJldHVybiBRdWFkVHJlZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWFkVHJlZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWdtYSA9IGV4cG9ydHMuTW91c2VDYXB0b3IgPSBleHBvcnRzLlF1YWRUcmVlID0gZXhwb3J0cy5DYW1lcmEgPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIExpYnJhcnkgRW5kcG9pbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlicmFyeSBlbmRwb2ludC5cbiAqIEBtb2R1bGVcbiAqL1xudmFyIHNpZ21hXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2lnbWFcIikpO1xuZXhwb3J0cy5TaWdtYSA9IHNpZ21hXzEuZGVmYXVsdDtcbnZhciBjYW1lcmFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlL2NhbWVyYVwiKSk7XG5leHBvcnRzLkNhbWVyYSA9IGNhbWVyYV8xLmRlZmF1bHQ7XG52YXIgcXVhZHRyZWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlL3F1YWR0cmVlXCIpKTtcbmV4cG9ydHMuUXVhZFRyZWUgPSBxdWFkdHJlZV8xLmRlZmF1bHQ7XG52YXIgbW91c2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlL2NhcHRvcnMvbW91c2VcIikpO1xuZXhwb3J0cy5Nb3VzZUNhcHRvciA9IG1vdXNlXzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IHNpZ21hXzEuZGVmYXVsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZHJhd0VkZ2VMYWJlbChjb250ZXh0LCBlZGdlRGF0YSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmVkZ2VMYWJlbFNpemUsIGZvbnQgPSBzZXR0aW5ncy5lZGdlTGFiZWxGb250LCB3ZWlnaHQgPSBzZXR0aW5ncy5lZGdlTGFiZWxXZWlnaHQsIGNvbG9yID0gc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuYXR0cmlidXRlXG4gICAgICAgID8gZWRnZURhdGFbc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuYXR0cmlidXRlXSB8fCBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5jb2xvciB8fCBcIiMwMDBcIlxuICAgICAgICA6IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmNvbG9yO1xuICAgIHZhciBsYWJlbCA9IGVkZ2VEYXRhLmxhYmVsO1xuICAgIGlmICghbGFiZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG4gICAgLy8gQ29tcHV0aW5nIHBvc2l0aW9ucyB3aXRob3V0IGNvbnNpZGVyaW5nIG5vZGVzIHNpemVzOlxuICAgIHZhciBzU2l6ZSA9IHNvdXJjZURhdGEuc2l6ZTtcbiAgICB2YXIgdFNpemUgPSB0YXJnZXREYXRhLnNpemU7XG4gICAgdmFyIHN4ID0gc291cmNlRGF0YS54O1xuICAgIHZhciBzeSA9IHNvdXJjZURhdGEueTtcbiAgICB2YXIgdHggPSB0YXJnZXREYXRhLng7XG4gICAgdmFyIHR5ID0gdGFyZ2V0RGF0YS55O1xuICAgIHZhciBjeCA9IChzeCArIHR4KSAvIDI7XG4gICAgdmFyIGN5ID0gKHN5ICsgdHkpIC8gMjtcbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmIChkIDwgc1NpemUgKyB0U2l6ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEFkZGluZyBub2RlcyBzaXplczpcbiAgICBzeCArPSAoZHggKiBzU2l6ZSkgLyBkO1xuICAgIHN5ICs9IChkeSAqIHNTaXplKSAvIGQ7XG4gICAgdHggLT0gKGR4ICogdFNpemUpIC8gZDtcbiAgICB0eSAtPSAoZHkgKiB0U2l6ZSkgLyBkO1xuICAgIGN4ID0gKHN4ICsgdHgpIC8gMjtcbiAgICBjeSA9IChzeSArIHR5KSAvIDI7XG4gICAgZHggPSB0eCAtIHN4O1xuICAgIGR5ID0gdHkgLSBzeTtcbiAgICBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAvLyBIYW5kbGluZyBlbGxpcHNpc1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgaWYgKHRleHRMZW5ndGggPiBkKSB7XG4gICAgICAgIHZhciBlbGxpcHNpcyA9IFwi4oCmXCI7XG4gICAgICAgIGxhYmVsID0gbGFiZWwgKyBlbGxpcHNpcztcbiAgICAgICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgICAgICB3aGlsZSAodGV4dExlbmd0aCA+IGQgJiYgbGFiZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCAtMikgKyBlbGxpcHNpcztcbiAgICAgICAgICAgIHRleHRMZW5ndGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwubGVuZ3RoIDwgNClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFuZ2xlO1xuICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgaWYgKGR5ID4gMClcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZHkgPiAwKVxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZHggLyBkKSArIE1hdGguUEk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGR4IC8gZCkgKyBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgY29udGV4dC5maWxsVGV4dChsYWJlbCwgLXRleHRMZW5ndGggLyAyLCBlZGdlRGF0YS5zaXplIC8gMiArIHNpemUpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZHJhd0VkZ2VMYWJlbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxhYmVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGFiZWxcIikpO1xuLyoqXG4gKiBEcmF3IGFuIGhvdmVyZWQgbm9kZS5cbiAqIC0gaWYgdGhlcmUgaXMgbm8gbGFiZWwgPT4gZGlzcGxheSBhIHNoYWRvdyBvbiB0aGUgbm9kZVxuICogLSBpZiB0aGUgbGFiZWwgYm94IGlzIGJpZ2dlciB0aGFuIG5vZGUgc2l6ZSA9PiBkaXNwbGF5IGEgbGFiZWwgYm94IHRoYXQgY29udGFpbnMgdGhlIG5vZGUgd2l0aCBhIHNoYWRvd1xuICogLSBlbHNlIG5vZGUgd2l0aCBzaGFkb3cgYW5kIHRoZSBsYWJlbCBib3hcbiAqL1xuZnVuY3Rpb24gZHJhd0hvdmVyKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgdmFyIHNpemUgPSBzZXR0aW5ncy5sYWJlbFNpemUsIGZvbnQgPSBzZXR0aW5ncy5sYWJlbEZvbnQsIHdlaWdodCA9IHNldHRpbmdzLmxhYmVsV2VpZ2h0O1xuICAgIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG4gICAgLy8gVGhlbiB3ZSBkcmF3IHRoZSBsYWJlbCBiYWNrZ3JvdW5kXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gODtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCIjMDAwXCI7XG4gICAgdmFyIFBBRERJTkcgPSAyO1xuICAgIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgdGV4dFdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChkYXRhLmxhYmVsKS53aWR0aCwgYm94V2lkdGggPSBNYXRoLnJvdW5kKHRleHRXaWR0aCArIDUpLCBib3hIZWlnaHQgPSBNYXRoLnJvdW5kKHNpemUgKyAyICogUEFERElORyksIHJhZGl1cyA9IE1hdGgubWF4KGRhdGEuc2l6ZSwgc2l6ZSAvIDIpICsgUEFERElORztcbiAgICAgICAgdmFyIGFuZ2xlUmFkaWFuID0gTWF0aC5hc2luKGJveEhlaWdodCAvIDIgLyByYWRpdXMpO1xuICAgICAgICB2YXIgeERlbHRhQ29vcmQgPSBNYXRoLnNxcnQoTWF0aC5hYnMoTWF0aC5wb3cocmFkaXVzLCAyKSAtIE1hdGgucG93KGJveEhlaWdodCAvIDIsIDIpKSk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGRhdGEueCArIHhEZWx0YUNvb3JkLCBkYXRhLnkgKyBib3hIZWlnaHQgLyAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgcmFkaXVzICsgYm94V2lkdGgsIGRhdGEueSArIGJveEhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyByYWRpdXMgKyBib3hXaWR0aCwgZGF0YS55IC0gYm94SGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHhEZWx0YUNvb3JkLCBkYXRhLnkgLSBib3hIZWlnaHQgLyAyKTtcbiAgICAgICAgY29udGV4dC5hcmMoZGF0YS54LCBkYXRhLnksIHJhZGl1cywgYW5nbGVSYWRpYW4sIC1hbmdsZVJhZGlhbik7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5hcmMoZGF0YS54LCBkYXRhLnksIGRhdGEuc2l6ZSArIFBBRERJTkcsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIC8vIEFuZCBmaW5hbGx5IHdlIGRyYXcgdGhlIGxhYmVsXG4gICAgKDAsIGxhYmVsXzEuZGVmYXVsdCkoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZHJhd0hvdmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkcmF3TGFiZWwoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBpZiAoIWRhdGEubGFiZWwpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmxhYmVsU2l6ZSwgZm9udCA9IHNldHRpbmdzLmxhYmVsRm9udCwgd2VpZ2h0ID0gc2V0dGluZ3MubGFiZWxXZWlnaHQsIGNvbG9yID0gc2V0dGluZ3MubGFiZWxDb2xvci5hdHRyaWJ1dGVcbiAgICAgICAgPyBkYXRhW3NldHRpbmdzLmxhYmVsQ29sb3IuYXR0cmlidXRlXSB8fCBzZXR0aW5ncy5sYWJlbENvbG9yLmNvbG9yIHx8IFwiIzAwMFwiXG4gICAgICAgIDogc2V0dGluZ3MubGFiZWxDb2xvci5jb2xvcjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG4gICAgY29udGV4dC5maWxsVGV4dChkYXRhLmxhYmVsLCBkYXRhLnggKyBkYXRhLnNpemUgKyAzLCBkYXRhLnkgKyBzaXplIC8gMyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkcmF3TGFiZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0gPSBleHBvcnRzLkFic3RyYWN0RWRnZVByb2dyYW0gPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIEFic3RyYWN0IEVkZ2UgUHJvZ3JhbVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEBtb2R1bGVcbiAqL1xudmFyIHByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL3Byb2dyYW1cIik7XG4vKipcbiAqIEVkZ2UgUHJvZ3JhbSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFic3RyYWN0RWRnZVByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0RWRnZVByb2dyYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RFZGdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgcG9pbnRzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgcG9pbnRzLCBhdHRyaWJ1dGVzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQWJzdHJhY3RFZGdlUHJvZ3JhbTtcbn0ocHJvZ3JhbV8xLkFic3RyYWN0UHJvZ3JhbSkpO1xuZXhwb3J0cy5BYnN0cmFjdEVkZ2VQcm9ncmFtID0gQWJzdHJhY3RFZGdlUHJvZ3JhbTtcbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0ocHJvZ3JhbUNsYXNzZXMpIHtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFZGdlQ29tcG91bmRQcm9ncmFtKGdsLCByZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoUHJvZ3JhbUNsYXNzKSB7IHJldHVybiBuZXcgUHJvZ3JhbUNsYXNzKGdsLCByZW5kZXJlcik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIEVkZ2VDb21wb3VuZFByb2dyYW0ucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHsgcmV0dXJuIHByb2dyYW0uYnVmZmVyRGF0YSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRWRnZUNvbXBvdW5kUHJvZ3JhbS5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkgeyByZXR1cm4gcHJvZ3JhbS5hbGxvY2F0ZShjYXBhY2l0eSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBFZGdlQ29tcG91bmRQcm9ncmFtLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0b2RvLCBpdCdzIGFscmVhZHkgZG9uZSBpbiBlYWNoIHByb2dyYW0gY29uc3RydWN0b3JcbiAgICAgICAgfTtcbiAgICAgICAgRWRnZUNvbXBvdW5kUHJvZ3JhbS5wcm90b3R5cGUuY29tcHV0ZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHsgcmV0dXJuIHByb2dyYW0uY29tcHV0ZUluZGljZXMoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEVkZ2VDb21wb3VuZFByb2dyYW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0uYnVmZmVyRGF0YSgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRWRnZUNvbXBvdW5kUHJvZ3JhbS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhLCBoaWRkZW4sIG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7IHJldHVybiBwcm9ncmFtLnByb2Nlc3Moc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSwgaGlkZGVuLCBvZmZzZXQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVkZ2VDb21wb3VuZFByb2dyYW07XG4gICAgfSgpKTtcbn1cbmV4cG9ydHMuY3JlYXRlRWRnZUNvbXBvdW5kUHJvZ3JhbSA9IGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0gPSBleHBvcnRzLkFic3RyYWN0Tm9kZVByb2dyYW0gPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIEFic3RyYWN0IE5vZGUgUHJvZ3JhbVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEBtb2R1bGVcbiAqL1xudmFyIHByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL3Byb2dyYW1cIik7XG4vKipcbiAqIE5vZGUgUHJvZ3JhbSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEFic3RyYWN0Tm9kZVByb2dyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0Tm9kZVByb2dyYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3ROb2RlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgcG9pbnRzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBwb2ludHMsIGF0dHJpYnV0ZXMpIHx8IHRoaXM7XG4gICAgICAgIC8vIExvY2F0aW9uc1xuICAgICAgICBfdGhpcy5wb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgICAgICBfdGhpcy5zaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfc2l6ZVwiKTtcbiAgICAgICAgX3RoaXMuY29sb3JMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9jb2xvclwiKTtcbiAgICAgICAgLy8gVW5pZm9ybSBMb2NhdGlvblxuICAgICAgICB2YXIgbWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICAgICAgaWYgKG1hdHJpeExvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3ROb2RlUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBtYXRyaXhMb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMubWF0cml4TG9jYXRpb24gPSBtYXRyaXhMb2NhdGlvbjtcbiAgICAgICAgdmFyIHJhdGlvTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJ1X3JhdGlvXCIpO1xuICAgICAgICBpZiAocmF0aW9Mb2NhdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0Tm9kZVByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgcmF0aW9Mb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMucmF0aW9Mb2NhdGlvbiA9IHJhdGlvTG9jYXRpb247XG4gICAgICAgIHZhciBzY2FsZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwidV9zY2FsZVwiKTtcbiAgICAgICAgaWYgKHNjYWxlTG9jYXRpb24gPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdE5vZGVQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIHNjYWxlTG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLnNjYWxlTG9jYXRpb24gPSBzY2FsZUxvY2F0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0Tm9kZVByb2dyYW0ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuc2l6ZUxvY2F0aW9uKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5jb2xvckxvY2F0aW9uKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgdGhpcy5hdHRyaWJ1dGVzICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNpemVMb2NhdGlvbiwgMSwgZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLmF0dHJpYnV0ZXMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDgpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY29sb3JMb2NhdGlvbiwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgdGhpcy5hdHRyaWJ1dGVzICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAxMik7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3ROb2RlUHJvZ3JhbTtcbn0ocHJvZ3JhbV8xLkFic3RyYWN0UHJvZ3JhbSkpO1xuZXhwb3J0cy5BYnN0cmFjdE5vZGVQcm9ncmFtID0gQWJzdHJhY3ROb2RlUHJvZ3JhbTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGNvbWJpbmluZyB0d28gb3IgbW9yZSBwcm9ncmFtcyBpbnRvIGEgc2luZ2xlIGNvbXBvdW5kIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG1vcmUgYSBxdWljayAmIGVhc3kgd2F5IHRvIGNvbWJpbmUgcHJvZ3JhbSB0aGFuIGEgcmVhbGx5XG4gKiBwZXJmb3JtYW50IG9wdGlvbi4gTW9yZSBwZXJmb3JtYW50IHByb2dyYW1zIGNhbiBiZSB3cml0dGVuIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBwcm9ncmFtQ2xhc3NlcyAtIFByb2dyYW0gY2xhc3NlcyB0byBjb21iaW5lLlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0ocHJvZ3JhbUNsYXNzZXMpIHtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOb2RlQ29tcG91bmRQcm9ncmFtKGdsLCByZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoUHJvZ3JhbUNsYXNzKSB7IHJldHVybiBuZXcgUHJvZ3JhbUNsYXNzKGdsLCByZW5kZXJlcik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIE5vZGVDb21wb3VuZFByb2dyYW0ucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHsgcmV0dXJuIHByb2dyYW0uYnVmZmVyRGF0YSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTm9kZUNvbXBvdW5kUHJvZ3JhbS5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkgeyByZXR1cm4gcHJvZ3JhbS5hbGxvY2F0ZShjYXBhY2l0eSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOb2RlQ29tcG91bmRQcm9ncmFtLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0b2RvLCBpdCdzIGFscmVhZHkgZG9uZSBpbiBlYWNoIHByb2dyYW0gY29uc3RydWN0b3JcbiAgICAgICAgfTtcbiAgICAgICAgTm9kZUNvbXBvdW5kUHJvZ3JhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5idWZmZXJEYXRhKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOb2RlQ29tcG91bmRQcm9ncmFtLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGRhdGEsIGhpZGRlbiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHsgcmV0dXJuIHByb2dyYW0ucHJvY2VzcyhkYXRhLCBoaWRkZW4sIG9mZnNldCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTm9kZUNvbXBvdW5kUHJvZ3JhbTtcbiAgICB9KCkpO1xufVxuZXhwb3J0cy5jcmVhdGVOb2RlQ29tcG91bmRQcm9ncmFtID0gY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdFByb2dyYW0gPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIFJlbmRlcmVyIFByb2dyYW1cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2luZ2xlIFdlYkdMIHByb2dyYW0gdXNlZCBieSBzaWdtYSdzIFdlYkdMIHJlbmRlcmVyLlxuICogQG1vZHVsZVxuICovXG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFkZXJzL3V0aWxzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBQcm9ncmFtIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQWJzdHJhY3RQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0UHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgcG9pbnRzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyU291cmNlID0gdmVydGV4U2hhZGVyU291cmNlO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0UHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGJ1ZmZlclwiKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gKDAsIHV0aWxzXzEubG9hZFZlcnRleFNoYWRlcikoZ2wsIHRoaXMudmVydGV4U2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9ICgwLCB1dGlsc18xLmxvYWRGcmFnbWVudFNoYWRlcikoZ2wsIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSAoMCwgdXRpbHNfMS5sb2FkUHJvZ3JhbSkoZ2wsIFt0aGlzLnZlcnRleFNoYWRlciwgdGhpcy5mcmFnbWVudFNoYWRlcl0pO1xuICAgIH1cbiAgICBBYnN0cmFjdFByb2dyYW0ucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFycmF5LCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgIH07XG4gICAgQWJzdHJhY3RQcm9ncmFtLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyAqIHRoaXMuYXR0cmlidXRlcyAqIGNhcGFjaXR5KTtcbiAgICB9O1xuICAgIEFic3RyYWN0UHJvZ3JhbS5wcm90b3R5cGUuaGFzTm90aGluZ1RvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RQcm9ncmFtID0gQWJzdHJhY3RQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIFJlbmRlcmVyIEVkZ2UgQXJyb3cgUHJvZ3JhbVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENvbXBvdW5kIHByb2dyYW0gcmVuZGVyaW5nIGVkZ2VzIGFzIGFuIGFycm93IGZyb20gdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0LlxuICogQG1vZHVsZVxuICovXG52YXIgZWRnZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL2VkZ2VcIik7XG52YXIgZWRnZV9hcnJvd0hlYWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lZGdlLmFycm93SGVhZFwiKSk7XG52YXIgZWRnZV9jbGFtcGVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZWRnZS5jbGFtcGVkXCIpKTtcbnZhciBFZGdlQXJyb3dQcm9ncmFtID0gKDAsIGVkZ2VfMS5jcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKShbZWRnZV9jbGFtcGVkXzEuZGVmYXVsdCwgZWRnZV9hcnJvd0hlYWRfMS5kZWZhdWx0XSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFZGdlQXJyb3dQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHNcIik7XG52YXIgZWRnZV9hcnJvd0hlYWRfdmVydF9nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvZWRnZS5hcnJvd0hlYWQudmVydC5nbHNsLmpzXCIpKTtcbnZhciBlZGdlX2Fycm93SGVhZF9mcmFnX2dsc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhZGVycy9lZGdlLmFycm93SGVhZC5mcmFnLmdsc2wuanNcIikpO1xudmFyIGVkZ2VfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9lZGdlXCIpO1xudmFyIFBPSU5UUyA9IDMsIEFUVFJJQlVURVMgPSA5LCBTVFJJREUgPSBQT0lOVFMgKiBBVFRSSUJVVEVTO1xudmFyIEVkZ2VBcnJvd0hlYWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFZGdlQXJyb3dIZWFkUHJvZ3JhbShnbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnbCwgZWRnZV9hcnJvd0hlYWRfdmVydF9nbHNsXzEuZGVmYXVsdCwgZWRnZV9hcnJvd0hlYWRfZnJhZ19nbHNsXzEuZGVmYXVsdCwgUE9JTlRTLCBBVFRSSUJVVEVTKSB8fCB0aGlzO1xuICAgICAgICAvLyBMb2NhdGlvbnNcbiAgICAgICAgX3RoaXMucG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICAgICAgX3RoaXMuY29sb3JMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9jb2xvclwiKTtcbiAgICAgICAgX3RoaXMubm9ybWFsTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfbm9ybWFsXCIpO1xuICAgICAgICBfdGhpcy5yYWRpdXNMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9yYWRpdXNcIik7XG4gICAgICAgIF90aGlzLmJhcnljZW50cmljTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfYmFyeWNlbnRyaWNcIik7XG4gICAgICAgIC8vIFVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgIHZhciBtYXRyaXhMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcInVfbWF0cml4XCIpO1xuICAgICAgICBpZiAobWF0cml4TG9jYXRpb24gPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZGdlQXJyb3dIZWFkUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBtYXRyaXhMb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMubWF0cml4TG9jYXRpb24gPSBtYXRyaXhMb2NhdGlvbjtcbiAgICAgICAgdmFyIHNxcnRab29tUmF0aW9Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcInVfc3FydFpvb21SYXRpb1wiKTtcbiAgICAgICAgaWYgKHNxcnRab29tUmF0aW9Mb2NhdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2VBcnJvd0hlYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIHNxcnRab29tUmF0aW9Mb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMuc3FydFpvb21SYXRpb0xvY2F0aW9uID0gc3FydFpvb21SYXRpb0xvY2F0aW9uO1xuICAgICAgICB2YXIgY29ycmVjdGlvblJhdGlvTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiKTtcbiAgICAgICAgaWYgKGNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZUFycm93SGVhZFByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29ycmVjdGlvblJhdGlvTG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLmNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID0gY29ycmVjdGlvblJhdGlvTG9jYXRpb247XG4gICAgICAgIF90aGlzLmJpbmQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFZGdlQXJyb3dIZWFkUHJvZ3JhbS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgLy8gQmluZGluZ3NcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5ub3JtYWxMb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucmFkaXVzTG9jYXRpb24pO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmNvbG9yTG9jYXRpb24pO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmJhcnljZW50cmljTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLm5vcm1hbExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDgpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmFkaXVzTG9jYXRpb24sIDEsIGdsLkZMT0FULCBmYWxzZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMTYpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY29sb3JMb2NhdGlvbiwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMjApO1xuICAgICAgICAvLyBUT0RPOiBtYXliZSB3ZSBjYW4gb3B0aW1pemUgaGVyZSBieSBwYWNraW5nIHRoaXMgaW4gYSBiaXQgbWFza1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYmFyeWNlbnRyaWNMb2NhdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAyNCk7XG4gICAgfTtcbiAgICBFZGdlQXJyb3dIZWFkUHJvZ3JhbS5wcm90b3R5cGUuY29tcHV0ZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICB9O1xuICAgIEVkZ2VBcnJvd0hlYWRQcm9ncmFtLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEsIGhpZGRlbiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IG9mZnNldCAqIFNUUklERSwgbCA9IGlfMSArIFNUUklERTsgaV8xIDwgbDsgaV8xKyspXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVtpXzFdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDEsIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxLCB4MSA9IHNvdXJjZURhdGEueCwgeTEgPSBzb3VyY2VEYXRhLnksIHgyID0gdGFyZ2V0RGF0YS54LCB5MiA9IHRhcmdldERhdGEueSwgY29sb3IgPSAoMCwgdXRpbHNfMS5mbG9hdENvbG9yKShkYXRhLmNvbG9yKTtcbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MSwgZHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHksIG4xID0gMCwgbjIgPSAwO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBQT0lOVFMgKiBBVFRSSUJVVEVTICogb2Zmc2V0O1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICAvLyBGaXJzdCBwb2ludFxuICAgICAgICBhcnJheVtpKytdID0geDI7XG4gICAgICAgIGFycmF5W2krK10gPSB5MjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IC1uMTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IC1uMjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IHJhZGl1cztcbiAgICAgICAgYXJyYXlbaSsrXSA9IGNvbG9yO1xuICAgICAgICBhcnJheVtpKytdID0gMTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAwO1xuICAgICAgICAvLyBTZWNvbmQgcG9pbnRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAxO1xuICAgICAgICBhcnJheVtpKytdID0gMDtcbiAgICAgICAgLy8gVGhpcmQgcG9pbnRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAwO1xuICAgICAgICBhcnJheVtpXSA9IDE7XG4gICAgfTtcbiAgICBFZGdlQXJyb3dIZWFkUHJvZ3JhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5oYXNOb3RoaW5nVG9SZW5kZXIoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIEJpbmRpbmcgdW5pZm9ybXNcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLm1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLnNxcnRab29tUmF0aW9Mb2NhdGlvbiwgTWF0aC5zcXJ0KHBhcmFtcy5yYXRpbykpO1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5jb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbiwgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIC8vIERyYXdpbmc6XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCB0aGlzLmFycmF5Lmxlbmd0aCAvIEFUVFJJQlVURVMpO1xuICAgIH07XG4gICAgcmV0dXJuIEVkZ2VBcnJvd0hlYWRQcm9ncmFtO1xufShlZGdlXzEuQWJzdHJhY3RFZGdlUHJvZ3JhbSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRWRnZUFycm93SGVhZFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWRnZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL2VkZ2VcIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsc1wiKTtcbnZhciBlZGdlX2NsYW1wZWRfdmVydF9nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvZWRnZS5jbGFtcGVkLnZlcnQuZ2xzbC5qc1wiKSk7XG52YXIgZWRnZV9mcmFnX2dsc2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhZGVycy9lZGdlLmZyYWcuZ2xzbC5qc1wiKSk7XG52YXIgUE9JTlRTID0gNCwgQVRUUklCVVRFUyA9IDYsIFNUUklERSA9IFBPSU5UUyAqIEFUVFJJQlVURVM7XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFZGdlQ2xhbXBlZFByb2dyYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWRnZUNsYW1wZWRQcm9ncmFtKGdsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdsLCBlZGdlX2NsYW1wZWRfdmVydF9nbHNsXzEuZGVmYXVsdCwgZWRnZV9mcmFnX2dsc2xfMS5kZWZhdWx0LCBQT0lOVFMsIEFUVFJJQlVURVMpIHx8IHRoaXM7XG4gICAgICAgIC8vIEluaXRpYWxpemluZyBpbmRpY2VzIGJ1ZmZlclxuICAgICAgICB2YXIgaW5kaWNlc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBpZiAoaW5kaWNlc0J1ZmZlciA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2VDbGFtcGVkUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyByZXNvbHV0aW9uTG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLmluZGljZXNCdWZmZXIgPSBpbmRpY2VzQnVmZmVyO1xuICAgICAgICAvLyBMb2NhdGlvbnM6XG4gICAgICAgIF90aGlzLnBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgICAgIF90aGlzLmNvbG9yTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfY29sb3JcIik7XG4gICAgICAgIF90aGlzLm5vcm1hbExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJhX25vcm1hbFwiKTtcbiAgICAgICAgX3RoaXMucmFkaXVzTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfcmFkaXVzXCIpO1xuICAgICAgICAvLyBVbmlmb3JtIGxvY2F0aW9uc1xuICAgICAgICB2YXIgbWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICAgICAgaWYgKG1hdHJpeExvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZUNsYW1wZWRQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIG1hdHJpeExvY2F0aW9uXCIpO1xuICAgICAgICBfdGhpcy5tYXRyaXhMb2NhdGlvbiA9IG1hdHJpeExvY2F0aW9uO1xuICAgICAgICB2YXIgc3FydFpvb21SYXRpb0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwidV9zcXJ0Wm9vbVJhdGlvXCIpO1xuICAgICAgICBpZiAoc3FydFpvb21SYXRpb0xvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZUNsYW1wZWRQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIGNhbWVyYVJhdGlvTG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLnNxcnRab29tUmF0aW9Mb2NhdGlvbiA9IHNxcnRab29tUmF0aW9Mb2NhdGlvbjtcbiAgICAgICAgdmFyIGNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwidV9jb3JyZWN0aW9uUmF0aW9cIik7XG4gICAgICAgIGlmIChjb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2VDbGFtcGVkUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyB2aWV3cG9ydFJhdGlvTG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLmNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID0gY29ycmVjdGlvblJhdGlvTG9jYXRpb247XG4gICAgICAgIC8vIEVuYWJsaW5nIHRoZSBPRVNfZWxlbWVudF9pbmRleF91aW50IGV4dGVuc2lvblxuICAgICAgICAvLyBOT1RFOiBvbiBvbGRlciBHUFVzLCB0aGlzIG1lYW5zIHRoYXQgcmVhbGx5IGxhcmdlIGdyYXBocyB3b24ndFxuICAgICAgICAvLyBoYXZlIGFsbCB0aGVpciBlZGdlcyByZW5kZXJlZC4gQnV0IGl0IHNlZW1zIHRoYXQgdGhlXG4gICAgICAgIC8vIGBPRVNfZWxlbWVudF9pbmRleF91aW50YCBpcyBxdWl0ZSBldmVyeXdoZXJlIHNvIHdlJ2xsIGhhbmRsZVxuICAgICAgICAvLyB0aGUgcG90ZW50aWFsIGlzc3VlIGlmIGl0IHJlYWxseSBhcmlzZXMuXG4gICAgICAgIC8vIE5PVEU6IHdoZW4gdXNpbmcgd2ViZ2wyLCB0aGUgZXh0ZW5zaW9uIGlzIGVuYWJsZWQgYnkgZGVmYXVsdFxuICAgICAgICBfdGhpcy5jYW5Vc2UzMkJpdHNJbmRpY2VzID0gKDAsIHV0aWxzXzEuY2FuVXNlMzJCaXRzSW5kaWNlcykoZ2wpO1xuICAgICAgICBfdGhpcy5JbmRpY2VzQXJyYXkgPSBfdGhpcy5jYW5Vc2UzMkJpdHNJbmRpY2VzID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICAgICAgX3RoaXMuaW5kaWNlc0FycmF5ID0gbmV3IF90aGlzLkluZGljZXNBcnJheSgpO1xuICAgICAgICBfdGhpcy5pbmRpY2VzVHlwZSA9IF90aGlzLmNhblVzZTMyQml0c0luZGljZXMgPyBnbC5VTlNJR05FRF9JTlQgOiBnbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgX3RoaXMuYmluZCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVkZ2VDbGFtcGVkUHJvZ3JhbS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzQnVmZmVyKTtcbiAgICAgICAgLy8gQmluZGluZ3NcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5ub3JtYWxMb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuY29sb3JMb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucmFkaXVzTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLm5vcm1hbExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDgpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY29sb3JMb2NhdGlvbiwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMTYpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmFkaXVzTG9jYXRpb24sIDEsIGdsLkZMT0FULCBmYWxzZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMjApO1xuICAgIH07XG4gICAgRWRnZUNsYW1wZWRQcm9ncmFtLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEsIGhpZGRlbiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IG9mZnNldCAqIFNUUklERSwgbCA9IGlfMSArIFNUUklERTsgaV8xIDwgbDsgaV8xKyspXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVtpXzFdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDEsIHgxID0gc291cmNlRGF0YS54LCB5MSA9IHNvdXJjZURhdGEueSwgeDIgPSB0YXJnZXREYXRhLngsIHkyID0gdGFyZ2V0RGF0YS55LCByYWRpdXMgPSB0YXJnZXREYXRhLnNpemUgfHwgMSwgY29sb3IgPSAoMCwgdXRpbHNfMS5mbG9hdENvbG9yKShkYXRhLmNvbG9yKTtcbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MSwgZHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHksIG4xID0gMCwgbjIgPSAwO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBQT0lOVFMgKiBBVFRSSUJVVEVTICogb2Zmc2V0O1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICAvLyBGaXJzdCBwb2ludFxuICAgICAgICBhcnJheVtpKytdID0geDE7XG4gICAgICAgIGFycmF5W2krK10gPSB5MTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IG4xO1xuICAgICAgICBhcnJheVtpKytdID0gbjI7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIC8vIEZpcnN0IHBvaW50IGZsaXBwZWRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgxO1xuICAgICAgICBhcnJheVtpKytdID0geTE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIC8vIFNlY29uZCBwb2ludFxuICAgICAgICBhcnJheVtpKytdID0geDI7XG4gICAgICAgIGFycmF5W2krK10gPSB5MjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IG4xO1xuICAgICAgICBhcnJheVtpKytdID0gbjI7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IHJhZGl1cztcbiAgICAgICAgLy8gU2Vjb25kIHBvaW50IGZsaXBwZWRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaV0gPSAtcmFkaXVzO1xuICAgIH07XG4gICAgRWRnZUNsYW1wZWRQcm9ncmFtLnByb3RvdHlwZS5jb21wdXRlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSB0aGlzLmFycmF5Lmxlbmd0aCAvIEFUVFJJQlVURVM7XG4gICAgICAgIHZhciBzaXplID0gbCArIGwgLyAyO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyB0aGlzLkluZGljZXNBcnJheShzaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgICAgICBpbmRpY2VzW2MrK10gPSBpO1xuICAgICAgICAgICAgaW5kaWNlc1tjKytdID0gaSArIDE7XG4gICAgICAgICAgICBpbmRpY2VzW2MrK10gPSBpICsgMjtcbiAgICAgICAgICAgIGluZGljZXNbYysrXSA9IGkgKyAyO1xuICAgICAgICAgICAgaW5kaWNlc1tjKytdID0gaSArIDE7XG4gICAgICAgICAgICBpbmRpY2VzW2MrK10gPSBpICsgMztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGljZXNBcnJheSA9IGluZGljZXM7XG4gICAgfTtcbiAgICBFZGdlQ2xhbXBlZFByb2dyYW0ucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYnVmZmVyRGF0YS5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBJbmRpY2VzIGRhdGFcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzQXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB9O1xuICAgIEVkZ2VDbGFtcGVkUHJvZ3JhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5oYXNOb3RoaW5nVG9SZW5kZXIoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIEJpbmRpbmcgdW5pZm9ybXNcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLm1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLnNxcnRab29tUmF0aW9Mb2NhdGlvbiwgTWF0aC5zcXJ0KHBhcmFtcy5yYXRpbykpO1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5jb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbiwgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIC8vIERyYXdpbmc6XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuaW5kaWNlc0FycmF5Lmxlbmd0aCwgdGhpcy5pbmRpY2VzVHlwZSwgMCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWRnZUNsYW1wZWRQcm9ncmFtO1xufShlZGdlXzEuQWJzdHJhY3RFZGdlUHJvZ3JhbSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRWRnZUNsYW1wZWRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBTaWdtYS5qcyBXZWJHTCBSZW5kZXJlciBFZGdlIFByb2dyYW1cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBQcm9ncmFtIHJlbmRlcmluZyBlZGdlcyBhcyB0aGljayBsaW5lcyB1c2luZyBmb3VyIHBvaW50cyB0cmFuc2xhdGVkXG4gKiBvcnRob2dvbmFsbHkgZnJvbSB0aGUgc291cmNlICYgdGFyZ2V0J3MgY2VudGVycyBieSBoYWxmIHRoaWNrbmVzcy5cbiAqXG4gKiBSZW5kZXJpbmcgdHdvIHRyaWFuZ2xlcyBieSB1c2luZyBvbmx5IGZvdXIgcG9pbnRzIGlzIG1hZGUgcG9zc2libGUgdGhyb3VnaFxuICogdGhlIHVzZSBvZiBpbmRpY2VzLlxuICpcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiB0aGUgNiBwb2ludHMgLyAyIHRyaWFuZ2xlcyBhcHByb2FjaCBhbmRcbiAqIHNob3VsZCBoYW5kbGUgdGhpY2tuZXNzIGJldHRlciB0aGFuIHdpdGggZ2wuTElORVMuXG4gKlxuICogVGhpcyB2ZXJzaW9uIG9mIHRoZSBzaGFkZXIgYmFsYW5jZXMgZ2VvbWV0cnkgY29tcHV0YXRpb24gZXZlbmx5IGJldHdlZW5cbiAqIHRoZSBDUFUgJiBHUFUgKG5vcm1hbHMgYXJlIGNvbXB1dGVkIG9uIHRoZSBDUFUgc2lkZSkuXG4gKiBAbW9kdWxlXG4gKi9cbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzXCIpO1xudmFyIGVkZ2VfdmVydF9nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvZWRnZS52ZXJ0Lmdsc2wuanNcIikpO1xudmFyIGVkZ2VfZnJhZ19nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvZWRnZS5mcmFnLmdsc2wuanNcIikpO1xudmFyIGVkZ2VfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9lZGdlXCIpO1xudmFyIFBPSU5UUyA9IDQsIEFUVFJJQlVURVMgPSA1LCBTVFJJREUgPSBQT0lOVFMgKiBBVFRSSUJVVEVTO1xudmFyIEVkZ2VQcm9ncmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFZGdlUHJvZ3JhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFZGdlUHJvZ3JhbShnbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnbCwgZWRnZV92ZXJ0X2dsc2xfMS5kZWZhdWx0LCBlZGdlX2ZyYWdfZ2xzbF8xLmRlZmF1bHQsIFBPSU5UUywgQVRUUklCVVRFUykgfHwgdGhpcztcbiAgICAgICAgLy8gSW5pdGlhbGl6aW5nIGluZGljZXMgYnVmZmVyXG4gICAgICAgIHZhciBpbmRpY2VzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmIChpbmRpY2VzQnVmZmVyID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZVByb2dyYW06IGVycm9yIHdoaWxlIGNyZWF0aW5nIGluZGljZXNCdWZmZXJcIik7XG4gICAgICAgIF90aGlzLmluZGljZXNCdWZmZXIgPSBpbmRpY2VzQnVmZmVyO1xuICAgICAgICAvLyBMb2NhdGlvbnNcbiAgICAgICAgX3RoaXMucG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICAgICAgX3RoaXMuY29sb3JMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKF90aGlzLnByb2dyYW0sIFwiYV9jb2xvclwiKTtcbiAgICAgICAgX3RoaXMubm9ybWFsTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcImFfbm9ybWFsXCIpO1xuICAgICAgICB2YXIgbWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oX3RoaXMucHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICAgICAgaWYgKG1hdHJpeExvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZVByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgbWF0cml4TG9jYXRpb25cIik7XG4gICAgICAgIF90aGlzLm1hdHJpeExvY2F0aW9uID0gbWF0cml4TG9jYXRpb247XG4gICAgICAgIHZhciBjb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcInVfY29ycmVjdGlvblJhdGlvXCIpO1xuICAgICAgICBpZiAoY29ycmVjdGlvblJhdGlvTG9jYXRpb24gPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZGdlUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBjb3JyZWN0aW9uUmF0aW9Mb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMuY29ycmVjdGlvblJhdGlvTG9jYXRpb24gPSBjb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbjtcbiAgICAgICAgdmFyIHNxcnRab29tUmF0aW9Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihfdGhpcy5wcm9ncmFtLCBcInVfc3FydFpvb21SYXRpb1wiKTtcbiAgICAgICAgaWYgKHNxcnRab29tUmF0aW9Mb2NhdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2VQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIHNxcnRab29tUmF0aW9Mb2NhdGlvblwiKTtcbiAgICAgICAgX3RoaXMuc3FydFpvb21SYXRpb0xvY2F0aW9uID0gc3FydFpvb21SYXRpb0xvY2F0aW9uO1xuICAgICAgICAvLyBFbmFibGluZyB0aGUgT0VTX2VsZW1lbnRfaW5kZXhfdWludCBleHRlbnNpb25cbiAgICAgICAgLy8gTk9URTogb24gb2xkZXIgR1BVcywgdGhpcyBtZWFucyB0aGF0IHJlYWxseSBsYXJnZSBncmFwaHMgd29uJ3RcbiAgICAgICAgLy8gaGF2ZSBhbGwgdGhlaXIgZWRnZXMgcmVuZGVyZWQuIEJ1dCBpdCBzZWVtcyB0aGF0IHRoZVxuICAgICAgICAvLyBgT0VTX2VsZW1lbnRfaW5kZXhfdWludGAgaXMgcXVpdGUgZXZlcnl3aGVyZSBzbyB3ZSdsbCBoYW5kbGVcbiAgICAgICAgLy8gdGhlIHBvdGVudGlhbCBpc3N1ZSBpZiBpdCByZWFsbHkgYXJpc2VzLlxuICAgICAgICAvLyBOT1RFOiB3aGVuIHVzaW5nIHdlYmdsMiwgdGhlIGV4dGVuc2lvbiBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgX3RoaXMuY2FuVXNlMzJCaXRzSW5kaWNlcyA9ICgwLCB1dGlsc18xLmNhblVzZTMyQml0c0luZGljZXMpKGdsKTtcbiAgICAgICAgX3RoaXMuSW5kaWNlc0FycmF5ID0gX3RoaXMuY2FuVXNlMzJCaXRzSW5kaWNlcyA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgICAgIF90aGlzLmluZGljZXNBcnJheSA9IG5ldyBfdGhpcy5JbmRpY2VzQXJyYXkoKTtcbiAgICAgICAgX3RoaXMuaW5kaWNlc1R5cGUgPSBfdGhpcy5jYW5Vc2UzMkJpdHNJbmRpY2VzID8gZ2wuVU5TSUdORURfSU5UIDogZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIF90aGlzLmJpbmQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFZGdlUHJvZ3JhbS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzQnVmZmVyKTtcbiAgICAgICAgLy8gQmluZGluZ3NcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5ub3JtYWxMb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuY29sb3JMb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5wb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMubm9ybWFsTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgOCk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5jb2xvckxvY2F0aW9uLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAxNik7XG4gICAgfTtcbiAgICBFZGdlUHJvZ3JhbS5wcm90b3R5cGUuY29tcHV0ZUluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5hcnJheS5sZW5ndGggLyBBVFRSSUJVVEVTO1xuICAgICAgICB2YXIgc2l6ZSA9IGwgKyBsIC8gMjtcbiAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgdGhpcy5JbmRpY2VzQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICAgICAgaW5kaWNlc1tjKytdID0gaTtcbiAgICAgICAgICAgIGluZGljZXNbYysrXSA9IGkgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tjKytdID0gaSArIDI7XG4gICAgICAgICAgICBpbmRpY2VzW2MrK10gPSBpICsgMjtcbiAgICAgICAgICAgIGluZGljZXNbYysrXSA9IGkgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tjKytdID0gaSArIDM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRpY2VzQXJyYXkgPSBpbmRpY2VzO1xuICAgIH07XG4gICAgRWRnZVByb2dyYW0ucHJvdG90eXBlLmJ1ZmZlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYnVmZmVyRGF0YS5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBJbmRpY2VzIGRhdGFcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzQXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB9O1xuICAgIEVkZ2VQcm9ncmFtLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEsIGhpZGRlbiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IG9mZnNldCAqIFNUUklERSwgbCA9IGlfMSArIFNUUklERTsgaV8xIDwgbDsgaV8xKyspXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVtpXzFdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDEsIHgxID0gc291cmNlRGF0YS54LCB5MSA9IHNvdXJjZURhdGEueSwgeDIgPSB0YXJnZXREYXRhLngsIHkyID0gdGFyZ2V0RGF0YS55LCBjb2xvciA9ICgwLCB1dGlsc18xLmZsb2F0Q29sb3IpKGRhdGEuY29sb3IpO1xuICAgICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgICB2YXIgZHggPSB4MiAtIHgxLCBkeSA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeSwgbjEgPSAwLCBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IFBPSU5UUyAqIEFUVFJJQlVURVMgKiBvZmZzZXQ7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIC8vIEZpcnN0IHBvaW50XG4gICAgICAgIGFycmF5W2krK10gPSB4MTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IHkxO1xuICAgICAgICBhcnJheVtpKytdID0gbjE7XG4gICAgICAgIGFycmF5W2krK10gPSBuMjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IGNvbG9yO1xuICAgICAgICAvLyBGaXJzdCBwb2ludCBmbGlwcGVkXG4gICAgICAgIGFycmF5W2krK10gPSB4MTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IHkxO1xuICAgICAgICBhcnJheVtpKytdID0gLW4xO1xuICAgICAgICBhcnJheVtpKytdID0gLW4yO1xuICAgICAgICBhcnJheVtpKytdID0gY29sb3I7XG4gICAgICAgIC8vIFNlY29uZCBwb2ludFxuICAgICAgICBhcnJheVtpKytdID0geDI7XG4gICAgICAgIGFycmF5W2krK10gPSB5MjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IG4xO1xuICAgICAgICBhcnJheVtpKytdID0gbjI7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgLy8gU2Vjb25kIHBvaW50IGZsaXBwZWRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2ldID0gY29sb3I7XG4gICAgfTtcbiAgICBFZGdlUHJvZ3JhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5oYXNOb3RoaW5nVG9SZW5kZXIoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5tYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy5zcXJ0Wm9vbVJhdGlvTG9jYXRpb24sIE1hdGguc3FydChwYXJhbXMucmF0aW8pKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuY29ycmVjdGlvblJhdGlvTG9jYXRpb24sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgICAvLyBEcmF3aW5nOlxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmluZGljZXNBcnJheS5sZW5ndGgsIHRoaXMuaW5kaWNlc1R5cGUsIDApO1xuICAgIH07XG4gICAgcmV0dXJuIEVkZ2VQcm9ncmFtO1xufShlZGdlXzEuQWJzdHJhY3RFZGdlUHJvZ3JhbSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRWRnZVByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsc1wiKTtcbnZhciBub2RlX2Zhc3RfdmVydF9nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYWRlcnMvbm9kZS5mYXN0LnZlcnQuZ2xzbC5qc1wiKSk7XG52YXIgbm9kZV9mYXN0X2ZyYWdfZ2xzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFkZXJzL25vZGUuZmFzdC5mcmFnLmdsc2wuanNcIikpO1xudmFyIG5vZGVfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9ub2RlXCIpO1xudmFyIFBPSU5UUyA9IDEsIEFUVFJJQlVURVMgPSA0O1xudmFyIE5vZGVGYXN0UHJvZ3JhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZUZhc3RQcm9ncmFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vZGVGYXN0UHJvZ3JhbShnbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnbCwgbm9kZV9mYXN0X3ZlcnRfZ2xzbF8xLmRlZmF1bHQsIG5vZGVfZmFzdF9mcmFnX2dsc2xfMS5kZWZhdWx0LCBQT0lOVFMsIEFUVFJJQlVURVMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOb2RlRmFzdFByb2dyYW0ucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgaGlkZGVuLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIGkgPSBvZmZzZXQgKiBQT0lOVFMgKiBBVFRSSUJVVEVTO1xuICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgICBhcnJheVtpKytdID0gMDtcbiAgICAgICAgICAgIGFycmF5W2krK10gPSAwO1xuICAgICAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgICAgICBhcnJheVtpKytdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3IgPSAoMCwgdXRpbHNfMS5mbG9hdENvbG9yKShkYXRhLmNvbG9yKTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IGRhdGEueDtcbiAgICAgICAgYXJyYXlbaSsrXSA9IGRhdGEueTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgYXJyYXlbaV0gPSBjb2xvcjtcbiAgICB9O1xuICAgIE5vZGVGYXN0UHJvZ3JhbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5oYXNOb3RoaW5nVG9SZW5kZXIoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLnJhdGlvTG9jYXRpb24sIDEgLyBNYXRoLnNxcnQocGFyYW1zLnJhdGlvKSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLnNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMubWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIHRoaXMuYXJyYXkubGVuZ3RoIC8gQVRUUklCVVRFUyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZUZhc3RQcm9ncmFtO1xufShub2RlXzEuQWJzdHJhY3ROb2RlUHJvZ3JhbSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm9kZUZhc3RQcm9ncmFtO1xuIiwiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Q6KG8scik9Pntmb3IodmFyIHQgaW4gcillLm8ocix0KSYmIWUubyhvLHQpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobyx0LHtlbnVtZXJhYmxlOiEwLGdldDpyW3RdfSl9LG86KGUsbyk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pLHI6ZT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9fSxvPXt9O2UucihvKSxlLmQobyx7ZGVmYXVsdDooKT0+cn0pO2NvbnN0IHI9XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG59XFxuXCI7bW9kdWxlLmV4cG9ydHM9b30pKCk7IiwiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9e2Q6KGUsdCk9Pntmb3IodmFyIG8gaW4gdClhLm8odCxvKSYmIWEubyhlLG8pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLHtlbnVtZXJhYmxlOiEwLGdldDp0W29dfSl9LG86KGEsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGUpLHI6YT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9fSxlPXt9O2EucihlKSxhLmQoZSx7ZGVmYXVsdDooKT0+dH0pO2NvbnN0IHQ9XCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1cztcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfYmFyeWNlbnRyaWM7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zcXJ0Wm9vbVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgbWluVGhpY2tuZXNzID0gMS43O1xcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcbmNvbnN0IGZsb2F0IGFycm93SGVhZFdpZHRoTGVuZ3RoUmF0aW8gPSAwLjY2O1xcbmNvbnN0IGZsb2F0IGFycm93SGVhZExlbmd0aFRoaWNrbmVzc1JhdGlvID0gMi41O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChhX25vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBhX25vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFRoZXNlIGZpcnN0IGNvbXB1dGF0aW9ucyBhcmUgdGFrZW4gZnJvbSBlZGdlLnZlcnQuZ2xzbCBhbmRcXG4gIC8vIGVkZ2UuY2xhbXBlZC52ZXJ0Lmdsc2wuIFBsZWFzZSByZWFkIGl0IHRvIGdldCBiZXR0ZXIgY29tbWVudHMgb24gd2hhdCdzXFxuICAvLyBoYXBwZW5pbmc6XFxuICBmbG9hdCBwaXhlbHNUaGlja25lc3MgPSBtYXgobm9ybWFsTGVuZ3RoLCBtaW5UaGlja25lc3MgKiB1X3NxcnRab29tUmF0aW8pO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbztcXG4gIGZsb2F0IGFkYXB0ZWRXZWJHTFRoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzICogdV9zcXJ0Wm9vbVJhdGlvO1xcbiAgZmxvYXQgYWRhcHRlZFdlYkdMTm9kZVJhZGl1cyA9IGFfcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gKiB1X3NxcnRab29tUmF0aW87XFxuICBmbG9hdCBhZGFwdGVkV2ViR0xBcnJvd0hlYWRMZW5ndGggPSBhZGFwdGVkV2ViR0xUaGlja25lc3MgKiAyLjAgKiBhcnJvd0hlYWRMZW5ndGhUaGlja25lc3NSYXRpbztcXG4gIGZsb2F0IGFkYXB0ZWRXZWJHTEFycm93SGVhZEhhbGZXaWR0aCA9IGFkYXB0ZWRXZWJHTEFycm93SGVhZExlbmd0aCAqIGFycm93SGVhZFdpZHRoTGVuZ3RoUmF0aW8gLyAyLjA7XFxuXFxuICBmbG9hdCBkYSA9IGFfYmFyeWNlbnRyaWMueDtcXG4gIGZsb2F0IGRiID0gYV9iYXJ5Y2VudHJpYy55O1xcbiAgZmxvYXQgZGMgPSBhX2JhcnljZW50cmljLno7XFxuXFxuICB2ZWMyIGRlbHRhID0gdmVjMihcXG4gICAgICBkYSAqIChhZGFwdGVkV2ViR0xOb2RlUmFkaXVzICogdW5pdE5vcm1hbC55KVxcbiAgICArIGRiICogKChhZGFwdGVkV2ViR0xOb2RlUmFkaXVzICsgYWRhcHRlZFdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueSArIGFkYXB0ZWRXZWJHTEFycm93SGVhZEhhbGZXaWR0aCAqIHVuaXROb3JtYWwueClcXG4gICAgKyBkYyAqICgoYWRhcHRlZFdlYkdMTm9kZVJhZGl1cyArIGFkYXB0ZWRXZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnkgLSBhZGFwdGVkV2ViR0xBcnJvd0hlYWRIYWxmV2lkdGggKiB1bml0Tm9ybWFsLngpLFxcblxcbiAgICAgIGRhICogKC1hZGFwdGVkV2ViR0xOb2RlUmFkaXVzICogdW5pdE5vcm1hbC54KVxcbiAgICArIGRiICogKC0oYWRhcHRlZFdlYkdMTm9kZVJhZGl1cyArIGFkYXB0ZWRXZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnggKyBhZGFwdGVkV2ViR0xBcnJvd0hlYWRIYWxmV2lkdGggKiB1bml0Tm9ybWFsLnkpXFxuICAgICsgZGMgKiAoLShhZGFwdGVkV2ViR0xOb2RlUmFkaXVzICsgYWRhcHRlZFdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueCAtIGFkYXB0ZWRXZWJHTEFycm93SGVhZEhhbGZXaWR0aCAqIHVuaXROb3JtYWwueSlcXG4gICk7XFxuXFxuICB2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uICsgZGVsdGEsIDEpKS54eTtcXG5cXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMCwgMSk7XFxuXFxuICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO21vZHVsZS5leHBvcnRzPWV9KSgpOyIsIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOihvLG4pPT57Zm9yKHZhciB0IGluIG4pZS5vKG4sdCkmJiFlLm8obyx0KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sdCx7ZW51bWVyYWJsZTohMCxnZXQ6blt0XX0pfSxvOihlLG8pPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sbz17fTtlLnIobyksZS5kKG8se2RlZmF1bHQ6KCk9Pm59KTtjb25zdCBuPVwiYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1cztcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NxcnRab29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG5cXG5jb25zdCBmbG9hdCBtaW5UaGlja25lc3MgPSAxLjc7XFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuY29uc3QgZmxvYXQgYXJyb3dIZWFkTGVuZ3RoVGhpY2tuZXNzUmF0aW8gPSAyLjU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKGFfbm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IGFfbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0b1xcbiAgLy8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3MgaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zcXJ0Wm9vbVJhdGlvKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW87XFxuICBmbG9hdCBhZGFwdGVkV2ViR0xUaGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAqIHVfc3FydFpvb21SYXRpbztcXG5cXG4gIC8vIEhlcmUsIHdlIG1vdmUgdGhlIHBvaW50IHRvIGxlYXZlIHNwYWNlIGZvciB0aGUgYXJyb3cgaGVhZDpcXG4gIGZsb2F0IGRpcmVjdGlvbiA9IHNpZ24oYV9yYWRpdXMpO1xcbiAgZmxvYXQgYWRhcHRlZFdlYkdMTm9kZVJhZGl1cyA9IGRpcmVjdGlvbiAqIGFfcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gKiB1X3NxcnRab29tUmF0aW87XFxuICBmbG9hdCBhZGFwdGVkV2ViR0xBcnJvd0hlYWRMZW5ndGggPSBhZGFwdGVkV2ViR0xUaGlja25lc3MgKiAyLjAgKiBhcnJvd0hlYWRMZW5ndGhUaGlja25lc3NSYXRpbztcXG5cXG4gIHZlYzIgY29tcGVuc2F0aW9uVmVjdG9yID0gdmVjMigtZGlyZWN0aW9uICogdW5pdE5vcm1hbC55LCBkaXJlY3Rpb24gKiB1bml0Tm9ybWFsLngpICogKGFkYXB0ZWRXZWJHTE5vZGVSYWRpdXMgKyBhZGFwdGVkV2ViR0xBcnJvd0hlYWRMZW5ndGgpO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24gKyB1bml0Tm9ybWFsICogYWRhcHRlZFdlYkdMVGhpY2tuZXNzICsgY29tcGVuc2F0aW9uVmVjdG9yLCAxKSkueHksIDAsIDEpO1xcblxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfc3FydFpvb21SYXRpbztcXG5cXG4gIHZfbm9ybWFsID0gdW5pdE5vcm1hbDtcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO21vZHVsZS5leHBvcnRzPW99KSgpOyIsIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOihuLHQpPT57Zm9yKHZhciBvIGluIHQpZS5vKHQsbykmJiFlLm8obixvKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyx7ZW51bWVyYWJsZTohMCxnZXQ6dFtvXX0pfSxvOihlLG4pPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sbj17fTtlLnIobiksZS5kKG4se2RlZmF1bHQ6KCk9PnR9KTtjb25zdCB0PVwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxuXFxuY29uc3QgZmxvYXQgZmVhdGhlciA9IDAuMDAxO1xcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdl90aGlja25lc3M7XFxuXFxuICBmbG9hdCB0ID0gc21vb3Roc3RlcChcXG4gICAgdl90aGlja25lc3MgLSBmZWF0aGVyLFxcbiAgICB2X3RoaWNrbmVzcyxcXG4gICAgZGlzdFxcbiAgKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh2X2NvbG9yLCB0cmFuc3BhcmVudCwgdCk7XFxufVxcblwiO21vZHVsZS5leHBvcnRzPW59KSgpOyIsIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOihuLG8pPT57Zm9yKHZhciB0IGluIG8pZS5vKG8sdCkmJiFlLm8obix0KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sdCx7ZW51bWVyYWJsZTohMCxnZXQ6b1t0XX0pfSxvOihlLG4pPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sbj17fTtlLnIobiksZS5kKG4se2RlZmF1bHQ6KCk9Pm99KTtjb25zdCBvPSdhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zcXJ0Wm9vbVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxuXFxuY29uc3QgZmxvYXQgbWluVGhpY2tuZXNzID0gMS43O1xcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChhX25vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBhX25vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFdlIHJlcXVpcmUgZWRnZXMgdG8gYmUgYXQgbGVhc3QgYG1pblRoaWNrbmVzc2AgcGl4ZWxzIHRoaWNrICpvbiBzY3JlZW4qXFxuICAvLyAoc28gd2UgbmVlZCB0byBjb21wZW5zYXRlIHRoZSBTUVJUIHpvb20gcmF0aW8pOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zcXJ0Wm9vbVJhdGlvKTtcXG5cXG4gIC8vIFRoZW4sIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIG5vcm1hbGl6ZWQgdGhpY2tuZXNzIG9mIHRoZSBlZGdlIGluIHRoZSBXZWJHTFxcbiAgLy8gcmVmZXJlbnRpYWwgKGluIGEgKFswLCAxXSwgWzAsIDFdKSBzcGFjZSksIHVzaW5nIG91ciBcIm1hZ2ljXCIgY29ycmVjdGlvblxcbiAgLy8gcmF0aW86XFxuICBmbG9hdCB3ZWJHTFRoaWNrbmVzcyA9IHBpeGVsc1RoaWNrbmVzcyAqIHVfY29ycmVjdGlvblJhdGlvO1xcblxcbiAgLy8gRmluYWxseSwgd2UgYWRhcHQgdGhlIGVkZ2UgdGhpY2tuZXNzIHRvIHRoZSBcIlNRUlQgcnVsZVwiIGluIHNpZ21hIChzbyB0aGF0XFxuICAvLyBpdGVtcyBhcmUgbm90IHRvbyBiaWcgd2hlbiB6b29tZWQgaW4sIGFuZCBub3QgdG9vIHNtYWxsIHdoZW4gem9vbWVkIG91dCkuXFxuICAvLyBUaGUgZXhhY3QgY29tcHV0YXRpb24gc2hvdWxkIGJlIGBhZGFwdGVkID0gdmFsdWUgKiB6b29tIC8gc3FydCh6b29tKWAsIGJ1dFxcbiAgLy8gaXRcXCdzIHNpbXBsZXIgbGlrZSB0aGlzOlxcbiAgZmxvYXQgYWRhcHRlZFdlYkdMVGhpY2tuZXNzID0gd2ViR0xUaGlja25lc3MgKiB1X3NxcnRab29tUmF0aW87XFxuXFxuICAvLyBIZXJlIGlzIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHZlcnRleFxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiArIHVuaXROb3JtYWwgKiBhZGFwdGVkV2ViR0xUaGlja25lc3MsIDEpKS54eSwgMCwgMSk7XFxuXFxuICAvLyBGb3IgdGhlIGZyYWdtZW50IHNoYWRlciB0aG91Z2gsIHdlIG5lZWQgYSB0aGlja25lc3MgdGhhdCB0YWtlcyB0aGUgXCJtYWdpY1wiXFxuICAvLyBjb3JyZWN0aW9uIHJhdGlvIGludG8gYWNjb3VudCAoYXMgaW4gd2ViR0xUaGlja25lc3MpLCBidXQgc28gdGhhdCB0aGVcXG4gIC8vIGFudGlhbGlhc2ludCBlZmZlY3QgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSB6b29tIGxldmVsLiBTbyBoZXJlXFwncyB5ZXRcXG4gIC8vIGFub3RoZXIgdGhpY2tuZXNzIHZlcnNpb246XFxuICB2X3RoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzIC8gdV9zcXJ0Wm9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuJzttb2R1bGUuZXhwb3J0cz1ufSkoKTsiLCIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17ZDoobixvKT0+e2Zvcih2YXIgdCBpbiBvKWUubyhvLHQpJiYhZS5vKG4sdCkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLHQse2VudW1lcmFibGU6ITAsZ2V0Om9bdF19KX0sbzooZSxuKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikscjplPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX19LG49e307ZS5yKG4pLGUuZChuLHtkZWZhdWx0OigpPT5vfSk7Y29uc3Qgbz1cInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9ib3JkZXI7XFxuXFxuY29uc3QgZmxvYXQgcmFkaXVzID0gMC41O1xcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTtcXG4gIGZsb2F0IGRpc3QgPSByYWRpdXMgLSBsZW5ndGgobSk7XFxuXFxuICBmbG9hdCB0ID0gMC4wO1xcbiAgaWYgKGRpc3QgPiB2X2JvcmRlcilcXG4gICAgdCA9IDEuMDtcXG4gIGVsc2UgaWYgKGRpc3QgPiAwLjApXFxuICAgIHQgPSBkaXN0IC8gdl9ib3JkZXI7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBtaXgodHJhbnNwYXJlbnQsIHZfY29sb3IsIHQpO1xcbn1cXG5cIjttb2R1bGUuZXhwb3J0cz1ufSkoKTsiLCIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgbz17ZDoodCxlKT0+e2Zvcih2YXIgbiBpbiBlKW8ubyhlLG4pJiYhby5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sbzoobyx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sdCkscjpvPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobyxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX19LHQ9e307by5yKHQpLG8uZCh0LHtkZWZhdWx0OigpPT5lfSk7Y29uc3QgZT1cImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9ib3JkZXI7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KFxcbiAgICAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSxcXG4gICAgMCxcXG4gICAgMVxcbiAgKTtcXG5cXG4gIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxcbiAgLy8gIC0geCBTQ0FMSU5HX1JBVElPIHRvIGNvcnJlY3QgdGhlIGNhbnZhcyBzY2FsaW5nXFxuICAvLyAgLSB4IDIgdG8gY29ycmVjdCB0aGUgZm9ybXVsYWVcXG4gIGdsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIHVfcmF0aW8gKiB1X3NjYWxlICogMi4wO1xcblxcbiAgdl9ib3JkZXIgPSAoMS4wIC8gdV9yYXRpbykgKiAoMC41IC8gYV9zaXplKTtcXG5cXG4gIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7bW9kdWxlLmV4cG9ydHM9dH0pKCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFNpZ21hLmpzIFNoYWRlciBVdGlsc1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENvZGUgdXNlZCB0byBsb2FkIHNpZ21hJ3Mgc2hhZGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkUHJvZ3JhbSA9IGV4cG9ydHMubG9hZEZyYWdtZW50U2hhZGVyID0gZXhwb3J0cy5sb2FkVmVydGV4U2hhZGVyID0gdm9pZCAwO1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGxvYWQgYSBzaGFkZXIuXG4gKi9cbmZ1bmN0aW9uIGxvYWRTaGFkZXIodHlwZSwgZ2wsIHNvdXJjZSkge1xuICAgIHZhciBnbFR5cGUgPSB0eXBlID09PSBcIlZFUlRFWFwiID8gZ2wuVkVSVEVYX1NIQURFUiA6IGdsLkZSQUdNRU5UX1NIQURFUjtcbiAgICAvLyBDcmVhdGluZyB0aGUgc2hhZGVyXG4gICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbFR5cGUpO1xuICAgIGlmIChzaGFkZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNoYWRlcjogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIHNoYWRlclwiKTtcbiAgICB9XG4gICAgLy8gTG9hZGluZyBzb3VyY2VcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIC8vIENvbXBpbGluZyB0aGUgc2hhZGVyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIC8vIFJldHJpZXZpbmcgY29tcGlsYXRpb24gc3RhdHVzXG4gICAgdmFyIHN1Y2Nlc3NmdWxseUNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuICAgIC8vIFRocm93aW5nIGlmIHNvbWV0aGluZyB3ZW50IGF3cnlcbiAgICBpZiAoIXN1Y2Nlc3NmdWxseUNvbXBpbGVkKSB7XG4gICAgICAgIHZhciBpbmZvTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNoYWRlcjogZXJyb3Igd2hpbGUgY29tcGlsaW5nIHRoZSBzaGFkZXI6XFxuXCIuY29uY2F0KGluZm9Mb2csIFwiXFxuXCIpLmNvbmNhdChzb3VyY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGxvYWRWZXJ0ZXhTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICAgIHJldHVybiBsb2FkU2hhZGVyKFwiVkVSVEVYXCIsIGdsLCBzb3VyY2UpO1xufVxuZXhwb3J0cy5sb2FkVmVydGV4U2hhZGVyID0gbG9hZFZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGxvYWRGcmFnbWVudFNoYWRlcihnbCwgc291cmNlKSB7XG4gICAgcmV0dXJuIGxvYWRTaGFkZXIoXCJGUkFHTUVOVFwiLCBnbCwgc291cmNlKTtcbn1cbmV4cG9ydHMubG9hZEZyYWdtZW50U2hhZGVyID0gbG9hZEZyYWdtZW50U2hhZGVyO1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGxvYWQgYSBwcm9ncmFtLlxuICovXG5mdW5jdGlvbiBsb2FkUHJvZ3JhbShnbCwgc2hhZGVycykge1xuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGlmIChwcm9ncmFtID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgcHJvZ3JhbS5cIik7XG4gICAgfVxuICAgIHZhciBpLCBsO1xuICAgIC8vIEF0dGFjaGluZyB0aGUgc2hhZGVyc1xuICAgIGZvciAoaSA9IDAsIGwgPSBzaGFkZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIC8vIENoZWNraW5nIHN0YXR1c1xuICAgIHZhciBzdWNjZXNzZnVsbHlMaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICBpZiAoIXN1Y2Nlc3NmdWxseUxpbmtlZCkge1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkUHJvZ3JhbTogZXJyb3Igd2hpbGUgbGlua2luZyB0aGUgcHJvZ3JhbS5cIik7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZXhwb3J0cy5sb2FkUHJvZ3JhbSA9IGxvYWRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFNpZ21hLmpzIFNldHRpbmdzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlzdCBvZiBzZXR0aW5ncyBhbmQgc29tZSBoYW5keSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9TRVRUSU5HUyA9IGV4cG9ydHMudmFsaWRhdGVTZXR0aW5ncyA9IHZvaWQgMDtcbnZhciBsYWJlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlbmRlcmluZy9jYW52YXMvbGFiZWxcIikpO1xudmFyIGhvdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVuZGVyaW5nL2NhbnZhcy9ob3ZlclwiKSk7XG52YXIgZWRnZV9sYWJlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlbmRlcmluZy9jYW52YXMvZWRnZS1sYWJlbFwiKSk7XG52YXIgbm9kZV9mYXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL25vZGUuZmFzdFwiKSk7XG52YXIgZWRnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlbmRlcmluZy93ZWJnbC9wcm9ncmFtcy9lZGdlXCIpKTtcbnZhciBlZGdlX2Fycm93XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2VkZ2UuYXJyb3dcIikpO1xuZnVuY3Rpb24gdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubGFiZWxEZW5zaXR5ICE9PSBcIm51bWJlclwiIHx8IHNldHRpbmdzLmxhYmVsRGVuc2l0eSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgYGxhYmVsRGVuc2l0eWAuIEV4cGVjdGluZyBhIHBvc2l0aXZlIG51bWJlci5cIik7XG4gICAgfVxuICAgIHZhciBtaW5DYW1lcmFSYXRpbyA9IHNldHRpbmdzLm1pbkNhbWVyYVJhdGlvLCBtYXhDYW1lcmFSYXRpbyA9IHNldHRpbmdzLm1heENhbWVyYVJhdGlvO1xuICAgIGlmICh0eXBlb2YgbWluQ2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1heENhbWVyYVJhdGlvID09PSBcIm51bWJlclwiICYmIG1heENhbWVyYVJhdGlvIDwgbWluQ2FtZXJhUmF0aW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgY2FtZXJhIHJhdGlvIGJvdW5kYXJpZXMuIEV4cGVjdGluZyBgbWF4Q2FtZXJhUmF0aW9gIHRvIGJlIGdyZWF0ZXIgdGhhbiBgbWluQ2FtZXJhUmF0aW9gLlwiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2V0dGluZ3MgPSB2YWxpZGF0ZVNldHRpbmdzO1xuZXhwb3J0cy5ERUZBVUxUX1NFVFRJTkdTID0ge1xuICAgIC8vIFBlcmZvcm1hbmNlXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgICBoaWRlTGFiZWxzT25Nb3ZlOiBmYWxzZSxcbiAgICByZW5kZXJMYWJlbHM6IHRydWUsXG4gICAgcmVuZGVyRWRnZUxhYmVsczogZmFsc2UsXG4gICAgZW5hYmxlRWRnZUNsaWNrRXZlbnRzOiBmYWxzZSxcbiAgICBlbmFibGVFZGdlV2hlZWxFdmVudHM6IGZhbHNlLFxuICAgIGVuYWJsZUVkZ2VIb3ZlckV2ZW50czogZmFsc2UsXG4gICAgLy8gQ29tcG9uZW50IHJlbmRlcmluZ1xuICAgIGRlZmF1bHROb2RlQ29sb3I6IFwiIzk5OVwiLFxuICAgIGRlZmF1bHROb2RlVHlwZTogXCJjaXJjbGVcIixcbiAgICBkZWZhdWx0RWRnZUNvbG9yOiBcIiNjY2NcIixcbiAgICBkZWZhdWx0RWRnZVR5cGU6IFwibGluZVwiLFxuICAgIGxhYmVsRm9udDogXCJBcmlhbFwiLFxuICAgIGxhYmVsU2l6ZTogMTQsXG4gICAgbGFiZWxXZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgbGFiZWxDb2xvcjogeyBjb2xvcjogXCIjMDAwXCIgfSxcbiAgICBlZGdlTGFiZWxGb250OiBcIkFyaWFsXCIsXG4gICAgZWRnZUxhYmVsU2l6ZTogMTQsXG4gICAgZWRnZUxhYmVsV2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgIGVkZ2VMYWJlbENvbG9yOiB7IGF0dHJpYnV0ZTogXCJjb2xvclwiIH0sXG4gICAgc3RhZ2VQYWRkaW5nOiAzMCxcbiAgICAvLyBMYWJlbHNcbiAgICBsYWJlbERlbnNpdHk6IDEsXG4gICAgbGFiZWxHcmlkQ2VsbFNpemU6IDEwMCxcbiAgICBsYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZDogNixcbiAgICAvLyBSZWR1Y2Vyc1xuICAgIG5vZGVSZWR1Y2VyOiBudWxsLFxuICAgIGVkZ2VSZWR1Y2VyOiBudWxsLFxuICAgIC8vIEZlYXR1cmVzXG4gICAgekluZGV4OiBmYWxzZSxcbiAgICBtaW5DYW1lcmFSYXRpbzogbnVsbCxcbiAgICBtYXhDYW1lcmFSYXRpbzogbnVsbCxcbiAgICAvLyBSZW5kZXJlcnNcbiAgICBsYWJlbFJlbmRlcmVyOiBsYWJlbF8xLmRlZmF1bHQsXG4gICAgaG92ZXJSZW5kZXJlcjogaG92ZXJfMS5kZWZhdWx0LFxuICAgIGVkZ2VMYWJlbFJlbmRlcmVyOiBlZGdlX2xhYmVsXzEuZGVmYXVsdCxcbiAgICAvLyBMaWZlY3ljbGVcbiAgICBhbGxvd0ludmFsaWRDb250YWluZXI6IGZhbHNlLFxuICAgIC8vIFByb2dyYW0gY2xhc3Nlc1xuICAgIG5vZGVQcm9ncmFtQ2xhc3Nlczoge1xuICAgICAgICBjaXJjbGU6IG5vZGVfZmFzdF8xLmRlZmF1bHQsXG4gICAgfSxcbiAgICBlZGdlUHJvZ3JhbUNsYXNzZXM6IHtcbiAgICAgICAgYXJyb3c6IGVkZ2VfYXJyb3dfMS5kZWZhdWx0LFxuICAgICAgICBsaW5lOiBlZGdlXzEuZGVmYXVsdCxcbiAgICB9LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2FtZXJhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29yZS9jYW1lcmFcIikpO1xudmFyIG1vdXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29yZS9jYXB0b3JzL21vdXNlXCIpKTtcbnZhciBxdWFkdHJlZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvcmUvcXVhZHRyZWVcIikpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgbGFiZWxzXzEgPSByZXF1aXJlKFwiLi9jb3JlL2xhYmVsc1wiKTtcbnZhciBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XG52YXIgdG91Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb3JlL2NhcHRvcnMvdG91Y2hcIikpO1xudmFyIG1hdHJpY2VzXzEgPSByZXF1aXJlKFwiLi91dGlscy9tYXRyaWNlc1wiKTtcbnZhciBlZGdlX2NvbGxpc2lvbnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2VkZ2UtY29sbGlzaW9uc1wiKTtcbi8qKlxuICogSW1wb3J0YW50IGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlRGVmYXVsdHMoc2V0dGluZ3MsIGtleSwgZGF0YSkge1xuICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShcInhcIikgfHwgIWRhdGEuaGFzT3duUHJvcGVydHkoXCJ5XCIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSB2YWxpZCBwb3NpdGlvbiAoeCwgeSkgZm9yIG5vZGUgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIi4gQWxsIHlvdXIgbm9kZXMgbXVzdCBoYXZlIGEgbnVtYmVyIFxcXCJ4XFxcIiBhbmQgXFxcInlcXFwiLiBNYXliZSB5b3VyIGZvcmdvdCB0byBhcHBseSBhIGxheW91dCBvciB5b3VyIFxcXCJub2RlUmVkdWNlclxcXCIgaXMgbm90IHJldHVybmluZyB0aGUgY29ycmVjdCBkYXRhP1wiKSk7XG4gICAgaWYgKCFkYXRhLmNvbG9yKVxuICAgICAgICBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdE5vZGVDb2xvcjtcbiAgICBpZiAoIWRhdGEubGFiZWwgJiYgZGF0YS5sYWJlbCAhPT0gXCJcIilcbiAgICAgICAgZGF0YS5sYWJlbCA9IG51bGw7XG4gICAgaWYgKGRhdGEubGFiZWwgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmxhYmVsICE9PSBudWxsKVxuICAgICAgICBkYXRhLmxhYmVsID0gXCJcIiArIGRhdGEubGFiZWw7XG4gICAgZWxzZVxuICAgICAgICBkYXRhLmxhYmVsID0gbnVsbDtcbiAgICBpZiAoIWRhdGEuc2l6ZSlcbiAgICAgICAgZGF0YS5zaXplID0gMjtcbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJoaWRkZW5cIikpXG4gICAgICAgIGRhdGEuaGlkZGVuID0gZmFsc2U7XG4gICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KFwiaGlnaGxpZ2h0ZWRcIikpXG4gICAgICAgIGRhdGEuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJmb3JjZUxhYmVsXCIpKVxuICAgICAgICBkYXRhLmZvcmNlTGFiZWwgPSBmYWxzZTtcbiAgICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IFwiXCIpXG4gICAgICAgIGRhdGEudHlwZSA9IHNldHRpbmdzLmRlZmF1bHROb2RlVHlwZTtcbiAgICBpZiAoIWRhdGEuekluZGV4KVxuICAgICAgICBkYXRhLnpJbmRleCA9IDA7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBhcHBseUVkZ2VEZWZhdWx0cyhzZXR0aW5ncywga2V5LCBkYXRhKSB7XG4gICAgaWYgKCFkYXRhLmNvbG9yKVxuICAgICAgICBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICBpZiAoIWRhdGEubGFiZWwpXG4gICAgICAgIGRhdGEubGFiZWwgPSBcIlwiO1xuICAgIGlmICghZGF0YS5zaXplKVxuICAgICAgICBkYXRhLnNpemUgPSAwLjU7XG4gICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KFwiaGlkZGVuXCIpKVxuICAgICAgICBkYXRhLmhpZGRlbiA9IGZhbHNlO1xuICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShcImZvcmNlTGFiZWxcIikpXG4gICAgICAgIGRhdGEuZm9yY2VMYWJlbCA9IGZhbHNlO1xuICAgIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gXCJcIilcbiAgICAgICAgZGF0YS50eXBlID0gc2V0dGluZ3MuZGVmYXVsdEVkZ2VUeXBlO1xuICAgIGlmICghZGF0YS56SW5kZXgpXG4gICAgICAgIGRhdGEuekluZGV4ID0gMDtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogTWFpbiBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7R3JhcGh9ICAgICAgIGdyYXBoICAgICAtIEdyYXBoIHRvIHJlbmRlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIERPTSBjb250YWluZXIgaW4gd2hpY2ggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgc2V0dGluZ3MgIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gKi9cbnZhciBTaWdtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbWEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbWEoZ3JhcGgsIGNvbnRhaW5lciwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgICAgICBfdGhpcy5jYW52YXNDb250ZXh0cyA9IHt9O1xuICAgICAgICBfdGhpcy53ZWJHTENvbnRleHRzID0ge307XG4gICAgICAgIF90aGlzLmFjdGl2ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICBfdGhpcy5xdWFkdHJlZSA9IG5ldyBxdWFkdHJlZV8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMubGFiZWxHcmlkID0gbmV3IGxhYmVsc18xLkxhYmVsR3JpZCgpO1xuICAgICAgICBfdGhpcy5ub2RlRGF0YUNhY2hlID0ge307XG4gICAgICAgIF90aGlzLmVkZ2VEYXRhQ2FjaGUgPSB7fTtcbiAgICAgICAgX3RoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzID0gW107XG4gICAgICAgIF90aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscyA9IFtdO1xuICAgICAgICBfdGhpcy5ub2RlRXh0ZW50ID0geyB4OiBbMCwgMV0sIHk6IFswLCAxXSB9O1xuICAgICAgICBfdGhpcy5tYXRyaXggPSAoMCwgbWF0cmljZXNfMS5pZGVudGl0eSkoKTtcbiAgICAgICAgX3RoaXMuaW52TWF0cml4ID0gKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCk7XG4gICAgICAgIF90aGlzLmNvcnJlY3Rpb25SYXRpbyA9IDE7XG4gICAgICAgIF90aGlzLmN1c3RvbUJCb3ggPSBudWxsO1xuICAgICAgICBfdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24gPSAoMCwgdXRpbHNfMS5jcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24pKHtcbiAgICAgICAgICAgIHg6IFswLCAxXSxcbiAgICAgICAgICAgIHk6IFswLCAxXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlOlxuICAgICAgICBfdGhpcy5jYW1lcmFTaXplUmF0aW8gPSAxO1xuICAgICAgICAvLyBTdGFydGluZyBkaW1lbnNpb25zIGFuZCBwaXhlbCByYXRpb1xuICAgICAgICBfdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIF90aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLnBpeGVsUmF0aW8gPSAoMCwgdXRpbHNfMS5nZXRQaXhlbFJhdGlvKSgpO1xuICAgICAgICAvLyBTdGF0ZVxuICAgICAgICBfdGhpcy5kaXNwbGF5ZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaG92ZXJlZEVkZ2UgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZW5kZXJGcmFtZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9IG51bGw7XG4gICAgICAgIF90aGlzLm5lZWRUb1Byb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubmVlZFRvU29mdFByb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY2hlY2tFZGdlc0V2ZW50c0ZyYW1lID0gbnVsbDtcbiAgICAgICAgLy8gUHJvZ3JhbXNcbiAgICAgICAgX3RoaXMubm9kZVByb2dyYW1zID0ge307XG4gICAgICAgIF90aGlzLmhvdmVyTm9kZVByb2dyYW1zID0ge307XG4gICAgICAgIF90aGlzLmVkZ2VQcm9ncmFtcyA9IHt9O1xuICAgICAgICBfdGhpcy5zZXR0aW5ncyA9ICgwLCB1dGlsc18xLmFzc2lnbikoe30sIHNldHRpbmdzXzEuREVGQVVMVF9TRVRUSU5HUywgc2V0dGluZ3MpO1xuICAgICAgICAvLyBWYWxpZGF0aW5nXG4gICAgICAgICgwLCBzZXR0aW5nc18xLnZhbGlkYXRlU2V0dGluZ3MpKF90aGlzLnNldHRpbmdzKTtcbiAgICAgICAgKDAsIHV0aWxzXzEudmFsaWRhdGVHcmFwaCkoZ3JhcGgpO1xuICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY29udGFpbmVyIHNob3VsZCBiZSBhbiBodG1sIGVsZW1lbnQuXCIpO1xuICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgIF90aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgLy8gSW5pdGlhbGl6aW5nIGNvbnRleHRzXG4gICAgICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImVkZ2VzXCIsIHsgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlIH0pO1xuICAgICAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwiZWRnZUxhYmVsc1wiKTtcbiAgICAgICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwibm9kZXNcIik7XG4gICAgICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJsYWJlbHNcIik7XG4gICAgICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJob3ZlcnNcIik7XG4gICAgICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImhvdmVyTm9kZXNcIik7XG4gICAgICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJtb3VzZVwiKTtcbiAgICAgICAgLy8gQmxlbmRpbmdcbiAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLndlYkdMQ29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IF90aGlzLndlYkdMQ29udGV4dHNba2V5XTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkaW5nIHByb2dyYW1zXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gX3RoaXMuc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICB2YXIgTm9kZVByb2dyYW1DbGFzcyA9IF90aGlzLnNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1t0eXBlXTtcbiAgICAgICAgICAgIF90aGlzLm5vZGVQcm9ncmFtc1t0eXBlXSA9IG5ldyBOb2RlUHJvZ3JhbUNsYXNzKF90aGlzLndlYkdMQ29udGV4dHMubm9kZXMsIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmhvdmVyTm9kZVByb2dyYW1zW3R5cGVdID0gbmV3IE5vZGVQcm9ncmFtQ2xhc3MoX3RoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLCBfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBfdGhpcy5zZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICAgIHZhciBFZGdlUHJvZ3JhbUNsYXNzID0gX3RoaXMuc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW3R5cGVdO1xuICAgICAgICAgICAgX3RoaXMuZWRnZVByb2dyYW1zW3R5cGVdID0gbmV3IEVkZ2VQcm9ncmFtQ2xhc3MoX3RoaXMud2ViR0xDb250ZXh0cy5lZGdlcywgX3RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWwgcmVzaXplXG4gICAgICAgIF90aGlzLnJlc2l6ZSgpO1xuICAgICAgICAvLyBJbml0aWFsaXppbmcgdGhlIGNhbWVyYVxuICAgICAgICBfdGhpcy5jYW1lcmEgPSBuZXcgY2FtZXJhXzEuZGVmYXVsdCgpO1xuICAgICAgICAvLyBCaW5kaW5nIGNhbWVyYSBldmVudHNcbiAgICAgICAgX3RoaXMuYmluZENhbWVyYUhhbmRsZXJzKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemluZyBjYXB0b3JzXG4gICAgICAgIF90aGlzLm1vdXNlQ2FwdG9yID0gbmV3IG1vdXNlXzEuZGVmYXVsdChfdGhpcy5lbGVtZW50cy5tb3VzZSwgX3RoaXMpO1xuICAgICAgICBfdGhpcy50b3VjaENhcHRvciA9IG5ldyB0b3VjaF8xLmRlZmF1bHQoX3RoaXMuZWxlbWVudHMubW91c2UsIF90aGlzKTtcbiAgICAgICAgLy8gQmluZGluZyBldmVudCBoYW5kbGVyc1xuICAgICAgICBfdGhpcy5iaW5kRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAvLyBCaW5kaW5nIGdyYXBoIGhhbmRsZXJzXG4gICAgICAgIF90aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnR1YWwgc2V0dGluZ3MtcmVsYXRlZCB0aGluZ3NcbiAgICAgICAgX3RoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUoKTtcbiAgICAgICAgLy8gUHJvY2Vzc2luZyBkYXRhIGZvciB0aGUgZmlyc3QgdGltZSAmIHJlbmRlclxuICAgICAgICBfdGhpcy5wcm9jZXNzKCk7XG4gICAgICAgIF90aGlzLnJlbmRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIEludGVybmFsIG1ldGhvZHMuXG4gICAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9ICgwLCB1dGlsc18xLmNyZWF0ZUVsZW1lbnQpKFwiY2FudmFzXCIsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNsYXNzOiBcInNpZ21hLVwiLmNvbmNhdChpZCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2lkXSA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnRcbiAgICAgKiBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5jcmVhdGVDYW52YXNDb250ZXh0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcyhpZCk7XG4gICAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHRzW2lkXSA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnRcbiAgICAgKiBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBpZCAgICAgIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAge29iamVjdD99IG9wdGlvbnMgLSAjZ2V0Q29udGV4dCBwYXJhbXMgdG8gb3ZlcnJpZGUgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5jcmVhdGVXZWJHTENvbnRleHQgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKGlkKTtcbiAgICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0gX19hc3NpZ24oeyBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLCBhbnRpYWxpYXM6IGZhbHNlIH0sIChvcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciBjb250ZXh0O1xuICAgICAgICAvLyBGaXJzdCB3ZSB0cnkgd2ViZ2wyIGZvciBhbiBlYXN5IHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICAgIC8vIEVsc2Ugd2UgZmFsbCBiYWNrIHRvIHdlYmdsXG4gICAgICAgIGlmICghY29udGV4dClcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgLy8gRWRnZSwgSSBhbSBsb29raW5nIHJpZ2h0IGF0IHlvdS4uLlxuICAgICAgICBpZiAoIWNvbnRleHQpXG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICB0aGlzLndlYkdMQ29udGV4dHNbaWRdID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBjYW1lcmEgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuYmluZENhbWVyYUhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FtZXJhLm9uKFwidXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGNoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIG5vZGUgY29sbGlkZXMgd2l0aCBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5tb3VzZUlzT25Ob2RlID0gZnVuY3Rpb24gKF9hLCBfYiwgc2l6ZSkge1xuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICB2YXIgbm9kZVggPSBfYi54LCBub2RlWSA9IF9iLnk7XG4gICAgICAgIHJldHVybiAoeCA+IG5vZGVYIC0gc2l6ZSAmJlxuICAgICAgICAgICAgeCA8IG5vZGVYICsgc2l6ZSAmJlxuICAgICAgICAgICAgeSA+IG5vZGVZIC0gc2l6ZSAmJlxuICAgICAgICAgICAgeSA8IG5vZGVZICsgc2l6ZSAmJlxuICAgICAgICAgICAgTWF0aC5zcXJ0KE1hdGgucG93KHggLSBub2RlWCwgMikgKyBNYXRoLnBvdyh5IC0gbm9kZVksIDIpKSA8IHNpemUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhbGwgbm9kZXMgaW4gcXVhZCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRRdWFkTm9kZXMgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG1vdXNlR3JhcGhQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHRyZWUucG9pbnQobW91c2VHcmFwaFBvc2l0aW9uLngsIDEgLSBtb3VzZUdyYXBoUG9zaXRpb24ueSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjbG9zZXN0IG5vZGUgdG8gYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0Tm9kZUF0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHggPSBwb3NpdGlvbi54LCB5ID0gcG9zaXRpb24ueTtcbiAgICAgICAgdmFyIHF1YWROb2RlcyA9IHRoaXMuZ2V0UXVhZE5vZGVzKHBvc2l0aW9uKTtcbiAgICAgICAgLy8gV2Ugd2lsbCBob3ZlciB0aGUgbm9kZSB3aG9zZSBjZW50ZXIgaXMgY2xvc2VzdCB0byBtb3VzZVxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSwgbm9kZUF0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHF1YWROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gcXVhZE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2NhbGVTaXplKGRhdGEuc2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaGlkZGVuICYmIHRoaXMubW91c2VJc09uTm9kZShwb3NpdGlvbiwgbm9kZVBvc2l0aW9uLCBzaXplKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gbm9kZVBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coeSAtIG5vZGVQb3NpdGlvbi55LCAyKSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29ydCBieSBtaW4gc2l6ZSBhbHNvIGZvciBjYXNlcyB3aGVyZSBjZW50ZXIgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBub2RlQXRQb3NpdGlvbiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlQXRQb3NpdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmJpbmRFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBIYW5kbGluZyB3aW5kb3cgcmVzaXplXG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5lZWRUb1NvZnRQcm9jZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplKTtcbiAgICAgICAgLy8gSGFuZGxpbmcgbW91c2UgbW92ZVxuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBub2RlVG9Ib3ZlciA9IF90aGlzLmdldE5vZGVBdFBvc2l0aW9uKGUpO1xuICAgICAgICAgICAgaWYgKG5vZGVUb0hvdmVyICYmIF90aGlzLmhvdmVyZWROb2RlICE9PSBub2RlVG9Ib3ZlciAmJiAhX3RoaXMubm9kZURhdGFDYWNoZVtub2RlVG9Ib3Zlcl0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxpbmcgcGFzc2luZyBmcm9tIG9uZSBub2RlIHRvIHRoZSBvdGhlciBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5ob3ZlcmVkTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImxlYXZlTm9kZVwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFzZUV2ZW50KSwgeyBub2RlOiBfdGhpcy5ob3ZlcmVkTm9kZSB9KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaG92ZXJlZE5vZGUgPSBub2RlVG9Ib3ZlcjtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZW50ZXJOb2RlXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlRXZlbnQpLCB7IG5vZGU6IG5vZGVUb0hvdmVyIH0pKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVja2luZyBpZiB0aGUgaG92ZXJlZCBub2RlIGlzIHN0aWxsIGhvdmVyZWRcbiAgICAgICAgICAgIGlmIChfdGhpcy5ob3ZlcmVkTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3RoaXMubm9kZURhdGFDYWNoZVtfdGhpcy5ob3ZlcmVkTm9kZV07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IF90aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLnNjYWxlU2l6ZShkYXRhLnNpemUpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMubW91c2VJc09uTm9kZShlLCBwb3MsIHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMuaG92ZXJlZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImxlYXZlTm9kZVwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFzZUV2ZW50KSwgeyBub2RlOiBub2RlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2V0dGluZ3MuZW5hYmxlRWRnZUhvdmVyRXZlbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tFZGdlSG92ZXJFdmVudHMoYmFzZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNldHRpbmdzLmVuYWJsZUVkZ2VIb3ZlckV2ZW50cyA9PT0gXCJkZWJvdW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSA9ICgwLCB1dGlsc18xLnJlcXVlc3RGcmFtZSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tFZGdlSG92ZXJFdmVudHMoYmFzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBIYW5kbGluZyBjbGlja1xuICAgICAgICB2YXIgY3JlYXRlTW91c2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpc0Zha2VTaWdtYU1vdXNlRXZlbnQgPSBlLm9yaWdpbmFsLmlzRmFrZVNpZ21hTW91c2VFdmVudDtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUF0UG9zaXRpb24gPSBpc0Zha2VTaWdtYU1vdXNlRXZlbnQgPyBfdGhpcy5nZXROb2RlQXRQb3NpdGlvbihlKSA6IF90aGlzLmhvdmVyZWROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlQXRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIk5vZGVcIiksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlRXZlbnQpLCB7IG5vZGU6IG5vZGVBdFBvc2l0aW9uIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcIndoZWVsXCIgPyBfdGhpcy5zZXR0aW5ncy5lbmFibGVFZGdlV2hlZWxFdmVudHMgOiBfdGhpcy5zZXR0aW5ncy5lbmFibGVFZGdlQ2xpY2tFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpcy5nZXRFZGdlQXRQb2ludChlLngsIGUueSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIkVkZ2VcIiksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlRXZlbnQpLCB7IGVkZ2U6IGVkZ2UgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiU3RhZ2VcIiksIGJhc2VFdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVDbGljayA9IGNyZWF0ZU1vdXNlTGlzdGVuZXIoXCJjbGlja1wiKTtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmlnaHRDbGljayA9IGNyZWF0ZU1vdXNlTGlzdGVuZXIoXCJyaWdodENsaWNrXCIpO1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayA9IGNyZWF0ZU1vdXNlTGlzdGVuZXIoXCJkb3VibGVDbGlja1wiKTtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlV2hlZWwgPSBjcmVhdGVNb3VzZUxpc3RlbmVyKFwid2hlZWxcIik7XG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24gPSBjcmVhdGVNb3VzZUxpc3RlbmVyKFwiZG93blwiKTtcbiAgICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlKTtcbiAgICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcInJpZ2h0Q2xpY2tcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmlnaHRDbGljayk7XG4gICAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJkb3VibGVDbGlja1wiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayk7XG4gICAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJ3aGVlbFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVXaGVlbCk7XG4gICAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZWRvd25cIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93bik7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gRGVhbCB3aXRoIFRvdWNoIGNhcHRvciBldmVudHNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmJpbmRHcmFwaEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5lZWRUb1Byb2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX3NjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5zb2Z0R3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5uZWVkVG9Tb2Z0UHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5fc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLm5vZGVEYXRhQ2FjaGVbZS5rZXldO1xuICAgICAgICAgICAgaWYgKF90aGlzLmhvdmVyZWROb2RlID09PSBlLmtleSlcbiAgICAgICAgICAgICAgICBfdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZ3JhcGhVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuZWRnZURhdGFDYWNoZVtlLmtleV07XG4gICAgICAgICAgICBpZiAoX3RoaXMuaG92ZXJlZEVkZ2UgPT09IGUua2V5KVxuICAgICAgICAgICAgICAgIF90aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lZGdlRGF0YUNhY2hlID0ge307XG4gICAgICAgICAgICBfdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZ3JhcGhVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIF90aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhcGgub24oXCJub2RlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZ3JhcGhVcGRhdGUpO1xuICAgICAgICBncmFwaC5vbihcIm5vZGVEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgICBncmFwaC5vbihcIm5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5zb2Z0R3JhcGhVcGRhdGUpO1xuICAgICAgICBncmFwaC5vbihcImVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZ3JhcGhVcGRhdGUpO1xuICAgICAgICBncmFwaC5vbihcImVkZ2VBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLm9uKFwiZWRnZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLm9uKFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnNvZnRHcmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLm9uKFwiZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLm9uKFwiZWRnZXNDbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyRWRnZXNHcmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLm9uKFwiY2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgZGVhbGluZyB3aXRoIFwibGVhdmVFZGdlXCIgYW5kIFwiZW50ZXJFZGdlXCIgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmNoZWNrRWRnZUhvdmVyRXZlbnRzID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGVkZ2VUb0hvdmVyID0gdGhpcy5ob3ZlcmVkTm9kZSA/IG51bGwgOiB0aGlzLmdldEVkZ2VBdFBvaW50KHBheWxvYWQuZXZlbnQueCwgcGF5bG9hZC5ldmVudC55KTtcbiAgICAgICAgaWYgKGVkZ2VUb0hvdmVyICE9PSB0aGlzLmhvdmVyZWRFZGdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJsZWF2ZUVkZ2VcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBheWxvYWQpLCB7IGVkZ2U6IHRoaXMuaG92ZXJlZEVkZ2UgfSkpO1xuICAgICAgICAgICAgaWYgKGVkZ2VUb0hvdmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVudGVyRWRnZVwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGF5bG9hZCksIHsgZWRnZTogZWRnZVRvSG92ZXIgfSkpO1xuICAgICAgICAgICAgdGhpcy5ob3ZlcmVkRWRnZSA9IGVkZ2VUb0hvdmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIGxvb2tpbmcgZm9yIGFuIGVkZ2UgY29sbGlkaW5nIHdpdGggYSBnaXZlbiBwb2ludCBhdCAoeCwgeSkuIFJldHVybnNcbiAgICAgKiB0aGUga2V5IG9mIHRoZSBlZGdlIGlmIGFueSwgb3IgbnVsbCBlbHNlLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRFZGdlQXRQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLCBlZGdlRGF0YUNhY2hlID0gX2IuZWRnZURhdGFDYWNoZSwgbm9kZURhdGFDYWNoZSA9IF9iLm5vZGVEYXRhQ2FjaGU7XG4gICAgICAgIC8vIENoZWNrIGZpcnN0IHRoYXQgcGl4ZWwgaXMgY29sb3JlZDpcbiAgICAgICAgLy8gTm90ZSB0aGF0IG1vdXNlIHBvc2l0aW9ucyBtdXN0IGJlIGNvcnJlY3RlZCBieSBwaXhlbCByYXRpbyB0byBjb3JyZWN0bHlcbiAgICAgICAgLy8gaW5kZXggdGhlIGRyYXdpbmcgYnVmZmVyLlxuICAgICAgICBpZiAoISgwLCBlZGdlX2NvbGxpc2lvbnNfMS5pc1BpeGVsQ29sb3JlZCkodGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLCB4ICogdGhpcy5waXhlbFJhdGlvLCB5ICogdGhpcy5waXhlbFJhdGlvKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBDaGVjayBmb3IgZWFjaCBlZGdlIGlmIGl0IGNvbGxpZGVzIHdpdGggdGhlIHBvaW50OlxuICAgICAgICB2YXIgX2MgPSB0aGlzLnZpZXdwb3J0VG9HcmFwaCh7IHg6IHgsIHk6IHkgfSksIGdyYXBoWCA9IF9jLngsIGdyYXBoWSA9IF9jLnk7XG4gICAgICAgIC8vIFRvIHRyYW5zbGF0ZSBlZGdlIHRoaWNrbmVzc2VzIHRvIHRoZSBncmFwaCBzeXN0ZW0sIHdlIG9ic2VydmUgYnkgaG93IG11Y2hcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBvZiBhIG5vbi1udWxsIGVkZ2UgaXMgdHJhbnNmb3JtZWQgdG8gYmV0d2VlbiB0aGUgZ3JhcGggc3lzdGVtXG4gICAgICAgIC8vIGFuZCB0aGUgdmlld3BvcnQgc3lzdGVtOlxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb25SYXRpbyA9IDA7XG4gICAgICAgIHRoaXMuZ3JhcGguc29tZUVkZ2UoZnVuY3Rpb24gKGtleSwgXywgc291cmNlSWQsIHRhcmdldElkLCBfYSwgX2IpIHtcbiAgICAgICAgICAgIHZhciB4cyA9IF9hLngsIHlzID0gX2EueTtcbiAgICAgICAgICAgIHZhciB4dCA9IF9iLngsIHl0ID0gX2IueTtcbiAgICAgICAgICAgIGlmIChlZGdlRGF0YUNhY2hlW2tleV0uaGlkZGVuIHx8IG5vZGVEYXRhQ2FjaGVbc291cmNlSWRdLmhpZGRlbiB8fCBub2RlRGF0YUNhY2hlW3RhcmdldElkXS5oaWRkZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHhzICE9PSB4dCB8fCB5cyAhPT0geXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhcGhMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coeHQgLSB4cywgMikgKyBNYXRoLnBvdyh5dCAtIHlzLCAyKSk7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gX3RoaXMuZ3JhcGhUb1ZpZXdwb3J0KHsgeDogeHMsIHk6IHlzIH0pLCB2cF94cyA9IF9jLngsIHZwX3lzID0gX2MueTtcbiAgICAgICAgICAgICAgICB2YXIgX2QgPSBfdGhpcy5ncmFwaFRvVmlld3BvcnQoeyB4OiB4dCwgeTogeXQgfSksIHZwX3h0ID0gX2QueCwgdnBfeXQgPSBfZC55O1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydExlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyh2cF94dCAtIHZwX3hzLCAyKSArIE1hdGgucG93KHZwX3l0IC0gdnBfeXMsIDIpKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvblJhdGlvID0gZ3JhcGhMZW5ndGggLyB2aWV3cG9ydExlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIG5vIG5vbi1udWxsIGVkZ2UgaGFzIGJlZW4gZm91bmQsIHJldHVybiBudWxsOlxuICAgICAgICBpZiAoIXRyYW5zZm9ybWF0aW9uUmF0aW8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gTm93IHdlIGNhbiBsb29rIGZvciBtYXRjaGluZyBlZGdlczpcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ncmFwaC5maWx0ZXJFZGdlcyhmdW5jdGlvbiAoa2V5LCBlZGdlQXR0cmlidXRlcywgc291cmNlSWQsIHRhcmdldElkLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChlZGdlRGF0YUNhY2hlW2tleV0uaGlkZGVuIHx8IG5vZGVEYXRhQ2FjaGVbc291cmNlSWRdLmhpZGRlbiB8fCBub2RlRGF0YUNhY2hlW3RhcmdldElkXS5oaWRkZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCgwLCBlZGdlX2NvbGxpc2lvbnNfMS5kb0VkZ2VDb2xsaWRlV2l0aFBvaW50KShncmFwaFgsIGdyYXBoWSwgc291cmNlUG9zaXRpb24ueCwgc291cmNlUG9zaXRpb24ueSwgdGFyZ2V0UG9zaXRpb24ueCwgdGFyZ2V0UG9zaXRpb24ueSwgXG4gICAgICAgICAgICAvLyBBZGFwdCB0aGUgZWRnZSBzaXplIHRvIHRoZSB6b29tIHJhdGlvOlxuICAgICAgICAgICAgKGVkZ2VEYXRhQ2FjaGVba2V5XS5zaXplICogdHJhbnNmb3JtYXRpb25SYXRpbykgLyBfdGhpcy5jYW1lcmFTaXplUmF0aW8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG5vIGVkZ2VzIGZvdW5kXG4gICAgICAgIC8vIGlmIG5vbmUgb2YgdGhlIGVkZ2VzIGhhdmUgYSB6SW5kZXgsIHNlbGVjdGVkIHRoZSBtb3N0IHJlY2VudGx5IGNyZWF0ZWQgb25lIHRvIG1hdGNoIHRoZSByZW5kZXJpbmcgb3JkZXJcbiAgICAgICAgdmFyIHNlbGVjdGVkRWRnZSA9IGVkZ2VzW2VkZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBvdGhlcndpc2Ugc2VsZWN0IGVkZ2Ugd2l0aCBoaWdoZXN0IHpJbmRleFxuICAgICAgICB2YXIgaGlnaGVzdFpJbmRleCA9IC1JbmZpbml0eTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGVkZ2VzXzEgPSBfX3ZhbHVlcyhlZGdlcyksIGVkZ2VzXzFfMSA9IGVkZ2VzXzEubmV4dCgpOyAhZWRnZXNfMV8xLmRvbmU7IGVkZ2VzXzFfMSA9IGVkZ2VzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHpJbmRleCA9IHRoaXMuZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZShlZGdlLCBcInpJbmRleFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoekluZGV4ID49IGhpZ2hlc3RaSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlID0gZWRnZTtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFpJbmRleCA9IHpJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc18xXzEgJiYgIWVkZ2VzXzFfMS5kb25lICYmIChfYSA9IGVkZ2VzXzEucmV0dXJuKSkgX2EuY2FsbChlZGdlc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRFZGdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcHJvY2VzcyB0aGUgd2hvbGUgZ3JhcGgncyBkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoa2VlcEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoa2VlcEFycmF5cyA9PT0gdm9pZCAwKSB7IGtlZXBBcnJheXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgICB2YXIgbm9kZVpFeHRlbnQgPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIHZhciBlZGdlWkV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgLy8gQ2xlYXJpbmcgdGhlIHF1YWRcbiAgICAgICAgdGhpcy5xdWFkdHJlZS5jbGVhcigpO1xuICAgICAgICAvLyBSZXNldHRpbmcgdGhlIGxhYmVsIGdyaWRcbiAgICAgICAgLy8gVE9ETzogaXQncyBwcm9iYWJseSBiZXR0ZXIgdG8gZG8gdGhpcyBleHBsaWNpdGx5IG9yIG9uIHJlc2l6ZXMgZm9yIGxheW91dCBhbmQgYW5pbXNcbiAgICAgICAgdGhpcy5sYWJlbEdyaWQucmVzaXplQW5kQ2xlYXIoZGltZW5zaW9ucywgc2V0dGluZ3MubGFiZWxHcmlkQ2VsbFNpemUpO1xuICAgICAgICAvLyBDbGVhciB0aGUgaGlnaGxpZ2h0ZWROb2Rlc1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIENvbXB1dGluZyBleHRlbnRzXG4gICAgICAgIHRoaXMubm9kZUV4dGVudCA9ICgwLCB1dGlsc18xLmdyYXBoRXh0ZW50KShncmFwaCk7XG4gICAgICAgIC8vIFJlc2V0dGluZyBgZm9yY2VMYWJlbGAgaW5kaWNlc1xuICAgICAgICB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVscyA9IFtdO1xuICAgICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBpdCBpcyBpbXBvcnRhbnQgdG8gY29tcHV0ZSB0aGlzIG1hdHJpeCBhZnRlciBjb21wdXRpbmcgdGhlIG5vZGUncyBleHRlbnRcbiAgICAgICAgLy8gYmVjYXVzZSAjLmdldEdyYXBoRGltZW5zaW9ucyByZWxpZXMgb24gaXRcbiAgICAgICAgdmFyIG51bGxDYW1lcmEgPSBuZXcgY2FtZXJhXzEuZGVmYXVsdCgpO1xuICAgICAgICB2YXIgbnVsbENhbWVyYU1hdHJpeCA9ICgwLCB1dGlsc18xLm1hdHJpeEZyb21DYW1lcmEpKG51bGxDYW1lcmEuZ2V0U3RhdGUoKSwgdGhpcy5nZXREaW1lbnNpb25zKCksIHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCksIHRoaXMuZ2V0U2V0dGluZyhcInN0YWdlUGFkZGluZ1wiKSB8fCAwKTtcbiAgICAgICAgLy8gUmVzY2FsaW5nIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uID0gKDAsIHV0aWxzXzEuY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKSh0aGlzLmN1c3RvbUJCb3ggfHwgdGhpcy5ub2RlRXh0ZW50KTtcbiAgICAgICAgdmFyIG5vZGVzUGVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAvLyBOb2RlIGRpc3BsYXkgZGF0YSByZXNvbHV0aW9uOlxuICAgICAgICAgICAgLy8gICAxLiBGaXJzdCB3ZSBnZXQgdGhlIG5vZGUncyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyAgIDIuIFdlIG9wdGlvbmFsbHkgcmVkdWNlIHRoZW0gdXNpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAvLyAgICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdG90YWwgb2JqZWN0IGFuZCB3b24ndCBiZSBtZXJnZWRcbiAgICAgICAgICAgIC8vICAgMy4gV2UgYXBwbHkgb3VyIGRlZmF1bHRzLCB3aGlsZSBydW5uaW5nIHNvbWUgdml0YWwgY2hlY2tzXG4gICAgICAgICAgICAvLyAgIDQuIFdlIGFwcGx5IHRoZSBub3JtYWxpemF0aW9uIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBXZSBzaGFsbG93IGNvcHkgbm9kZSBkYXRhIHRvIGF2b2lkIGRhbmdlcm91cyBiZWhhdmlvcnMgZnJvbSByZWR1Y2Vyc1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBPYmplY3QuYXNzaWduKHt9LCBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhub2RlKSk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9kZVJlZHVjZXIpXG4gICAgICAgICAgICAgICAgYXR0ciA9IHNldHRpbmdzLm5vZGVSZWR1Y2VyKG5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBhcHBseU5vZGVEZWZhdWx0cyh0aGlzLnNldHRpbmdzLCBub2RlLCBhdHRyKTtcbiAgICAgICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSA9IChub2Rlc1BlclByb2dyYW1zW2RhdGEudHlwZV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmFwcGx5VG8oZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5mb3JjZUxhYmVsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS56SW5kZXggPCBub2RlWkV4dGVudFswXSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZVpFeHRlbnRbMF0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS56SW5kZXggPiBub2RlWkV4dGVudFsxXSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZVpFeHRlbnRbMV0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXBBcnJheXMpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0uYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgICAgIC8vIFdlIHJlc2V0IHRoYXQgY291bnQgaGVyZSwgc28gdGhhdCB3ZSBjYW4gcmV1c2UgaXQgd2hpbGUgY2FsbGluZyB0aGUgUHJvZ3JhbSNwcm9jZXNzIG1ldGhvZHM6XG4gICAgICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGluZyBub2RlIHotaW5kZXhcbiAgICAgICAgLy8gVE9ETzogei1pbmRleCBuZWVkcyB1cyB0byBjb21wdXRlIGRpc3BsYXkgZGF0YSBiZWZvcmUgaGFuZFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXggJiYgbm9kZVpFeHRlbnRbMF0gIT09IG5vZGVaRXh0ZW50WzFdKVxuICAgICAgICAgICAgbm9kZXMgPSAoMCwgdXRpbHNfMS56SW5kZXhPcmRlcmluZykobm9kZVpFeHRlbnQsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdLnpJbmRleDsgfSwgbm9kZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICAgICAgdGhpcy5xdWFkdHJlZS5hZGQobm9kZSwgZGF0YS54LCAxIC0gZGF0YS55LCBkYXRhLnNpemUgLyB0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiAhZGF0YS5oaWRkZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbEdyaWQuYWRkKG5vZGUsIGRhdGEuc2l6ZSwgdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSwgeyBtYXRyaXg6IG51bGxDYW1lcmFNYXRyaXggfSkpO1xuICAgICAgICAgICAgdmFyIG5vZGVQcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgICAgICAgIGlmICghbm9kZVByb2dyYW0pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQoZGF0YS50eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgICAgICAgIG5vZGVQcm9ncmFtLnByb2Nlc3MoZGF0YSwgZGF0YS5oaWRkZW4sIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSsrKTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIG5vZGUgaW4gdGhlIGhpZ2hsaWdodGVkIHNldCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChkYXRhLmhpZ2hsaWdodGVkICYmICFkYXRhLmhpZGRlbilcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFiZWxHcmlkLm9yZ2FuaXplKCk7XG4gICAgICAgIHZhciBlZGdlc1BlclByb2dyYW1zID0ge307XG4gICAgICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gRWRnZSBkaXNwbGF5IGRhdGEgcmVzb2x1dGlvbjpcbiAgICAgICAgICAgIC8vICAgMS4gRmlyc3Qgd2UgZ2V0IHRoZSBlZGdlJ3MgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gICAyLiBXZSBvcHRpb25hbGx5IHJlZHVjZSB0aGVtIHVzaW5nIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgLy8gICAgICBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHRvdGFsIG9iamVjdCBhbmQgd29uJ3QgYmUgbWVyZ2VkXG4gICAgICAgICAgICAvLyAgIDMuIFdlIGFwcGx5IG91ciBkZWZhdWx0cywgd2hpbGUgcnVubmluZyBzb21lIHZpdGFsIGNoZWNrc1xuICAgICAgICAgICAgLy8gV2Ugc2hhbGxvdyBjb3B5IGVkZ2UgZGF0YSB0byBhdm9pZCBkYW5nZXJvdXMgYmVoYXZpb3JzIGZyb20gcmVkdWNlcnNcbiAgICAgICAgICAgIHZhciBhdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZXMoZWRnZSkpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVkZ2VSZWR1Y2VyKVxuICAgICAgICAgICAgICAgIGF0dHIgPSBzZXR0aW5ncy5lZGdlUmVkdWNlcihlZGdlLCBhdHRyKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXBwbHlFZGdlRGVmYXVsdHModGhpcy5zZXR0aW5ncywgZWRnZSwgYXR0cik7XG4gICAgICAgICAgICBlZGdlc1BlclByb2dyYW1zW2RhdGEudHlwZV0gPSAoZWRnZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXSA9IGRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5mb3JjZUxhYmVsICYmICFkYXRhLmhpZGRlbilcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVscy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuekluZGV4IDwgZWRnZVpFeHRlbnRbMF0pXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VaRXh0ZW50WzBdID0gZGF0YS56SW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuekluZGV4ID4gZWRnZVpFeHRlbnRbMV0pXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VaRXh0ZW50WzFdID0gZGF0YS56SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIGVkZ2UgdHlwZSBcXFwiXCIuY29uY2F0KHR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwQXJyYXlzKVxuICAgICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW3R5cGVdLmFsbG9jYXRlKGVkZ2VzUGVyUHJvZ3JhbXNbdHlwZV0gfHwgMCk7XG4gICAgICAgICAgICAvLyBXZSByZXNldCB0aGF0IGNvdW50IGhlcmUsIHNvIHRoYXQgd2UgY2FuIHJldXNlIGl0IHdoaWxlIGNhbGxpbmcgdGhlIFByb2dyYW0jcHJvY2VzcyBtZXRob2RzOlxuICAgICAgICAgICAgZWRnZXNQZXJQcm9ncmFtc1t0eXBlXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxpbmcgZWRnZSB6LWluZGV4XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCAmJiBlZGdlWkV4dGVudFswXSAhPT0gZWRnZVpFeHRlbnRbMV0pXG4gICAgICAgICAgICBlZGdlcyA9ICgwLCB1dGlsc18xLnpJbmRleE9yZGVyaW5nKShlZGdlWkV4dGVudCwgZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIF90aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV0uekluZGV4OyB9LCBlZGdlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG4gICAgICAgICAgICB2YXIgZXh0cmVtaXRpZXMgPSBncmFwaC5leHRyZW1pdGllcyhlZGdlKSwgc291cmNlRGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1swXV0sIHRhcmdldERhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMV1dO1xuICAgICAgICAgICAgdmFyIGhpZGRlbiA9IGRhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuO1xuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbZGF0YS50eXBlXS5wcm9jZXNzKHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEsIGhpZGRlbiwgZWRnZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdKyspO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5lZGdlUHJvZ3JhbXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoIWtlZXBBcnJheXMgJiYgdHlwZW9mIHByb2dyYW0uY29tcHV0ZUluZGljZXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNvbXB1dGVJbmRpY2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBiYWNrcG9ydHMgcG90ZW50aWFsIHNldHRpbmdzIHVwZGF0ZXMgd2hlcmUgaXQncyBuZWVkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhLm1pblJhdGlvID0gdGhpcy5zZXR0aW5ncy5taW5DYW1lcmFSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmEubWF4UmF0aW8gPSB0aGlzLnNldHRpbmdzLm1heENhbWVyYVJhdGlvO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRTdGF0ZSh0aGlzLmNhbWVyYS52YWxpZGF0ZVN0YXRlKHRoaXMuY2FtZXJhLmdldFN0YXRlKCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWNpZGVzIHdoZXRoZXIgdG8gcmVwcm9jZXNzIGdyYXBoIG9yIG5vdCwgYW5kIHRoZW4gcmVuZGVyIHRoZVxuICAgICAqIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHByb2Nlc3MgZGF0YT9cbiAgICAgICAgaWYgKHRoaXMubmVlZFRvUHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZWVkVG9Tb2Z0UHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0dGluZyBzdGF0ZVxuICAgICAgICB0aGlzLm5lZWRUb1Byb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZWVkVG9Tb2Z0UHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICAvLyBSZW5kZXJpbmdcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBzY2hlZHVsZXMgYSBgX3JlZnJlc2hgIGNhbGwgaWYgbm9uZSBoYXMgYmVlbiBzY2hlZHVsZWQgeWV0LiBJdFxuICAgICAqIHdpbGwgdGhlbiBiZSBwcm9jZXNzZWQgbmV4dCBhdmFpbGFibGUgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuX3NjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlckZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZyYW1lID0gKDAsIHV0aWxzXzEucmVxdWVzdEZyYW1lKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUucmVuZGVyTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmVuZGVyTGFiZWxzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIEZpbmRpbmcgdmlzaWJsZSBub2RlcyB0byBkaXNwbGF5IHRoZWlyIGxhYmVsc1xuICAgICAgICB2YXIgdmlzaWJsZU5vZGVzO1xuICAgICAgICBpZiAoY2FtZXJhU3RhdGUucmF0aW8gPj0gMSkge1xuICAgICAgICAgICAgLy8gQ2FtZXJhIGlzIHVuem9vbWVkIHNvIG5vIG5lZWQgdG8gYXNrIHRoZSBxdWFkdHJlZSBmb3IgdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgdmlzaWJsZU5vZGVzID0gbmV3IFNldCh0aGlzLmdyYXBoLm5vZGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTGV0J3MgYXNrIHRoZSBxdWFkdHJlZVxuICAgICAgICAgICAgdmFyIHZpZXdSZWN0YW5nbGUgPSB0aGlzLnZpZXdSZWN0YW5nbGUoKTtcbiAgICAgICAgICAgIHZpc2libGVOb2RlcyA9IG5ldyBTZXQodGhpcy5xdWFkdHJlZS5yZWN0YW5nbGUodmlld1JlY3RhbmdsZS54MSwgMSAtIHZpZXdSZWN0YW5nbGUueTEsIHZpZXdSZWN0YW5nbGUueDIsIDEgLSB2aWV3UmVjdGFuZ2xlLnkyLCB2aWV3UmVjdGFuZ2xlLmhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbGVjdGluZyBsYWJlbHMgdG8gZHJhd1xuICAgICAgICAvLyBUT0RPOiBkcm9wIGdyaWRzZXR0aW5ncyBsaWtld2lzZVxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aHJvdWdoIHZpc2libGUgbm9kZXNcbiAgICAgICAgdmFyIGxhYmVsc1RvRGlzcGxheSA9IHRoaXMubGFiZWxHcmlkXG4gICAgICAgICAgICAuZ2V0TGFiZWxzVG9EaXNwbGF5KGNhbWVyYVN0YXRlLnJhdGlvLCB0aGlzLnNldHRpbmdzLmxhYmVsRGVuc2l0eSlcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMpO1xuICAgICAgICB0aGlzLmRpc3BsYXllZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gRHJhd2luZyBsYWJlbHNcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHRzLmxhYmVscztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsYWJlbHNUb0Rpc3BsYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGxhYmVsc1RvRGlzcGxheVtpXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgd2FzIGFscmVhZHkgZHJhd24gKGxpa2UgaWYgaXQgaXMgZWxpZ2libGUgQU5EIGhhc1xuICAgICAgICAgICAgLy8gYGZvcmNlTGFiZWxgKSwgd2UgZG9uJ3Qgd2FudCB0byBkcmF3IGl0IGFnYWluXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5ZWRMYWJlbHMuaGFzKG5vZGUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgaGlkZGVuLCB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgaXRzIGxhYmVsIG9idmlvdXNseVxuICAgICAgICAgICAgaWYgKGRhdGEuaGlkZGVuKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSksIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIGNhbiBjYWNoZSB0aGUgbGFiZWxzIHdlIG5lZWQgdG8gcmVuZGVyIHVudGlsIHRoZSBjYW1lcmEncyByYXRpbyBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBjb21wdXRlZCBpbiB0aGUgY2FudmFzIGNvbXBvbmVudHM/XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2NhbGVTaXplKGRhdGEuc2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWRhdGEuZm9yY2VMYWJlbCAmJiBzaXplIDwgdGhpcy5zZXR0aW5ncy5sYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZU5vZGVzLmhhcyhub2RlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIFRPRE86XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGRpc3BsYXllZCBlZGdlIGxhYmVscyBkZXBlbmQgZGlyZWN0bHkgb24gYWN0dWFsbHkgcmVuZGVyZWQgbm9kZVxuICAgICAgICAgICAgLy8gbGFiZWxzLCB3ZSBuZWVkIHRvIG9ubHkgYWRkIHRvIHRoaXMuZGlzcGxheWVkTGFiZWxzIG5vZGVzIHdob3NlIGxhYmVsXG4gICAgICAgICAgICAvLyBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgdGhpcy5kaXNwbGF5ZWRMYWJlbHMgZGVwZW5kIG9uIHZpZXdwb3J0LCB3aGljaCBtaWdodCBiZWNvbWVcbiAgICAgICAgICAgIC8vIGFuIGlzc3VlIG9uY2Ugd2Ugc3RhcnQgbWVtb2l6aW5nIGdldExhYmVsc1RvRGlzcGxheS5cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheWVkTGFiZWxzLmFkZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubGFiZWxSZW5kZXJlcihjb250ZXh0LCBfX2Fzc2lnbihfX2Fzc2lnbih7IGtleTogbm9kZSB9LCBkYXRhKSwgeyBzaXplOiBzaXplLCB4OiB4LCB5OiB5IH0pLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciBlZGdlIGxhYmVscywgYmFzZWQgb24gd2hpY2ggbm9kZSBsYWJlbHMgd2VyZVxuICAgICAqIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLnJlbmRlckVkZ2VMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yZW5kZXJFZGdlTGFiZWxzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzO1xuICAgICAgICAvLyBDbGVhcmluZ1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHZhciBlZGdlTGFiZWxzVG9EaXNwbGF5ID0gKDAsIGxhYmVsc18xLmVkZ2VMYWJlbHNUb0Rpc3BsYXlGcm9tTm9kZXMpKHtcbiAgICAgICAgICAgIGdyYXBoOiB0aGlzLmdyYXBoLFxuICAgICAgICAgICAgaG92ZXJlZE5vZGU6IHRoaXMuaG92ZXJlZE5vZGUsXG4gICAgICAgICAgICBkaXNwbGF5ZWROb2RlTGFiZWxzOiB0aGlzLmRpc3BsYXllZExhYmVscyxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkTm9kZXM6IHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyxcbiAgICAgICAgfSkuY29uY2F0KHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzKTtcbiAgICAgICAgdmFyIGRpc3BsYXllZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlZGdlTGFiZWxzVG9EaXNwbGF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlTGFiZWxzVG9EaXNwbGF5W2ldLCBleHRyZW1pdGllcyA9IHRoaXMuZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSksIHNvdXJjZURhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMF1dLCB0YXJnZXREYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzFdXSwgZWRnZURhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWRnZSB3YXMgYWxyZWFkeSBkcmF3biAobGlrZSBpZiBpdCBpcyBlbGlnaWJsZSBBTkQgaGFzXG4gICAgICAgICAgICAvLyBgZm9yY2VMYWJlbGApLCB3ZSBkb24ndCB3YW50IHRvIGRyYXcgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmIChkaXNwbGF5ZWRMYWJlbHMuaGFzKGVkZ2UpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVkZ2UgaXMgaGlkZGVuIHdlIGRvbid0IG5lZWQgdG8gZGlzcGxheSBpdHMgbGFiZWxcbiAgICAgICAgICAgIC8vIE5PVEU6IHRoZSB0ZXN0IG9uIHNvdXJjZURhdGEgJiB0YXJnZXREYXRhIGlzIHByb2JhYmx5IHBhcmFub2lkIGF0IHRoaXMgcG9pbnQ/XG4gICAgICAgICAgICBpZiAoZWRnZURhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmVkZ2VMYWJlbFJlbmRlcmVyKGNvbnRleHQsIF9fYXNzaWduKF9fYXNzaWduKHsga2V5OiBlZGdlIH0sIGVkZ2VEYXRhKSwgeyBzaXplOiB0aGlzLnNjYWxlU2l6ZShlZGdlRGF0YS5zaXplKSB9KSwgX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyBrZXk6IGV4dHJlbWl0aWVzWzBdIH0sIHNvdXJjZURhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChzb3VyY2VEYXRhKSksIHsgc2l6ZTogdGhpcy5zY2FsZVNpemUoc291cmNlRGF0YS5zaXplKSB9KSwgX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyBrZXk6IGV4dHJlbWl0aWVzWzFdIH0sIHRhcmdldERhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydCh0YXJnZXREYXRhKSksIHsgc2l6ZTogdGhpcy5zY2FsZVNpemUodGFyZ2V0RGF0YS5zaXplKSB9KSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICBkaXNwbGF5ZWRMYWJlbHMuYWRkKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIHRoZSBoaWdobGlnaHRlZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5yZW5kZXJIaWdobGlnaHRlZE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMuaG92ZXJzO1xuICAgICAgICAvLyBDbGVhcmluZ1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIC8vIFJlbmRlcmluZ1xuICAgICAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX3RoaXMubm9kZURhdGFDYWNoZVtub2RlXTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhKSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAgICAgdmFyIHNpemUgPSBfdGhpcy5zY2FsZVNpemUoZGF0YS5zaXplKTtcbiAgICAgICAgICAgIF90aGlzLnNldHRpbmdzLmhvdmVyUmVuZGVyZXIoY29udGV4dCwgX19hc3NpZ24oX19hc3NpZ24oeyBrZXk6IG5vZGUgfSwgZGF0YSksIHsgc2l6ZTogc2l6ZSwgeDogeCwgeTogeSB9KSwgX3RoaXMuc2V0dGluZ3MpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9kZXNUb1JlbmRlciA9IFtdO1xuICAgICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSAmJiAhdGhpcy5ub2RlRGF0YUNhY2hlW3RoaXMuaG92ZXJlZE5vZGVdLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZXNUb1JlbmRlci5wdXNoKHRoaXMuaG92ZXJlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgaG92ZXJlZCBub2RlIGhhcyBhbHJlYWR5IGJlZW4gaGlnaGxpZ2h0ZWRcbiAgICAgICAgICAgIGlmIChub2RlICE9PSBfdGhpcy5ob3ZlcmVkTm9kZSlcbiAgICAgICAgICAgICAgICBub2Rlc1RvUmVuZGVyLnB1c2gobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiByZW5kZXIobm9kZSk7IH0pO1xuICAgICAgICAvLyBEcmF3IFdlYkdMIG5vZGVzIG9uIHRvcCBvZiB0aGUgbGFiZWxzOlxuICAgICAgICB2YXIgbm9kZXNQZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgICAvLyAxLiBDb3VudCBub2RlcyBwZXIgdHlwZTpcbiAgICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF90aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV0udHlwZTtcbiAgICAgICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAyLiBBbGxvY2F0ZSBmb3IgZWFjaCB0eXBlIGZvciB0aGUgcHJvcGVyIG51bWJlciBvZiBub2Rlc1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuaG92ZXJOb2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJOb2RlUHJvZ3JhbXNbdHlwZV0uYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgICAgIC8vIEFsc28gcmVzZXQgY291bnQsIHRvIHVzZSB3aGVuIHJlbmRlcmluZzpcbiAgICAgICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIFByb2Nlc3MgYWxsIG5vZGVzIHRvIHJlbmRlcjpcbiAgICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF90aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgICAgICBfdGhpcy5ob3Zlck5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdLnByb2Nlc3MoZGF0YSwgZGF0YS5oaWRkZW4sIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSsrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDQuIENsZWFyIGhvdmVyZWQgbm9kZXMgbGF5ZXI6XG4gICAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLmNsZWFyKHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAvLyA1LiBSZW5kZXI6XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ob3Zlck5vZGVQcm9ncmFtcykge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLmhvdmVyTm9kZVByb2dyYW1zW3R5cGVdO1xuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XG4gICAgICAgICAgICBwcm9ncmFtLmJ1ZmZlckRhdGEoKTtcbiAgICAgICAgICAgIHByb2dyYW0ucmVuZGVyKHtcbiAgICAgICAgICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8gLyB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIGhvdmVyIHJlbmRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSB8fCB0aGlzLnJlbmRlckZyYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9ICgwLCB1dGlsc18xLnJlcXVlc3RGcmFtZSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVzZXR0aW5nIHN0YXRlXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gUmVuZGVyaW5nXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzKCk7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJFZGdlTGFiZWxzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgICAgICB2YXIgaGFuZGxlRXNjYXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBhIHJlbmRlciB3YXMgc2NoZWR1bGVkLCB3ZSBjYW5jZWwgaXRcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmNhbmNlbEZyYW1lKSh0aGlzLnJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZWVkVG9Qcm9jZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5lZWRUb1NvZnRQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byByZXNpemVcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgLy8gQ2xlYXJpbmcgdGhlIGNhbnZhc2VzXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgLy8gUmVjb21wdXRpbmcgdXNlZnVsIGNhbWVyYS1yZWxhdGVkIHZhbHVlczpcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRWYWx1ZXMoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBub2RlcyB3ZSBjYW4gc3RvcCByaWdodCB0aGVyZVxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgub3JkZXIpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXNjYXBlKCk7XG4gICAgICAgIC8vIFRPRE86IGltcHJvdmUgdGhpcyBoZXVyaXN0aWMgb3IgbW92ZSB0byB0aGUgY2FwdG9yIGl0c2VsZj9cbiAgICAgICAgLy8gVE9ETzogZGVhbCB3aXRoIHRoZSB0b3VjaCBjYXB0b3IgaGVyZSBhcyB3ZWxsXG4gICAgICAgIHZhciBtb3VzZUNhcHRvciA9IHRoaXMubW91c2VDYXB0b3I7XG4gICAgICAgIHZhciBtb3ZpbmcgPSB0aGlzLmNhbWVyYS5pc0FuaW1hdGVkKCkgfHxcbiAgICAgICAgICAgIG1vdXNlQ2FwdG9yLmlzTW92aW5nIHx8XG4gICAgICAgICAgICBtb3VzZUNhcHRvci5kcmFnZ2VkRXZlbnRzIHx8XG4gICAgICAgICAgICBtb3VzZUNhcHRvci5jdXJyZW50V2hlZWxEaXJlY3Rpb247XG4gICAgICAgIC8vIFRoZW4gd2UgbmVlZCB0byBleHRyYWN0IGEgbWF0cml4IGZyb20gdGhlIGNhbWVyYVxuICAgICAgICB2YXIgY2FtZXJhU3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHZhciBncmFwaERpbWVuc2lvbnMgPSB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0U2V0dGluZyhcInN0YWdlUGFkZGluZ1wiKSB8fCAwO1xuICAgICAgICB0aGlzLm1hdHJpeCA9ICgwLCB1dGlsc18xLm1hdHJpeEZyb21DYW1lcmEpKGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZyk7XG4gICAgICAgIHRoaXMuaW52TWF0cml4ID0gKDAsIHV0aWxzXzEubWF0cml4RnJvbUNhbWVyYSkoY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb3JyZWN0aW9uUmF0aW8gPSAoMCwgdXRpbHNfMS5nZXRNYXRyaXhJbXBhY3QpKHRoaXMubWF0cml4LCBjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zKTtcbiAgICAgICAgLy8gRHJhd2luZyBub2Rlc1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZVByb2dyYW1zW3R5cGVdO1xuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XG4gICAgICAgICAgICBwcm9ncmFtLmJ1ZmZlckRhdGEoKTtcbiAgICAgICAgICAgIHByb2dyYW0ucmVuZGVyKHtcbiAgICAgICAgICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcmF0aW86IGNhbWVyYVN0YXRlLnJhdGlvLFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8gLyBjYW1lcmFTdGF0ZS5yYXRpbyxcbiAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERyYXdpbmcgZWRnZXNcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmhpZGVFZGdlc09uTW92ZSB8fCAhbW92aW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuZWRnZVByb2dyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmJ1ZmZlckRhdGEoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnJlbmRlcih7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByYXRpbzogY2FtZXJhU3RhdGUucmF0aW8sXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8gLyBjYW1lcmFTdGF0ZS5yYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGRpc3BsYXkgbGFiZWxzIG9uIG1vdmUgcGVyIHNldHRpbmdcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGlkZUxhYmVsc09uTW92ZSAmJiBtb3ZpbmcpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXNjYXBlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyRWRnZUxhYmVscygpO1xuICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUVzY2FwZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gdXBkYXRlIGV4cGVuc2l2ZSBhbmQgdGhlcmVmb3JlIGNhY2hlZCB2YWx1ZXNcbiAgICAgKiBlYWNoIHRpbWUgdGhlIGNhbWVyYSBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS51cGRhdGVDYWNoZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYXRpbyA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCkucmF0aW87XG4gICAgICAgIHRoaXMuY2FtZXJhU2l6ZVJhdGlvID0gTWF0aC5zcXJ0KHJhdGlvKTtcbiAgICB9O1xuICAgIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIFB1YmxpYyBBUEkuXG4gICAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDYW1lcmF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmdldENhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0dyYXBofVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBtb3VzZSBjYXB0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNb3VzZUNhcHRvcn1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0TW91c2VDYXB0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlQ2FwdG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgdG91Y2ggY2FwdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7VG91Y2hDYXB0b3J9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmdldFRvdWNoQ2FwdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3VjaENhcHRvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgcmVuZGVyZXIncyBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgZ3JhcGgncyBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0R3JhcGhEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBleHRlbnQueFsxXSAtIGV4dGVudC54WzBdIHx8IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IGV4dGVudC55WzFdIC0gZXh0ZW50LnlbMF0gfHwgMSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHNpZ21hIG5vZGUgYXR0cmlidXRlcy5cbiAgICAgKiBJdCdzIHVzZWZ1bGwgZm9yIGV4YW1wbGUgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcbiAgICAgKiBhbmQgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIG5vZGVSZWR1Y2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgICAqIEByZXR1cm4ge05vZGVEaXNwbGF5RGF0YSB8IHVuZGVmaW5lZH0gQSBjb3B5IG9mIHRoZSBkZXNpcmVkIG5vZGUncyBhdHRyaWJ1dGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXROb2RlRGlzcGxheURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICAgIHJldHVybiBub2RlID8gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBlZGdlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWxsIGZvciBleGFtcGxlIHRvIGdldCB2YWx1ZXMgdGhhdCBhcmUgc2V0IGJ5IHRoZSBlZGdlUmVkdWNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIGVkZ2UncyBrZXkuXG4gICAgICogQHJldHVybiB7RWRnZURpc3BsYXlEYXRhIHwgdW5kZWZpbmVkfSBBIGNvcHkgb2YgdGhlIGRlc2lyZWQgZWRnZSdzIGF0dHJpYnV0ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmdldEVkZ2VEaXNwbGF5RGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgICAgcmV0dXJuIGVkZ2UgPyBPYmplY3QuYXNzaWduKHt9LCBlZGdlKSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgYSBjb3B5IG9mIHRoZSBzZXR0aW5ncyBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2V0dGluZ3N9IEEgY29weSBvZiB0aGUgc2V0dGluZ3MgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBhIGdpdmVuIHNldHRpbmcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgc2V0dGluZyBrZXkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlIGF0dGFjaGVkIHRvIHRoaXMgc2V0dGluZyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRTZXR0aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgKiBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHthbnl9ICAgIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuc2V0U2V0dGluZyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAoMCwgc2V0dGluZ3NfMS52YWxpZGF0ZVNldHRpbmdzKSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZXR0aW5nc1VwZGF0ZSgpO1xuICAgICAgICB0aGlzLm5lZWRUb1Byb2Nlc3MgPSB0cnVlOyAvLyBUT0RPOiBzb21lIGtleXMgbWF5IHdvcmsgd2l0aCBvbmx5IG5lZWRUb1NvZnRQcm9jZXNzIG9yIGV2ZW4gbm90aGluZ1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXBkYXRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGUgYSBuZXcgcmVuZGVyIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAga2V5ICAgICAtIFRoZSBzZXR0aW5nIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBUaGUgdXBkYXRlIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS51cGRhdGVTZXR0aW5nID0gZnVuY3Rpb24gKGtleSwgdXBkYXRlcikge1xuICAgICAgICB0aGlzLnNldHRpbmdzW2tleV0gPSB1cGRhdGVyKHRoaXMuc2V0dGluZ3Nba2V5XSk7XG4gICAgICAgICgwLCBzZXR0aW5nc18xLnZhbGlkYXRlU2V0dGluZ3MpKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVNldHRpbmdzVXBkYXRlKCk7XG4gICAgICAgIHRoaXMubmVlZFRvUHJvY2VzcyA9IHRydWU7IC8vIFRPRE86IHNvbWUga2V5cyBtYXkgd29yayB3aXRoIG9ubHkgbmVlZFRvU29mdFByb2Nlc3Mgb3IgZXZlbiBub3RoaW5nXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlc2l6ZSB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXNXaWR0aCA9IHRoaXMud2lkdGgsIHByZXZpb3VzSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICgwLCB1dGlsc18xLmdldFBpeGVsUmF0aW8pKCk7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbGxvd0ludmFsaWRDb250YWluZXIpXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IENvbnRhaW5lciBoYXMgbm8gd2lkdGguIFlvdSBjYW4gc2V0IHRoZSBhbGxvd0ludmFsaWRDb250YWluZXIgc2V0dGluZyB0byB0cnVlIHRvIHN0b3Agc2VlaW5nIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dJbnZhbGlkQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29udGFpbmVyIGhhcyBubyBoZWlnaHQuIFlvdSBjYW4gc2V0IHRoZSBhbGxvd0ludmFsaWRDb250YWluZXIgc2V0dGluZyB0byB0cnVlIHRvIHN0b3Agc2VlaW5nIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHdlIGNhbiBzdG9wIHJpZ2h0IGhlcmVcbiAgICAgICAgaWYgKHByZXZpb3VzV2lkdGggPT09IHRoaXMud2lkdGggJiYgcHJldmlvdXNIZWlnaHQgPT09IHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInJlc2l6ZVwiKTtcbiAgICAgICAgLy8gU2l6aW5nIGRvbSBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpemluZyBjYW52YXMgY29udGV4dHNcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jYW52YXNDb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpZF0uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2lkXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHRzW2lkXS5zY2FsZSh0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2l6aW5nIFdlYkdMIGNvbnRleHRzXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMud2ViR0xDb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpZF0uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2lkXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICAgICAgdGhpcy53ZWJHTENvbnRleHRzW2lkXS52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjbGVhciBhbGwgdGhlIGNhbnZhc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndlYkdMQ29udGV4dHMubm9kZXMuY2xlYXIodGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMuY2xlYXIodGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5jbGVhcih0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5sYWJlbHMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5ob3ZlcnMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVmcmVzaCBhbGwgY29tcHV0ZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5lZWRUb1Byb2Nlc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVmcmVzaCBhbGwgY29tcHV0ZWQgZGF0YSwgYXQgdGhlIG5leHQgYXZhaWxhYmxlIGZyYW1lLlxuICAgICAqIElmIHRoaXMgbWV0aG9kIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHRoaXMgZnJhbWUsIHRoZW4gaXQgd2lsbCBvbmx5IHJlbmRlciBvbmNlIGF0IHRoZSBuZXh0IGF2YWlsYWJsZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5zY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubmVlZFRvUHJvY2VzcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvICh1bil6b29tLCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBwb3NpdGlvbiBvZiBhIHZpZXdwb3J0IHBvaW50LlxuICAgICAqIFVzZWQgZm9yIGluc3RhbmNlIHRvIHpvb20gXCJvbiB0aGUgbW91c2UgY3Vyc29yXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld3BvcnRUYXJnZXRcbiAgICAgKiBAcGFyYW0gbmV3UmF0aW9cbiAgICAgKiBAcmV0dXJuIHtDYW1lcmFTdGF0ZX1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZSA9IGZ1bmN0aW9uICh2aWV3cG9ydFRhcmdldCwgbmV3UmF0aW8pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgcmF0aW8gPSBfYS5yYXRpbywgYW5nbGUgPSBfYS5hbmdsZSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbWF4IHpvb21cbiAgICAgICAgdmFyIHJhdGlvRGlmZiA9IG5ld1JhdGlvIC8gcmF0aW87XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdyYXBoTW91c2VQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHZpZXdwb3J0VGFyZ2V0KTtcbiAgICAgICAgdmFyIGdyYXBoQ2VudGVyUG9zaXRpb24gPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaChjZW50ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgeDogKGdyYXBoTW91c2VQb3NpdGlvbi54IC0gZ3JhcGhDZW50ZXJQb3NpdGlvbi54KSAqICgxIC0gcmF0aW9EaWZmKSArIHgsXG4gICAgICAgICAgICB5OiAoZ3JhcGhNb3VzZVBvc2l0aW9uLnkgLSBncmFwaENlbnRlclBvc2l0aW9uLnkpICogKDEgLSByYXRpb0RpZmYpICsgeSxcbiAgICAgICAgICAgIHJhdGlvOiBuZXdSYXRpbyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGFic3RyYWN0IHJlY3RhbmdsZSBjb250YWluaW5nIHRoZSBncmFwaCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHZpZXcncyByZWN0YW5nbGUuXG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLnZpZXdSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IHJlZHVjZSByZWxhdGl2ZSBtYXJnaW4/XG4gICAgICAgIHZhciBtYXJnaW5YID0gKDAgKiB0aGlzLndpZHRoKSAvIDgsIG1hcmdpblkgPSAoMCAqIHRoaXMuaGVpZ2h0KSAvIDg7XG4gICAgICAgIHZhciBwMSA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHsgeDogMCAtIG1hcmdpblgsIHk6IDAgLSBtYXJnaW5ZIH0pLCBwMiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHsgeDogdGhpcy53aWR0aCArIG1hcmdpblgsIHk6IDAgLSBtYXJnaW5ZIH0pLCBoID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoeyB4OiAwLCB5OiB0aGlzLmhlaWdodCArIG1hcmdpblkgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogcDEueCxcbiAgICAgICAgICAgIHkxOiBwMS55LFxuICAgICAgICAgICAgeDI6IHAyLngsXG4gICAgICAgICAgICB5MjogcDIueSxcbiAgICAgICAgICAgIGhlaWdodDogcDIueSAtIGgueSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWVkIGdyYXBoIHN5c3RlbSB0byB0aGUgdmlld3BvcnQgc3lzdGVtLiBJdCBhbGxvd3NcbiAgICAgKiBvdmVycmlkaW5nIGFueXRoaW5nIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCwgb3IgZXZlbiB0aGUgbWF0cml4IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgaWYgb3ZlcnJpZGluZyBkaW1lbnNpb25zLCBwYWRkaW5nIG9yIGNhbWVyYVN0YXRlLCBhcyB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG1hdHJpeCBpcyBub3QgdGhlIGxpZ2h0ZXN0XG4gICAgICogb2YgY29tcHV0YXRpb25zLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5mcmFtZWRHcmFwaFRvVmlld3BvcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIG92ZXJyaWRlKSB7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdm9pZCAwKSB7IG92ZXJyaWRlID0ge307IH1cbiAgICAgICAgdmFyIHJlY29tcHV0ZU1hdHJpeCA9ICEhb3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgISFvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgISFvdmVycmlkZS5ncmFwaERpbWVuc2lvbnM7XG4gICAgICAgIHZhciBtYXRyaXggPSBvdmVycmlkZS5tYXRyaXhcbiAgICAgICAgICAgID8gb3ZlcnJpZGUubWF0cml4XG4gICAgICAgICAgICA6IHJlY29tcHV0ZU1hdHJpeFxuICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEubWF0cml4RnJvbUNhbWVyYSkob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFNldHRpbmcoXCJzdGFnZVBhZGRpbmdcIikgfHwgMClcbiAgICAgICAgICAgICAgICA6IHRoaXMubWF0cml4O1xuICAgICAgICB2YXIgdmlld3BvcnRQb3MgPSAoMCwgbWF0cmljZXNfMS5tdWx0aXBseVZlYzIpKG1hdHJpeCwgY29vcmRpbmF0ZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKCgxICsgdmlld3BvcnRQb3MueCkgKiB0aGlzLndpZHRoKSAvIDIsXG4gICAgICAgICAgICB5OiAoKDEgLSB2aWV3cG9ydFBvcy55KSAqIHRoaXMuaGVpZ2h0KSAvIDIsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIHZpZXdwb3J0IHN5c3RlbSB0byB0aGUgZnJhbWVkIGdyYXBoIHN5c3RlbS4gSXQgYWxsb3dzXG4gICAgICogb3ZlcnJpZGluZyBhbnl0aGluZyB0aGF0IGlzIHVzZWQgdG8gZ2V0IHRoZSB0cmFuc2xhdGlvbiBtYXRyaXgsIG9yIGV2ZW4gdGhlIG1hdHJpeCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBCZSBjYXJlZnVsIGlmIG92ZXJyaWRpbmcgZGltZW5zaW9ucywgcGFkZGluZyBvciBjYW1lcmFTdGF0ZSwgYXMgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBtYXRyaXggaXMgbm90IHRoZSBsaWdodGVzdFxuICAgICAqIG9mIGNvbXB1dGF0aW9ucy5cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUudmlld3BvcnRUb0ZyYW1lZEdyYXBoID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBvdmVycmlkZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHZvaWQgMCkgeyBvdmVycmlkZSA9IHt9OyB9XG4gICAgICAgIHZhciByZWNvbXB1dGVNYXRyaXggPSAhIW92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8ICEhb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8ICFvdmVycmlkZS5ncmFwaERpbWVuc2lvbnM7XG4gICAgICAgIHZhciBpbnZNYXRyaXggPSBvdmVycmlkZS5tYXRyaXhcbiAgICAgICAgICAgID8gb3ZlcnJpZGUubWF0cml4XG4gICAgICAgICAgICA6IHJlY29tcHV0ZU1hdHJpeFxuICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEubWF0cml4RnJvbUNhbWVyYSkob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFNldHRpbmcoXCJzdGFnZVBhZGRpbmdcIikgfHwgMCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuaW52TWF0cml4O1xuICAgICAgICB2YXIgcmVzID0gKDAsIG1hdHJpY2VzXzEubXVsdGlwbHlWZWMyKShpbnZNYXRyaXgsIHtcbiAgICAgICAgICAgIHg6IChjb29yZGluYXRlcy54IC8gdGhpcy53aWR0aCkgKiAyIC0gMSxcbiAgICAgICAgICAgIHk6IDEgLSAoY29vcmRpbmF0ZXMueSAvIHRoaXMuaGVpZ2h0KSAqIDIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNOYU4ocmVzLngpKVxuICAgICAgICAgICAgcmVzLnggPSAwO1xuICAgICAgICBpZiAoaXNOYU4ocmVzLnkpKVxuICAgICAgICAgICAgcmVzLnkgPSAwO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdHJhbnNsYXRlIGEgcG9pbnQncyBjb29yZGluYXRlcyBmcm9tIHRoZSB2aWV3cG9ydCBzeXN0ZW0gKHBpeGVsIGRpc3RhbmNlIGZyb20gdGhlIHRvcC1sZWZ0IG9mIHRoZVxuICAgICAqIHN0YWdlKSB0byB0aGUgZ3JhcGggc3lzdGVtICh0aGUgcmVmZXJlbmNlIHN5c3RlbSBvZiBkYXRhIGFzIHRoZXkgYXJlIGluIHRoZSBnaXZlbiBncmFwaCBpbnN0YW5jZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIGNhbWVyYSB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHRyYW5zbGF0ZSBjb29yZGluYXRlc1xuICAgICAqIGJhc2VkIG9uIGEgZGlmZmVyZW50IHZpZXcgdGhhbiB0aGUgb25lIGJlaW5nIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQgb24gc2NyZWVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlc30gICAgICAgICAgICAgICAgICB2aWV3cG9ydFBvaW50XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlQ29udmVyc2lvbk92ZXJyaWRlfSBvdmVycmlkZVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS52aWV3cG9ydFRvR3JhcGggPSBmdW5jdGlvbiAodmlld3BvcnRQb2ludCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGUgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24uaW52ZXJzZSh0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh2aWV3cG9ydFBvaW50LCBvdmVycmlkZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdHJhbnNsYXRlIGEgcG9pbnQncyBjb29yZGluYXRlcyBmcm9tIHRoZSBncmFwaCBzeXN0ZW0gKHRoZSByZWZlcmVuY2Ugc3lzdGVtIG9mIGRhdGEgYXMgdGhleSBhcmUgaW5cbiAgICAgKiB0aGUgZ2l2ZW4gZ3JhcGggaW5zdGFuY2UpIHRvIHRoZSB2aWV3cG9ydCBzeXN0ZW0gKHBpeGVsIGRpc3RhbmNlIGZyb20gdGhlIHRvcC1sZWZ0IG9mIHRoZSBzdGFnZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIGNhbWVyYSB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHRyYW5zbGF0ZSBjb29yZGluYXRlc1xuICAgICAqIGJhc2VkIG9uIGEgZGlmZmVyZW50IHZpZXcgdGhhbiB0aGUgb25lIGJlaW5nIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQgb24gc2NyZWVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlc30gICAgICAgICAgICAgICAgICBncmFwaFBvaW50XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlQ29udmVyc2lvbk92ZXJyaWRlfSBvdmVycmlkZVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5ncmFwaFRvVmlld3BvcnQgPSBmdW5jdGlvbiAoZ3JhcGhQb2ludCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGUgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQodGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24oZ3JhcGhQb2ludCksIG92ZXJyaWRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7eyB4OiBFeHRlbnQsIHk6IEV4dGVudCB9fVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ3JhcGhFeHRlbnQpKHRoaXMuZ3JhcGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBjdXN0b20gYm91bmRpbmcgYm94LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt7IHg6IEV4dGVudCwgeTogRXh0ZW50IH0gfCBudWxsfVxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5nZXRDdXN0b21CQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21CQm94O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94IHdpdGggYSBjdXN0b20gb25lLiBHaXZlIGBudWxsYCBhcyB0aGUgYXJndW1lbnQgdG8gc3RvcCBvdmVycmlkaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLnNldEN1c3RvbUJCb3ggPSBmdW5jdGlvbiAoY3VzdG9tQkJveCkge1xuICAgICAgICB0aGlzLmN1c3RvbUJCb3ggPSBjdXN0b21CQm94O1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzaHV0IHRoZSBjb250YWluZXIgJiByZWxlYXNlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBTaWdtYS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgLy8gRW1pdHRpbmcgXCJraWxsXCIgZXZlbnRzIHNvIHRoYXQgcGx1Z2lucyBhbmQgc3VjaCBjYW4gY2xlYW51cFxuICAgICAgICB0aGlzLmVtaXQoXCJraWxsXCIpO1xuICAgICAgICAvLyBSZWxlYXNpbmcgZXZlbnRzXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vIFJlbGVhc2luZyBjYW1lcmEgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5jYW1lcmEucmVtb3ZlTGlzdGVuZXIoXCJ1cGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSk7XG4gICAgICAgIC8vIFJlbGVhc2luZyBET00gZXZlbnRzICYgY2FwdG9yc1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUpO1xuICAgICAgICB0aGlzLm1vdXNlQ2FwdG9yLmtpbGwoKTtcbiAgICAgICAgdGhpcy50b3VjaENhcHRvci5raWxsKCk7XG4gICAgICAgIC8vIFJlbGVhc2luZyBncmFwaCBoYW5kbGVyc1xuICAgICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnNvZnRHcmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5ncmFwaFVwZGF0ZSk7XG4gICAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmdyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuc29mdEdyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmdyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlc0NsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlKTtcbiAgICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJjbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUpO1xuICAgICAgICAvLyBSZWxlYXNpbmcgY2FjaGUgJiBzdGF0ZVxuICAgICAgICB0aGlzLnF1YWR0cmVlID0gbmV3IHF1YWR0cmVlXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlID0ge307XG4gICAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzID0gW107XG4gICAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzID0gW107XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5jbGVhcigpO1xuICAgICAgICAvLyBDbGVhcmluZyBmcmFtZXNcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmNhbmNlbEZyYW1lKSh0aGlzLnJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuY2FuY2VsRnJhbWUpKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXN0cm95aW5nIGNhbnZhc2VzXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKVxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjYWxlIHRoZSBnaXZlbiBzaXplIGFjY29yZGluZyB0byB0aGUgY2FtZXJhJ3MgcmF0aW8sIGkuZS5cbiAgICAgKiB6b29taW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgdG8gc2NhbGUgKG5vZGUgc2l6ZSwgZWRnZSB0aGlja25lc3MgZXRjLikuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgIC0gVGhlIHNjYWxlZCBzaXplLlxuICAgICAqL1xuICAgIFNpZ21hLnByb3RvdHlwZS5zY2FsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXR1cm4gc2l6ZSAvIHRoaXMuY2FtZXJhU2l6ZVJhdGlvO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgdXNlZCBjYW52YXNlcy5cbiAgICAgKiBBdCB0aGUgbW9tZW50LCB0aGUgaW5zdGFudGlhdGVkIGNhbnZhc2VzIGFyZSB0aGUgZm9sbG93aW5nLCBhbmQgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIG9yZGVyIGluIHRoZSBET006XG4gICAgICogLSBgZWRnZXNgXG4gICAgICogLSBgbm9kZXNgXG4gICAgICogLSBgZWRnZUxhYmVsc2BcbiAgICAgKiAtIGBsYWJlbHNgXG4gICAgICogLSBgaG92ZXJzYFxuICAgICAqIC0gYGhvdmVyTm9kZXNgXG4gICAgICogLSBgbW91c2VgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQbGFpbk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD59IC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FudmFzZXMuXG4gICAgICovXG4gICAgU2lnbWEucHJvdG90eXBlLmdldENhbnZhc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIHRoaXMuZWxlbWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ21hO1xufSh0eXBlc18xLlR5cGVkRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWdtYTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHlwZWRFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIFR5cGVzXG4gKiA9PT09PT09PT09PT09PT1cbiAqXG4gKiBWYXJpb3VzIHR5cGUgZGVjbGFyYXRpb25zIHVzZWQgdGhyb3VnaG91dCB0aGUgbGlicmFyeS5cbiAqIEBtb2R1bGVcbiAqL1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBUeXBlZEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHlwZWRFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHlwZWRFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJhd0VtaXR0ZXIgPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHlwZWRFdmVudEVtaXR0ZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5UeXBlZEV2ZW50RW1pdHRlciA9IFR5cGVkRXZlbnRFbWl0dGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFuaW1hdGVOb2RlcyA9IGV4cG9ydHMuQU5JTUFURV9ERUZBVUxUUyA9IHZvaWQgMDtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG52YXIgZWFzaW5nc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Vhc2luZ3NcIikpO1xuZXhwb3J0cy5BTklNQVRFX0RFRkFVTFRTID0ge1xuICAgIGVhc2luZzogXCJxdWFkcmF0aWNJbk91dFwiLFxuICAgIGR1cmF0aW9uOiAxNTAsXG59O1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGFuaW1hdGUgdGhlIG5vZGVzLlxuICovXG5mdW5jdGlvbiBhbmltYXRlTm9kZXMoZ3JhcGgsIHRhcmdldHMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBleHBvcnRzLkFOSU1BVEVfREVGQVVMVFMsIG9wdHMpO1xuICAgIHZhciBlYXNpbmcgPSB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuZWFzaW5nIDogZWFzaW5nc18xLmRlZmF1bHRbb3B0aW9ucy5lYXNpbmddO1xuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdmFyIHN0YXJ0UG9zaXRpb25zID0ge307XG4gICAgZm9yICh2YXIgbm9kZSBpbiB0YXJnZXRzKSB7XG4gICAgICAgIHZhciBhdHRycyA9IHRhcmdldHNbbm9kZV07XG4gICAgICAgIHN0YXJ0UG9zaXRpb25zW25vZGVdID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gYXR0cnMpXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uc1tub2RlXVtrXSA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGUobm9kZSwgayk7XG4gICAgfVxuICAgIHZhciBmcmFtZSA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHAgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIG9wdGlvbnMuZHVyYXRpb247XG4gICAgICAgIGlmIChwID49IDEpIHtcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBpcyBkb25lXG4gICAgICAgICAgICBmb3IgKHZhciBub2RlIGluIHRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB0YXJnZXRzW25vZGVdO1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSBnaXZlbiB2YWx1ZXMgdG8gYXZvaWQgcHJlY2lzaW9uIGlzc3VlcyBhbmQgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhdHRycylcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBrLCBhdHRyc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwID0gZWFzaW5nKHApO1xuICAgICAgICBmb3IgKHZhciBub2RlIGluIHRhcmdldHMpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHRhcmdldHNbbm9kZV07XG4gICAgICAgICAgICB2YXIgcyA9IHN0YXJ0UG9zaXRpb25zW25vZGVdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhdHRycylcbiAgICAgICAgICAgICAgICBncmFwaC5zZXROb2RlQXR0cmlidXRlKG5vZGUsIGssIGF0dHJzW2tdICogcCArIHNba10gKiAoMSAtIHApKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9ICgwLCBpbmRleF8xLnJlcXVlc3RGcmFtZSkoc3RlcCk7XG4gICAgfTtcbiAgICBzdGVwKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZyYW1lKVxuICAgICAgICAgICAgKDAsIGluZGV4XzEuY2FuY2VsRnJhbWUpKGZyYW1lKTtcbiAgICB9O1xufVxuZXhwb3J0cy5hbmltYXRlTm9kZXMgPSBhbmltYXRlTm9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSFRNTF9DT0xPUlMgPSB2b2lkIDA7XG5leHBvcnRzLkhUTUxfQ09MT1JTID0ge1xuICAgIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICAgIGdyYXk6IFwiIzgwODA4MFwiLFxuICAgIGdyZXk6IFwiIzgwODA4MFwiLFxuICAgIHdoaXRlOiBcIiNGRkZGRkZcIixcbiAgICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICAgIHJlZDogXCIjRkYwMDAwXCIsXG4gICAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgICBncmVlbjogXCIjMDA4MDAwXCIsXG4gICAgbGltZTogXCIjMDBGRjAwXCIsXG4gICAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICAgIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gICAgbmF2eTogXCIjMDAwMDgwXCIsXG4gICAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gICAgdGVhbDogXCIjMDA4MDgwXCIsXG4gICAgYXF1YTogXCIjMDBGRkZGXCIsXG4gICAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICAgIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICAgIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gICAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICAgIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiIzAwRkY3RlwiLFxuICAgIGN5YW46IFwiIzAwRkZGRlwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gICAgZG9kZ2VyYmx1ZTogXCIjMUU5MEZGXCIsXG4gICAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gICAgZm9yZXN0Z3JlZW46IFwiIzIyOEIyMlwiLFxuICAgIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgICBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIixcbiAgICBsaW1lZ3JlZW46IFwiIzMyQ0QzMlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICAgIHJveWFsYmx1ZTogXCIjNDE2OUUxXCIsXG4gICAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiIzQ4RDFDQ1wiLFxuICAgIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICAgIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsXG4gICAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICAgIGRpbWdyYXk6IFwiIzY5Njk2OVwiLFxuICAgIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICAgIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gICAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICAgIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICAgIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gICAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gICAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gICAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gICAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgICBkYXJrcmVkOiBcIiM4QjAwMDBcIixcbiAgICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gICAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICAgIGRhcmtzZWFncmVlbjogXCIjOEZCQzhGXCIsXG4gICAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIiM5MzcwREJcIixcbiAgICBkYXJrdmlvbGV0OiBcIiM5NDAwRDNcIixcbiAgICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICAgIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICAgIHllbGxvd2dyZWVuOiBcIiM5QUNEMzJcIixcbiAgICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICAgIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gICAgZGFya2dyZXk6IFwiI0E5QTlBOVwiLFxuICAgIGxpZ2h0Ymx1ZTogXCIjQUREOEU2XCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICAgIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIixcbiAgICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFwiI0I4ODYwQlwiLFxuICAgIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gICAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgICBkYXJra2hha2k6IFwiI0JEQjc2QlwiLFxuICAgIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gICAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgICBwZXJ1OiBcIiNDRDg1M0ZcIixcbiAgICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICAgIHRhbjogXCIjRDJCNDhDXCIsXG4gICAgbGlnaHRncmF5OiBcIiNEM0QzRDNcIixcbiAgICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICAgIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICAgIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gICAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcIiNEQjcwOTNcIixcbiAgICBjcmltc29uOiBcIiNEQzE0M0NcIixcbiAgICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICAgIHBsdW06IFwiI0REQTBERFwiLFxuICAgIGJ1cmx5d29vZDogXCIjREVCODg3XCIsXG4gICAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gICAgZGFya3NhbG1vbjogXCIjRTk5NjdBXCIsXG4gICAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgICBsaWdodGNvcmFsOiBcIiNGMDgwODBcIixcbiAgICBraGFraTogXCIjRjBFNjhDXCIsXG4gICAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgICBob25leWRldzogXCIjRjBGRkYwXCIsXG4gICAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICAgIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICAgIHdoZWF0OiBcIiNGNURFQjNcIixcbiAgICBiZWlnZTogXCIjRjVGNURDXCIsXG4gICAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gICAgbWludGNyZWFtOiBcIiNGNUZGRkFcIixcbiAgICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCIjRkFFQkQ3XCIsXG4gICAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgICBvbGRsYWNlOiBcIiNGREY1RTZcIixcbiAgICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gICAgb3JhbmdlcmVkOiBcIiNGRjQ1MDBcIixcbiAgICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICAgIGhvdHBpbms6IFwiI0ZGNjlCNFwiLFxuICAgIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gICAgb3JhbmdlOiBcIiNGRkE1MDBcIixcbiAgICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICAgIHBpbms6IFwiI0ZGQzBDQlwiLFxuICAgIGdvbGQ6IFwiI0ZGRDcwMFwiLFxuICAgIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gICAgbmF2YWpvd2hpdGU6IFwiI0ZGREVBRFwiLFxuICAgIG1vY2Nhc2luOiBcIiNGRkU0QjVcIixcbiAgICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICAgIG1pc3R5cm9zZTogXCIjRkZFNEUxXCIsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICAgIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICAgIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICAgIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcIiNGRkZBQ0RcIixcbiAgICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gICAgc25vdzogXCIjRkZGQUZBXCIsXG4gICAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICAgIGl2b3J5OiBcIiNGRkZGRjBcIixcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3ViaWNJbk91dCA9IGV4cG9ydHMuY3ViaWNPdXQgPSBleHBvcnRzLmN1YmljSW4gPSBleHBvcnRzLnF1YWRyYXRpY0luT3V0ID0gZXhwb3J0cy5xdWFkcmF0aWNPdXQgPSBleHBvcnRzLnF1YWRyYXRpY0luID0gZXhwb3J0cy5saW5lYXIgPSB2b2lkIDA7XG4vKipcbiAqIFNpZ21hLmpzIEVhc2luZ3NcbiAqID09PT09PT09PT09PT09PT09XG4gKlxuICogSGFuZHkgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zLlxuICogQG1vZHVsZVxuICovXG52YXIgbGluZWFyID0gZnVuY3Rpb24gKGspIHsgcmV0dXJuIGs7IH07XG5leHBvcnRzLmxpbmVhciA9IGxpbmVhcjtcbnZhciBxdWFkcmF0aWNJbiA9IGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICogazsgfTtcbmV4cG9ydHMucXVhZHJhdGljSW4gPSBxdWFkcmF0aWNJbjtcbnZhciBxdWFkcmF0aWNPdXQgPSBmdW5jdGlvbiAoaykgeyByZXR1cm4gayAqICgyIC0gayk7IH07XG5leHBvcnRzLnF1YWRyYXRpY091dCA9IHF1YWRyYXRpY091dDtcbnZhciBxdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbn07XG5leHBvcnRzLnF1YWRyYXRpY0luT3V0ID0gcXVhZHJhdGljSW5PdXQ7XG52YXIgY3ViaWNJbiA9IGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICogayAqIGs7IH07XG5leHBvcnRzLmN1YmljSW4gPSBjdWJpY0luO1xudmFyIGN1YmljT3V0ID0gZnVuY3Rpb24gKGspIHsgcmV0dXJuIC0tayAqIGsgKiBrICsgMTsgfTtcbmV4cG9ydHMuY3ViaWNPdXQgPSBjdWJpY091dDtcbnZhciBjdWJpY0luT3V0ID0gZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xufTtcbmV4cG9ydHMuY3ViaWNJbk91dCA9IGN1YmljSW5PdXQ7XG52YXIgZWFzaW5ncyA9IHtcbiAgICBsaW5lYXI6IGV4cG9ydHMubGluZWFyLFxuICAgIHF1YWRyYXRpY0luOiBleHBvcnRzLnF1YWRyYXRpY0luLFxuICAgIHF1YWRyYXRpY091dDogZXhwb3J0cy5xdWFkcmF0aWNPdXQsXG4gICAgcXVhZHJhdGljSW5PdXQ6IGV4cG9ydHMucXVhZHJhdGljSW5PdXQsXG4gICAgY3ViaWNJbjogZXhwb3J0cy5jdWJpY0luLFxuICAgIGN1YmljT3V0OiBleHBvcnRzLmN1YmljT3V0LFxuICAgIGN1YmljSW5PdXQ6IGV4cG9ydHMuY3ViaWNJbk91dCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBlYXNpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvRWRnZUNvbGxpZGVXaXRoUG9pbnQgPSBleHBvcnRzLmlzUGl4ZWxDb2xvcmVkID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGhlbHBlciByZXR1cm5zIHRydWUgaXMgdGhlIHBpeGVsIGF0ICh4LHkpIGluIHRoZSBnaXZlbiBXZWJHTCBjb250ZXh0IGlzXG4gKiBjb2xvcmVkLCBhbmQgZmFsc2UgZWxzZS5cbiAqL1xuZnVuY3Rpb24gaXNQaXhlbENvbG9yZWQoZ2wsIHgsIHkpIHtcbiAgICB2YXIgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZ2wucmVhZFBpeGVscyh4LCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0geSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICByZXR1cm4gcGl4ZWxzWzNdID4gMDtcbn1cbmV4cG9ydHMuaXNQaXhlbENvbG9yZWQgPSBpc1BpeGVsQ29sb3JlZDtcbi8qKlxuICogVGhpcyBoZWxwZXIgY2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgcG9pbnQgKHgsIHkpIGNvbGxpZGVzIHdpdGggYW5cbiAqIGVkZ2UsIGNvbm5lY3RpbmcgYSBzb3VyY2UgKHhTLCB5UykgdG8gYSB0YXJnZXQgKHhULCB5VCkgd2l0aCBhIHRoaWNrbmVzcyBpblxuICogcGl4ZWxzLlxuICovXG5mdW5jdGlvbiBkb0VkZ2VDb2xsaWRlV2l0aFBvaW50KHgsIHksIHhTLCB5UywgeFQsIHlULCB0aGlja25lc3MpIHtcbiAgICAvLyBDaGVjayBmaXJzdCBpZiBwb2ludCBpcyBvdXQgb2YgdGhlIHJlY3RhbmdsZSB3aGljaCBvcHBvc2l0ZSBjb3JuZXJzIGFyZSB0aGVcbiAgICAvLyBzb3VyY2UgYW5kIHRoZSB0YXJnZXQsIHJlY3RhbmdsZSB3ZSBleHBhbmQgYnkgYHRoaWNrbmVzc2AgaW4gZXZlcnlcbiAgICAvLyBkaXJlY3Rpb25zOlxuICAgIGlmICh4IDwgeFMgLSB0aGlja25lc3MgJiYgeCA8IHhUIC0gdGhpY2tuZXNzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHkgPCB5UyAtIHRoaWNrbmVzcyAmJiB5IDwgeVQgLSB0aGlja25lc3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoeCA+IHhTICsgdGhpY2tuZXNzICYmIHggPiB4VCArIHRoaWNrbmVzcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh5ID4geVMgKyB0aGlja25lc3MgJiYgeSA+IHlUICsgdGhpY2tuZXNzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgYWN0dWFsIGNvbGxpc2lvbiBub3c6IFNpbmNlIHdlIG5vdyB0aGUgcG9pbnQgaXMgaW4gdGhpcyBiaWcgcmVjdGFuZ2xlXG4gICAgLy8gd2UgXCJqdXN0XCIgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCBhbmQgdGhlIGxpbmVcbiAgICAvLyBjb25uZWN0aW5nIHRoZSBzb3VyY2UgYW5kIHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIGB0aGlja25lc3NgOlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicygoeFQgLSB4UykgKiAoeVMgLSB5KSAtICh4UyAtIHgpICogKHlUIC0geVMpKSAvIE1hdGguc3FydChNYXRoLnBvdyh4VCAtIHhTLCAyKSArIE1hdGgucG93KHlUIC0geVMsIDIpKTtcbiAgICByZXR1cm4gZGlzdGFuY2UgPCB0aGlja25lc3MgLyAyO1xufVxuZXhwb3J0cy5kb0VkZ2VDb2xsaWRlV2l0aFBvaW50ID0gZG9FZGdlQ29sbGlkZVdpdGhQb2ludDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUdyYXBoID0gZXhwb3J0cy5jYW5Vc2UzMkJpdHNJbmRpY2VzID0gZXhwb3J0cy5leHRyYWN0UGl4ZWwgPSBleHBvcnRzLmdldE1hdHJpeEltcGFjdCA9IGV4cG9ydHMubWF0cml4RnJvbUNhbWVyYSA9IGV4cG9ydHMuZ2V0Q29ycmVjdGlvblJhdGlvID0gZXhwb3J0cy5mbG9hdENvbG9yID0gZXhwb3J0cy5mbG9hdEFycmF5Q29sb3IgPSBleHBvcnRzLnBhcnNlQ29sb3IgPSBleHBvcnRzLnpJbmRleE9yZGVyaW5nID0gZXhwb3J0cy5jcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24gPSBleHBvcnRzLmdyYXBoRXh0ZW50ID0gZXhwb3J0cy5nZXRQaXhlbFJhdGlvID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZXhwb3J0cy5jYW5jZWxGcmFtZSA9IGV4cG9ydHMucmVxdWVzdEZyYW1lID0gZXhwb3J0cy5hc3NpZ25EZWVwID0gZXhwb3J0cy5hc3NpZ24gPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSB2b2lkIDA7XG52YXIgaXNfZ3JhcGhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaFwiKSk7XG52YXIgbWF0cmljZXNfMSA9IHJlcXVpcmUoXCIuL21hdHJpY2VzXCIpO1xudmFyIGRhdGFfMSA9IHJlcXVpcmUoXCIuL2RhdGFcIik7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gICB2YWx1ZSAtIFRhcmdldCB2YWx1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbi8qKlxuICogSGVscGVyIHRvIHVzZSBPYmplY3QuYXNzaWduIHdpdGggbW9yZSB0aGFuIHR3byBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0ICAgICAgIC0gRmlyc3Qgb2JqZWN0LlxuICogQHBhcmFtICB7b2JqZWN0fSBbLi4ub2JqZWN0c10gLSBPYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbyA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmICghbylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgbyk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLmFzc2lnbiA9IGFzc2lnbjtcbi8qKlxuICogVmVyeSBzaW1wbGUgcmVjdXJzaXZlIE9iamVjdC5hc3NpZ24tbGlrZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldCAgICAgICAtIEZpcnN0IG9iamVjdC5cbiAqIEBwYXJhbSAge29iamVjdH0gWy4uLm9iamVjdHNdIC0gT2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduRGVlcCh0YXJnZXQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBvID0gb2JqZWN0c1tpXTtcbiAgICAgICAgaWYgKCFvKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob1trXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba10gPSBhc3NpZ25EZWVwKHRhcmdldFtrXSwgb1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba10gPSBvW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLmFzc2lnbkRlZXAgPSBhc3NpZ25EZWVwO1xuLyoqXG4gKiBKdXN0IHNvbWUgZGlydHkgdHJpY2sgdG8gbWFrZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGNhbmNlbEFuaW1hdGlvbkZyYW1lIFwid29ya1wiIGluIE5vZGUuanMsIGZvciB1bml0IHRlc3RzOlxuICovXG5leHBvcnRzLnJlcXVlc3RGcmFtZSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTsgfVxuICAgIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTsgfTtcbmV4cG9ydHMuY2FuY2VsRnJhbWUgPSB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIChyZXF1ZXN0SUQpIHsgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJRCk7IH1cbiAgICA6IGZ1bmN0aW9uIChyZXF1ZXN0SUQpIHsgcmV0dXJuIGNsZWFyVGltZW91dChyZXF1ZXN0SUQpOyB9O1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBET00gZWxlbWVudHMgZWFzaWx5LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdGFnICAgICAgICAtIFRhZyBuYW1lIG9mIHRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge29iamVjdH0gc3R5bGUgICAgICAtIFN0eWxlcyBtYXAuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIG1hcC5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgc3R5bGUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBzdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrXSA9IHN0eWxlW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoaywgYXR0cmlidXRlc1trXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGJyb3dzZXIncyBwaXhlbCByYXRpby5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHJldHVybiAxO1xufVxuZXhwb3J0cy5nZXRQaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbztcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBncmFwaCdzIG5vZGUgZXh0ZW50IGluIHggJiB5LlxuICpcbiAqIEBwYXJhbSAge0dyYXBofVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBncmFwaEV4dGVudChncmFwaCkge1xuICAgIGlmICghZ3JhcGgub3JkZXIpXG4gICAgICAgIHJldHVybiB7IHg6IFswLCAxXSwgeTogWzAsIDFdIH07XG4gICAgdmFyIHhNaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgeE1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgeU1pbiA9IEluZmluaXR5O1xuICAgIHZhciB5TWF4ID0gLUluZmluaXR5O1xuICAgIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChfLCBhdHRyKSB7XG4gICAgICAgIHZhciB4ID0gYXR0ci54LCB5ID0gYXR0ci55O1xuICAgICAgICBpZiAoeCA8IHhNaW4pXG4gICAgICAgICAgICB4TWluID0geDtcbiAgICAgICAgaWYgKHggPiB4TWF4KVxuICAgICAgICAgICAgeE1heCA9IHg7XG4gICAgICAgIGlmICh5IDwgeU1pbilcbiAgICAgICAgICAgIHlNaW4gPSB5O1xuICAgICAgICBpZiAoeSA+IHlNYXgpXG4gICAgICAgICAgICB5TWF4ID0geTtcbiAgICB9KTtcbiAgICByZXR1cm4geyB4OiBbeE1pbiwgeE1heF0sIHk6IFt5TWluLCB5TWF4XSB9O1xufVxuZXhwb3J0cy5ncmFwaEV4dGVudCA9IGdyYXBoRXh0ZW50O1xuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKGV4dGVudCkge1xuICAgIHZhciBfYSA9IF9fcmVhZChleHRlbnQueCwgMiksIG1pblggPSBfYVswXSwgbWF4WCA9IF9hWzFdLCBfYiA9IF9fcmVhZChleHRlbnQueSwgMiksIG1pblkgPSBfYlswXSwgbWF4WSA9IF9iWzFdO1xuICAgIHZhciByYXRpbyA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSksIGRYID0gKG1heFggKyBtaW5YKSAvIDIsIGRZID0gKG1heFkgKyBtaW5ZKSAvIDI7XG4gICAgaWYgKHJhdGlvID09PSAwIHx8IE1hdGguYWJzKHJhdGlvKSA9PT0gSW5maW5pdHkgfHwgaXNOYU4ocmF0aW8pKVxuICAgICAgICByYXRpbyA9IDE7XG4gICAgaWYgKGlzTmFOKGRYKSlcbiAgICAgICAgZFggPSAwO1xuICAgIGlmIChpc05hTihkWSkpXG4gICAgICAgIGRZID0gMDtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogMC41ICsgKGRhdGEueCAtIGRYKSAvIHJhdGlvLFxuICAgICAgICAgICAgeTogMC41ICsgKGRhdGEueSAtIGRZKSAvIHJhdGlvLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8gYXBwbHkgdGhpcyBpbiBiYXRjaCBvdmVyIGFycmF5IG9mIGluZGljZXNcbiAgICBmbi5hcHBseVRvID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZGF0YS54ID0gMC41ICsgKGRhdGEueCAtIGRYKSAvIHJhdGlvO1xuICAgICAgICBkYXRhLnkgPSAwLjUgKyAoZGF0YS55IC0gZFkpIC8gcmF0aW87XG4gICAgfTtcbiAgICBmbi5pbnZlcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGRYICsgcmF0aW8gKiAoZGF0YS54IC0gMC41KSxcbiAgICAgICAgICAgIHk6IGRZICsgcmF0aW8gKiAoZGF0YS55IC0gMC41KSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZuLnJhdGlvID0gcmF0aW87XG4gICAgcmV0dXJuIGZuO1xufVxuZXhwb3J0cy5jcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb247XG4vKipcbiAqIEZ1bmN0aW9uIG9yZGVyaW5nIHRoZSBnaXZlbiBlbGVtZW50cyBpbiByZXZlcnNlIHotb3JkZXIgc28gdGhleSBkcmF3blxuICogdGhlIGNvcnJlY3Qgd2F5LlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gICBleHRlbnQgICAtIFttaW4sIG1heF0geiB2YWx1ZXMuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZ2V0dGVyICAgLSBaIGF0dHJpYnV0ZSBnZXR0ZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHthcnJheX0gICAgZWxlbWVudHMgLSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHpJbmRleE9yZGVyaW5nKGV4dGVudCwgZ2V0dGVyLCBlbGVtZW50cykge1xuICAgIC8vIElmIGsgaXMgPiBuLCB3ZSdsbCB1c2UgYSBzdGFuZGFyZCBzb3J0XG4gICAgcmV0dXJuIGVsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHpBID0gZ2V0dGVyKGEpIHx8IDAsIHpCID0gZ2V0dGVyKGIpIHx8IDA7XG4gICAgICAgIGlmICh6QSA8IHpCKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoekEgPiB6QilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICAvLyBUT0RPOiBjb3VudGluZyBzb3J0IG9wdGltaXphdGlvblxufVxuZXhwb3J0cy56SW5kZXhPcmRlcmluZyA9IHpJbmRleE9yZGVyaW5nO1xuLyoqXG4gKiBXZWJHTCB1dGlsc1xuICogPT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiByZXR1cm5pbmcgYSBmbG9hdC1lbmNvZGVkIGNvbG9yIGZyb20gdmFyaW91cyBzdHJpbmdcbiAqIGZvcm1hdHMgZGVzY3JpYmluZyBjb2xvcnMuXG4gKi9cbnZhciBJTlQ4ID0gbmV3IEludDhBcnJheSg0KTtcbnZhciBJTlQzMiA9IG5ldyBJbnQzMkFycmF5KElOVDguYnVmZmVyLCAwLCAxKTtcbnZhciBGTE9BVDMyID0gbmV3IEZsb2F0MzJBcnJheShJTlQ4LmJ1ZmZlciwgMCwgMSk7XG52YXIgUkdCQV9URVNUX1JFR0VYID0gL15cXHMqcmdiYT9cXHMqXFwoLztcbnZhciBSR0JBX0VYVFJBQ1RfUkVHRVggPSAvXlxccypyZ2JhP1xccypcXChcXHMqKFswLTldKilcXHMqLFxccyooWzAtOV0qKVxccyosXFxzKihbMC05XSopKD86XFxzKixcXHMqKC4qKT8pP1xcKVxccyokLztcbmZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsKSB7XG4gICAgdmFyIHIgPSAwOyAvLyBieXRlXG4gICAgdmFyIGcgPSAwOyAvLyBieXRlXG4gICAgdmFyIGIgPSAwOyAvLyBieXRlXG4gICAgdmFyIGEgPSAxOyAvLyBmbG9hdFxuICAgIC8vIEhhbmRsaW5nIGhleGFkZWNpbWFsIG5vdGF0aW9uXG4gICAgaWYgKHZhbFswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgzKSArIHZhbC5jaGFyQXQoMyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMykgKyB2YWwuY2hhckF0KDQpLCAxNik7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg1KSArIHZhbC5jaGFyQXQoNiksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgYSA9IHBhcnNlSW50KHZhbC5jaGFyQXQoNykgKyB2YWwuY2hhckF0KDgpLCAxNikgLyAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxpbmcgcmdiIG5vdGF0aW9uXG4gICAgZWxzZSBpZiAoUkdCQV9URVNUX1JFR0VYLnRlc3QodmFsKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goUkdCQV9FWFRSQUNUX1JFR0VYKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByID0gK21hdGNoWzFdO1xuICAgICAgICAgICAgZyA9ICttYXRjaFsyXTtcbiAgICAgICAgICAgIGIgPSArbWF0Y2hbM107XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pXG4gICAgICAgICAgICAgICAgYSA9ICttYXRjaFs0XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByOiByLCBnOiBnLCBiOiBiLCBhOiBhIH07XG59XG5leHBvcnRzLnBhcnNlQ29sb3IgPSBwYXJzZUNvbG9yO1xudmFyIEZMT0FUX0NPTE9SX0NBQ0hFID0ge307XG5mb3IgKHZhciBodG1sQ29sb3IgaW4gZGF0YV8xLkhUTUxfQ09MT1JTKSB7XG4gICAgRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXSA9IGZsb2F0Q29sb3IoZGF0YV8xLkhUTUxfQ09MT1JTW2h0bWxDb2xvcl0pO1xuICAgIC8vIFJlcGxpY2F0aW5nIGNhY2hlIGZvciBoZXggdmFsdWVzIGZvciBmcmVlXG4gICAgRkxPQVRfQ09MT1JfQ0FDSEVbZGF0YV8xLkhUTUxfQ09MT1JTW2h0bWxDb2xvcl1dID0gRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXTtcbn1cbmZ1bmN0aW9uIGZsb2F0QXJyYXlDb2xvcih2YWwpIHtcbiAgICB2YWwgPSBkYXRhXzEuSFRNTF9DT0xPUlNbdmFsXSB8fCB2YWw7XG4gICAgLy8gTk9URTogdGhpcyB2YXJpYW50IGlzIG5vdCBjYWNoZWQgYmVjYXVzZSBpdCBpcyBtb3N0bHkgdXNlZCBmb3IgdW5pZm9ybXNcbiAgICB2YXIgX2EgPSBwYXJzZUNvbG9yKHZhbCksIHIgPSBfYS5yLCBnID0gX2EuZywgYiA9IF9hLmIsIGEgPSBfYS5hO1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhXSk7XG59XG5leHBvcnRzLmZsb2F0QXJyYXlDb2xvciA9IGZsb2F0QXJyYXlDb2xvcjtcbmZ1bmN0aW9uIGZsb2F0Q29sb3IodmFsKSB7XG4gICAgLy8gSWYgdGhlIGNvbG9yIGlzIGFscmVhZHkgY29tcHV0ZWQsIHdlIHlpZWxkIGl0XG4gICAgaWYgKHR5cGVvZiBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gRkxPQVRfQ09MT1JfQ0FDSEVbdmFsXTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VDb2xvcih2YWwpO1xuICAgIHZhciByID0gcGFyc2VkLnIsIGcgPSBwYXJzZWQuZywgYiA9IHBhcnNlZC5iO1xuICAgIHZhciBhID0gcGFyc2VkLmE7XG4gICAgYSA9IChhICogMjU1KSB8IDA7XG4gICAgSU5UMzJbMF0gPSAoKGEgPDwgMjQpIHwgKGIgPDwgMTYpIHwgKGcgPDwgOCkgfCByKSAmIDB4ZmVmZmZmZmY7XG4gICAgdmFyIGNvbG9yID0gRkxPQVQzMlswXTtcbiAgICBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdID0gY29sb3I7XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuZXhwb3J0cy5mbG9hdENvbG9yID0gZmxvYXRDb2xvcjtcbi8qKlxuICogSW4gc2lnbWEsIHRoZSBncmFwaCBpcyBub3JtYWxpemVkIGludG8gYSBbMCwgMV0sIFswLCAxXSBzcXVhcmUsIGJlZm9yZSBiZWluZyBnaXZlbiB0byB0aGUgdmFyaW91cyByZW5kZXJlcnMuIFRoaXNcbiAqIGhlbHBzIGRlYWxpbmcgd2l0aCBxdWFkdHJlZSBpbiBwYXJ0aWN1bGFyLlxuICogQnV0IGF0IHNvbWUgcG9pbnQsIHdlIG5lZWQgdG8gcmVzY2FsZSBpdCBzbyB0aGF0IGl0IHRha2VzIHRoZSBiZXN0IHBsYWNlIGluIHRoZSBzY3JlZW4sIGllLiB3ZSBhbHdheXMgd2FudCB0byBzZWUgdHdvXG4gKiBub2RlcyBcInRvdWNoaW5nXCIgb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGdyYXBoLCB3aXRoIHRoZSBjYW1lcmEgYmVpbmcgYXQgaXRzIGRlZmF1bHQgc3RhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoaXMgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3Rpb25SYXRpbyh2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucykge1xuICAgIHZhciB2aWV3cG9ydFJhdGlvID0gdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAvIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aDtcbiAgICB2YXIgZ3JhcGhSYXRpbyA9IGdyYXBoRGltZW5zaW9ucy5oZWlnaHQgLyBncmFwaERpbWVuc2lvbnMud2lkdGg7XG4gICAgLy8gSWYgdGhlIHN0YWdlIGFuZCB0aGUgZ3JhcGhzIGFyZSBpbiBkaWZmZXJlbnQgZGlyZWN0aW9ucyAoc3VjaCBhcyB0aGUgZ3JhcGggYmVpbmcgd2lkZXIgdGhhdCB0YWxsIHdoaWxlIHRoZSBzdGFnZVxuICAgIC8vIGlzIHRhbGxlciB0aGFuIHdpZGUpLCB3ZSBjYW4gc3RvcCBoZXJlIHRvIGhhdmUgaW5kZWVkIG5vZGVzIHRvdWNoaW5nIG9wcG9zaXRlIHNpZGVzOlxuICAgIGlmICgodmlld3BvcnRSYXRpbyA8IDEgJiYgZ3JhcGhSYXRpbyA+IDEpIHx8ICh2aWV3cG9ydFJhdGlvID4gMSAmJiBncmFwaFJhdGlvIDwgMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIEVsc2UsIHdlIG5lZWQgdG8gZml0IHRoZSBncmFwaCBpbnNpZGUgdGhlIHN0YWdlOlxuICAgIC8vIDEuIElmIHRoZSBncmFwaCBpcyBcInNxdWFyZXJcIiAoaWUuIHdpdGggYSByYXRpbyBjbG9zZXIgdG8gMSksIHdlIG5lZWQgdG8gbWFrZSB0aGUgbGFyZ2VzdCBzaWRlcyB0b3VjaDtcbiAgICAvLyAyLiBJZiB0aGUgc3RhZ2UgaXMgXCJzcXVhcmVyXCIsIHdlIG5lZWQgdG8gbWFrZSB0aGUgc21hbGxlc3Qgc2lkZXMgdG91Y2guXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGdyYXBoUmF0aW8sIDEgLyBncmFwaFJhdGlvKSwgTWF0aC5tYXgoMSAvIHZpZXdwb3J0UmF0aW8sIHZpZXdwb3J0UmF0aW8pKTtcbn1cbmV4cG9ydHMuZ2V0Q29ycmVjdGlvblJhdGlvID0gZ2V0Q29ycmVjdGlvblJhdGlvO1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSBtYXRyaXggZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2FtZXJhLlxuICovXG4vLyBUT0RPOiBpdCdzIHBvc3NpYmxlIHRvIG9wdGltaXplIHRoaXMgZHJhc3RpY2FsbHkhXG5mdW5jdGlvbiBtYXRyaXhGcm9tQ2FtZXJhKHN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZywgaW52ZXJzZSkge1xuICAgIHZhciBhbmdsZSA9IHN0YXRlLmFuZ2xlLCByYXRpbyA9IHN0YXRlLnJhdGlvLCB4ID0gc3RhdGUueCwgeSA9IHN0YXRlLnk7XG4gICAgdmFyIHdpZHRoID0gdmlld3BvcnREaW1lbnNpb25zLndpZHRoLCBoZWlnaHQgPSB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIHZhciBtYXRyaXggPSAoMCwgbWF0cmljZXNfMS5pZGVudGl0eSkoKTtcbiAgICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAtIDIgKiBwYWRkaW5nO1xuICAgIHZhciBjb3JyZWN0aW9uUmF0aW8gPSBnZXRDb3JyZWN0aW9uUmF0aW8odmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMpO1xuICAgIGlmICghaW52ZXJzZSkge1xuICAgICAgICAoMCwgbWF0cmljZXNfMS5tdWx0aXBseSkobWF0cml4LCAoMCwgbWF0cmljZXNfMS5zY2FsZSkoKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCksIDIgKiAoc21hbGxlc3REaW1lbnNpb24gLyB3aWR0aCkgKiBjb3JyZWN0aW9uUmF0aW8sIDIgKiAoc21hbGxlc3REaW1lbnNpb24gLyBoZWlnaHQpICogY29ycmVjdGlvblJhdGlvKSk7XG4gICAgICAgICgwLCBtYXRyaWNlc18xLm11bHRpcGx5KShtYXRyaXgsICgwLCBtYXRyaWNlc18xLnJvdGF0ZSkoKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCksIC1hbmdsZSkpO1xuICAgICAgICAoMCwgbWF0cmljZXNfMS5tdWx0aXBseSkobWF0cml4LCAoMCwgbWF0cmljZXNfMS5zY2FsZSkoKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCksIDEgLyByYXRpbykpO1xuICAgICAgICAoMCwgbWF0cmljZXNfMS5tdWx0aXBseSkobWF0cml4LCAoMCwgbWF0cmljZXNfMS50cmFuc2xhdGUpKCgwLCBtYXRyaWNlc18xLmlkZW50aXR5KSgpLCAteCwgLXkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBtYXRyaWNlc18xLm11bHRpcGx5KShtYXRyaXgsICgwLCBtYXRyaWNlc18xLnRyYW5zbGF0ZSkoKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCksIHgsIHkpKTtcbiAgICAgICAgKDAsIG1hdHJpY2VzXzEubXVsdGlwbHkpKG1hdHJpeCwgKDAsIG1hdHJpY2VzXzEuc2NhbGUpKCgwLCBtYXRyaWNlc18xLmlkZW50aXR5KSgpLCByYXRpbykpO1xuICAgICAgICAoMCwgbWF0cmljZXNfMS5tdWx0aXBseSkobWF0cml4LCAoMCwgbWF0cmljZXNfMS5yb3RhdGUpKCgwLCBtYXRyaWNlc18xLmlkZW50aXR5KSgpLCBhbmdsZSkpO1xuICAgICAgICAoMCwgbWF0cmljZXNfMS5tdWx0aXBseSkobWF0cml4LCAoMCwgbWF0cmljZXNfMS5zY2FsZSkoKDAsIG1hdHJpY2VzXzEuaWRlbnRpdHkpKCksIHdpZHRoIC8gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gY29ycmVjdGlvblJhdGlvLCBoZWlnaHQgLyBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBjb3JyZWN0aW9uUmF0aW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMubWF0cml4RnJvbUNhbWVyYSA9IG1hdHJpeEZyb21DYW1lcmE7XG4vKipcbiAqIEFsbCB0aGVzZSB0cmFuc2Zvcm1hdGlvbnMgd2UgYXBwbHkgb24gdGhlIG1hdHJpeCB0byBnZXQgaXQgcmVzY2FsZSB0aGUgZ3JhcGhcbiAqIGFzIHdlIHdhbnQgbWFrZSBpdCB2ZXJ5IGhhcmQgdG8gZ2V0IHBpeGVsLXBlcmZlY3QgZGlzdGFuY2VzIGluIFdlYkdMLiBUaGlzXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgZmFjdG9yIHRoYXQgcHJvcGVybHkgY2FuY2VscyB0aGUgbWF0cml4IGVmZmVjdCBvbiBsZW5ndGhzLlxuICpcbiAqIFtqYWNvbXlhbF1cbiAqIFRvIGJlIGZ1bGx5IGhvbmVzdCwgSSBjYW4ndCByZWFsbHkgZXhwbGFpbiBoYXBwZW5zIGhlcmUuLi4gSSBub3RpY2UgdGhhdCB0aGVcbiAqIGZvbGxvd2luZyByYXRpbyB3b3JrcyAoaWUuIGl0IGNvcnJlY3RseSBjb21wZW5zYXRlcyB0aGUgbWF0cml4IGltcGFjdCBvbiBhbGxcbiAqIGNhbWVyYSBzdGF0ZXMgSSBjb3VsZCB0cnkpOlxuICogPiBgUiA9IHNpemUoVikgLyBzaXplKE0gKiBWKSAvIFdgXG4gKiBhcyBsb25nIGFzIGBNICogVmAgaXMgaW4gdGhlIGRpcmVjdGlvbiBvZiBXIChpZS4gcGFyYWxsZWwgdG8gKE94KSkuIEl0IHdvcmtzXG4gKiBhcyB3ZWxsIHdpdGggSCBhbmQgYSB2ZWN0b3IgdGhhdCB0cmFuc2Zvcm1zIGludG8gc29tZXRoaW5nIHBhcmFsbGVsIHRvIChPeSkuXG4gKlxuICogQWxzbywgbm90ZSB0aGF0IHdlIHVzZSBgYW5nbGVgIGFuZCBub3QgYC1hbmdsZWAgKHRoYXQgd291bGQgc2VlbSBsb2dpY2FsLFxuICogc2luY2Ugd2Ugd2FudCB0byBhbnRpY2lwYXRlIHRoZSByb3RhdGlvbiksIGJlY2F1c2Ugb2YgdGhlIGZhY3QgdGhhdCBpbiBXZWJHTCxcbiAqIHRoZSBpbWFnZSBpcyB2ZXJ0aWNhbGx5IHN3YXBwZWQuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdHJpeEltcGFjdChtYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpIHtcbiAgICB2YXIgX2EgPSAoMCwgbWF0cmljZXNfMS5tdWx0aXBseVZlYzIpKG1hdHJpeCwgeyB4OiBNYXRoLmNvcyhjYW1lcmFTdGF0ZS5hbmdsZSksIHk6IE1hdGguc2luKGNhbWVyYVN0YXRlLmFuZ2xlKSB9LCAwKSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgIHJldHVybiAxIC8gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpIC8gdmlld3BvcnREaW1lbnNpb25zLndpZHRoO1xufVxuZXhwb3J0cy5nZXRNYXRyaXhJbXBhY3QgPSBnZXRNYXRyaXhJbXBhY3Q7XG4vKipcbiAqIEZ1bmN0aW9uIGV4dHJhY3RpbmcgdGhlIGNvbG9yIGF0IHRoZSBnaXZlbiBwaXhlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFBpeGVsKGdsLCB4LCB5LCBhcnJheSkge1xuICAgIHZhciBkYXRhID0gYXJyYXkgfHwgbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMuZXh0cmFjdFBpeGVsID0gZXh0cmFjdFBpeGVsO1xuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGtub3cgd2hldGhlciBnaXZlbiB3ZWJnbCBjb250ZXh0IGNhbiB1c2UgMzIgYml0cyBpbmRpY2VzLlxuICovXG5mdW5jdGlvbiBjYW5Vc2UzMkJpdHNJbmRpY2VzKGdsKSB7XG4gICAgdmFyIHdlYmdsMiA9IHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICByZXR1cm4gd2ViZ2wyIHx8ICEhZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKTtcbn1cbmV4cG9ydHMuY2FuVXNlMzJCaXRzSW5kaWNlcyA9IGNhblVzZTMyQml0c0luZGljZXM7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBncmFwaCB2YXJpYWJsZSBpcyBhIHZhbGlkIGdyYXBoLCBhbmQgaWYgc2lnbWEgY2FuIHJlbmRlciBpdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVHcmFwaChncmFwaCkge1xuICAgIC8vIGNoZWNrIGlmIGl0J3MgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlXG4gICAgaWYgKCEoMCwgaXNfZ3JhcGhfMS5kZWZhdWx0KShncmFwaCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBpbnZhbGlkIGdyYXBoIGluc3RhbmNlLlwiKTtcbiAgICAvLyBjaGVjayBpZiBub2RlcyBoYXZlIHgveSBhdHRyaWJ1dGVzXG4gICAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhdHRyaWJ1dGVzLngpIHx8ICFOdW1iZXIuaXNGaW5pdGUoYXR0cmlidXRlcy55KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IENvb3JkaW5hdGVzIG9mIG5vZGUgXCIuY29uY2F0KGtleSwgXCIgYXJlIGludmFsaWQuIEEgbm9kZSBtdXN0IGhhdmUgYSBudW1lcmljICd4JyBhbmQgJ3knIGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlR3JhcGggPSB2YWxpZGF0ZUdyYXBoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm11bHRpcGx5VmVjMiA9IGV4cG9ydHMubXVsdGlwbHkgPSBleHBvcnRzLnRyYW5zbGF0ZSA9IGV4cG9ydHMucm90YXRlID0gZXhwb3J0cy5zY2FsZSA9IGV4cG9ydHMuaWRlbnRpdHkgPSB2b2lkIDA7XG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5Lm9mKDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xufVxuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuLy8gVE9ETzogb3B0aW1pemVcbmZ1bmN0aW9uIHNjYWxlKG0sIHgsIHkpIHtcbiAgICBtWzBdID0geDtcbiAgICBtWzRdID0gdHlwZW9mIHkgPT09IFwibnVtYmVyXCIgPyB5IDogeDtcbiAgICByZXR1cm4gbTtcbn1cbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmZ1bmN0aW9uIHJvdGF0ZShtLCByKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyKSwgYyA9IE1hdGguY29zKHIpO1xuICAgIG1bMF0gPSBjO1xuICAgIG1bMV0gPSBzO1xuICAgIG1bM10gPSAtcztcbiAgICBtWzRdID0gYztcbiAgICByZXR1cm4gbTtcbn1cbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZnVuY3Rpb24gdHJhbnNsYXRlKG0sIHgsIHkpIHtcbiAgICBtWzZdID0geDtcbiAgICBtWzddID0geTtcbiAgICByZXR1cm4gbTtcbn1cbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICAgIHZhciBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICAgIHZhciBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuICAgIHZhciBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdO1xuICAgIHZhciBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdO1xuICAgIHZhciBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuICAgIGFbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgYVsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBhWzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICAgIGFbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgYVs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBhWzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICAgIGFbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgYVs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBhWzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZnVuY3Rpb24gbXVsdGlwbHlWZWMyKGEsIGIsIHopIHtcbiAgICBpZiAoeiA9PT0gdm9pZCAwKSB7IHogPSAxOyB9XG4gICAgdmFyIGEwMCA9IGFbMF07XG4gICAgdmFyIGEwMSA9IGFbMV07XG4gICAgdmFyIGExMCA9IGFbM107XG4gICAgdmFyIGExMSA9IGFbNF07XG4gICAgdmFyIGEyMCA9IGFbNl07XG4gICAgdmFyIGEyMSA9IGFbN107XG4gICAgdmFyIGIwID0gYi54O1xuICAgIHZhciBiMSA9IGIueTtcbiAgICByZXR1cm4geyB4OiBiMCAqIGEwMCArIGIxICogYTEwICsgYTIwICogeiwgeTogYjAgKiBhMDEgKyBiMSAqIGExMSArIGEyMSAqIHogfTtcbn1cbmV4cG9ydHMubXVsdGlwbHlWZWMyID0gbXVsdGlwbHlWZWMyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIFJlbmRlcmVyIEFycm93IFByb2dyYW1cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogUHJvZ3JhbSByZW5kZXJpbmcgZGlyZWN0aW9uIGFycm93cyBhcyBhIHNpbXBsZSB0cmlhbmdsZS5cbiAqIEBtb2R1bGVcbiAqXG4gKiBUaGlzIGZpbGUgdGFrZW4gZnJvbSBzaWdtYS5qcy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFjb215YWwvc2lnbWEuanMvYmxvYi9lMTg3YmE1YjU2N2ViMzU5ZjJiNGU0Mzg5ODc3ODVkYTczNjg0NjY3L3NyYy9yZW5kZXJpbmcvd2ViZ2wvcHJvZ3JhbXMvZWRnZS5hcnJvd0hlYWQudHNcbiAqL1xuY29uc3QgZWRnZV9hcnJvd0hlYWRfdmVydF9nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZWRnZS5hcnJvd0hlYWQudmVydC5nbHNsXCIpKTtcbmNvbnN0IGVkZ2VfYXJyb3dIZWFkX2ZyYWdfZ2xzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VkZ2UuYXJyb3dIZWFkLmZyYWcuZ2xzbFwiKSk7XG5jb25zdCBlZGdlXzEgPSByZXF1aXJlKFwic2lnbWEvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2NvbW1vbi9lZGdlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJzaWdtYS91dGlsc1wiKTtcbmNvbnN0IENIT05LSU5FU1MgPSAxLjU7XG5jb25zdCBQT0lOVFMgPSAzLCBBVFRSSUJVVEVTID0gOSwgU1RSSURFID0gUE9JTlRTICogQVRUUklCVVRFUztcbmNsYXNzIENob25reUFycnJvd0hlYWRQcm9ncmFtIGV4dGVuZHMgZWRnZV8xLkFic3RyYWN0RWRnZVByb2dyYW0ge1xuICAgIGNvbnN0cnVjdG9yKGdsKSB7XG4gICAgICAgIHN1cGVyKGdsLCBlZGdlX2Fycm93SGVhZF92ZXJ0X2dsc2xfMS5kZWZhdWx0LCBlZGdlX2Fycm93SGVhZF9mcmFnX2dsc2xfMS5kZWZhdWx0LCBQT0lOVFMsIEFUVFJJQlVURVMpO1xuICAgICAgICAvLyBMb2NhdGlvbnNcbiAgICAgICAgdGhpcy5wb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgICAgIHRoaXMuY29sb3JMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX2NvbG9yXCIpO1xuICAgICAgICB0aGlzLm5vcm1hbExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfbm9ybWFsXCIpO1xuICAgICAgICB0aGlzLnJhZGl1c0xvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcmFkaXVzXCIpO1xuICAgICAgICB0aGlzLmJhcnljZW50cmljTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9iYXJ5Y2VudHJpY1wiKTtcbiAgICAgICAgLy8gVW5pZm9ybSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgbWF0cml4TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfbWF0cml4XCIpO1xuICAgICAgICBpZiAobWF0cml4TG9jYXRpb24gPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFZGdlQXJyb3dIZWFkUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBtYXRyaXhMb2NhdGlvblwiKTtcbiAgICAgICAgdGhpcy5tYXRyaXhMb2NhdGlvbiA9IG1hdHJpeExvY2F0aW9uO1xuICAgICAgICBjb25zdCBzcXJ0Wm9vbVJhdGlvTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfc3FydFpvb21SYXRpb1wiKTtcbiAgICAgICAgaWYgKHNxcnRab29tUmF0aW9Mb2NhdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVkZ2VBcnJvd0hlYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIHNxcnRab29tUmF0aW9Mb2NhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zcXJ0Wm9vbVJhdGlvTG9jYXRpb24gPSBzcXJ0Wm9vbVJhdGlvTG9jYXRpb247XG4gICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiKTtcbiAgICAgICAgaWYgKGNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWRnZUFycm93SGVhZFByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29ycmVjdGlvblJhdGlvTG9jYXRpb25cIik7XG4gICAgICAgIHRoaXMuY29ycmVjdGlvblJhdGlvTG9jYXRpb24gPSBjb3JyZWN0aW9uUmF0aW9Mb2NhdGlvbjtcbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgfVxuICAgIGJpbmQoKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgLy8gQmluZGluZ3NcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5ub3JtYWxMb2NhdGlvbik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucmFkaXVzTG9jYXRpb24pO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmNvbG9yTG9jYXRpb24pO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmJhcnljZW50cmljTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLm5vcm1hbExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIEFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIDgpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmFkaXVzTG9jYXRpb24sIDEsIGdsLkZMT0FULCBmYWxzZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMTYpO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY29sb3JMb2NhdGlvbiwgNCwgZ2wuVU5TSUdORURfQllURSwgdHJ1ZSwgQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMjApO1xuICAgICAgICAvLyBUT0RPOiBtYXliZSB3ZSBjYW4gb3B0aW1pemUgaGVyZSBieSBwYWNraW5nIHRoaXMgaW4gYSBiaXQgbWFza1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYmFyeWNlbnRyaWNMb2NhdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCBBVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAyNCk7XG4gICAgfVxuICAgIGNvbXB1dGVJbmRpY2VzKCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgfVxuICAgIHByb2Nlc3Moc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSwgaGlkZGVuLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGhpZGRlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldCAqIFNUUklERSwgbCA9IGkgKyBTVFJJREU7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVtpXSA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDEsIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxLCB4MSA9IHNvdXJjZURhdGEueCwgeTEgPSBzb3VyY2VEYXRhLnksIHgyID0gdGFyZ2V0RGF0YS54LCB5MiA9IHRhcmdldERhdGEueSwgY29sb3IgPSAoMCwgdXRpbHNfMS5mbG9hdENvbG9yKShkYXRhLmNvbG9yKTtcbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgY29uc3QgZHggPSB4MiAtIHgxLCBkeSA9IHkyIC0geTE7XG4gICAgICAgIGxldCBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeSwgbjEgPSAwLCBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzICogQ0hPTktJTkVTUztcbiAgICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3MgKiBDSE9OS0lORVNTO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gUE9JTlRTICogQVRUUklCVVRFUyAqIG9mZnNldDtcbiAgICAgICAgY29uc3QgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICAvLyBGaXJzdCBwb2ludFxuICAgICAgICBhcnJheVtpKytdID0geDI7XG4gICAgICAgIGFycmF5W2krK10gPSB5MjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IC1uMTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IC1uMjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IHJhZGl1cztcbiAgICAgICAgYXJyYXlbaSsrXSA9IGNvbG9yO1xuICAgICAgICBhcnJheVtpKytdID0gMTtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAwO1xuICAgICAgICAvLyBTZWNvbmQgcG9pbnRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAxO1xuICAgICAgICBhcnJheVtpKytdID0gMDtcbiAgICAgICAgLy8gVGhpcmQgcG9pbnRcbiAgICAgICAgYXJyYXlbaSsrXSA9IHgyO1xuICAgICAgICBhcnJheVtpKytdID0geTI7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjE7XG4gICAgICAgIGFycmF5W2krK10gPSAtbjI7XG4gICAgICAgIGFycmF5W2krK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W2krK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbaSsrXSA9IDA7XG4gICAgICAgIGFycmF5W2krK10gPSAwO1xuICAgICAgICBhcnJheVtpXSA9IDE7XG4gICAgfVxuICAgIHJlbmRlcihwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTm90aGluZ1RvUmVuZGVyKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgLy8gQmluZGluZyB1bmlmb3Jtc1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMubWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHRoaXMuc3FydFpvb21SYXRpb0xvY2F0aW9uLCBNYXRoLnNxcnQocGFyYW1zLnJhdGlvKSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLmNvcnJlY3Rpb25SYXRpb0xvY2F0aW9uLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICAgICAgLy8gRHJhd2luZzpcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHRoaXMuYXJyYXkubGVuZ3RoIC8gQVRUUklCVVRFUyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2hvbmt5QXJycm93SGVhZFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogU2lnbWEuanMgV2ViR0wgUmVuZGVyZXIgRWRnZSBBcnJvdyBQcm9ncmFtXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29tcG91bmQgcHJvZ3JhbSByZW5kZXJpbmcgZWRnZXMgYXMgYW4gYXJyb3cgZnJvbSB0aGUgc291cmNlIHRvIHRoZSB0YXJnZXQuXG4gKiBAbW9kdWxlXG4gKlxuICogVGhpcyBmaWxlIHRha2VuIGZyb20gc2lnbWEuanMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phY29teWFsL3NpZ21hLmpzL2Jsb2IvZTE4N2JhNWI1NjdlYjM1OWYyYjRlNDM4OTg3Nzg1ZGE3MzY4NDY2Ny9zcmMvcmVuZGVyaW5nL3dlYmdsL3Byb2dyYW1zL2VkZ2UuYXJyb3cudHNcbiAqL1xuY29uc3QgZWRnZV8xID0gcmVxdWlyZShcInNpZ21hL3JlbmRlcmluZy93ZWJnbC9wcm9ncmFtcy9jb21tb24vZWRnZVwiKTtcbmNvbnN0IGVkZ2VfYXJyb3dIZWFkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZWRnZS5hcnJvd0hlYWRcIikpO1xuY29uc3QgZWRnZV9jbGFtcGVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNpZ21hL3JlbmRlcmluZy93ZWJnbC9wcm9ncmFtcy9lZGdlLmNsYW1wZWRcIikpO1xuY29uc3QgQ2hvbmt5QXJyb3dQcm9ncmFtID0gKDAsIGVkZ2VfMS5jcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKShbXG4gICAgZWRnZV9jbGFtcGVkXzEuZGVmYXVsdCxcbiAgICBlZGdlX2Fycm93SGVhZF8xLmRlZmF1bHQsXG5dKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENob25reUFycm93UHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZEdyYXBoID0gZXhwb3J0cy5qc29uVGV4dFRvR3JhcGhEZWYgPSB2b2lkIDA7XG5jb25zdCBncmFwaG9sb2d5XzEgPSByZXF1aXJlKFwiZ3JhcGhvbG9neVwiKTtcbmNvbnN0IGdyYXBob2xvZ3lfbGF5b3V0XzEgPSByZXF1aXJlKFwiZ3JhcGhvbG9neS1sYXlvdXRcIik7XG5jb25zdCBncmFwaG9sb2d5X2xheW91dF9mb3JjZWF0bGFzMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJncmFwaG9sb2d5LWxheW91dC1mb3JjZWF0bGFzMlwiKSk7XG5mdW5jdGlvbiBqc29uVGV4dFRvR3JhcGhEZWYodGV4dCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChvYmosIGZpZWxkTmFtZSwgY2hlY2ssIHJlcXVpcmVkID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAob2JqW2ZpZWxkTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7ZmllbGROYW1lfVwiIGlzIG1pc3NpbmcsIGhhdmUgJHtKU09OLnN0cmluZ2lmeShvYmopfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gY2hlY2sob2JqW2ZpZWxkTmFtZV0pO1xuICAgICAgICBpZiAoY2hlY2tSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgZmllbGQgJHtmaWVsZE5hbWV9IGZhaWxzIHR5cGUgY2hlY2tgO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1N0cmluZyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbiAgICBjb25zdCBpc051bWJlciA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcbiAgICBjb25zdCBpc09iamVjdCA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIjtcbiAgICBjaGVja0ZpZWxkKHBhcnNlZCwgXCJ0aXRsZVwiLCBpc1N0cmluZywgZmFsc2UpO1xuICAgIGNoZWNrRmllbGQocGFyc2VkLCBcIm5vZGVzXCIsICh2KSA9PiBpc09iamVjdCh2KSAmJlxuICAgICAgICBPYmplY3QuZW50cmllcyh2KS5ldmVyeSgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGspKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tGaWVsZCh2LCBcInByb3BzXCIsIGlzT2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICBjaGVja0ZpZWxkKHYsIFwiY29sb3JcIiwgaXNTdHJpbmcsIGZhbHNlKTtcbiAgICAgICAgICAgIGNoZWNrRmllbGQodiwgXCJsYWJlbFwiLCBpc1N0cmluZywgZmFsc2UpO1xuICAgICAgICAgICAgY2hlY2tGaWVsZCh2LCBcIndlaWdodFwiLCBpc051bWJlciwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pKTtcbiAgICBjaGVja0ZpZWxkKHBhcnNlZCwgXCJlZGdlc1wiLCAoZWRnZXMpID0+IEFycmF5LmlzQXJyYXkoZWRnZXMpICYmXG4gICAgICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIGNoZWNrRmllbGQoZWRnZSwgXCJ0b1wiLCBpc1N0cmluZyk7XG4gICAgICAgICAgICBjaGVja0ZpZWxkKGVkZ2UsIFwiZnJvbVwiLCBpc1N0cmluZyk7XG4gICAgICAgIH0pKTtcbiAgICByZXR1cm4gcGFyc2VkO1xufVxuZXhwb3J0cy5qc29uVGV4dFRvR3JhcGhEZWYgPSBqc29uVGV4dFRvR3JhcGhEZWY7XG5mdW5jdGlvbiBidWlsZEdyYXBoKGRlZikge1xuICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBob2xvZ3lfMS5EaXJlY3RlZEdyYXBoKCk7XG4gICAgT2JqZWN0LmVudHJpZXMoZGVmLm5vZGVzKS5mb3JFYWNoKChbaWQsIG5vZGVdKSA9PiBncmFwaC5hZGROb2RlKGlkLCB7XG4gICAgICAgIG5vZGVEZWY6IG5vZGUsXG4gICAgICAgIGNvbG9yOiBub2RlLmNvbG9yLFxuICAgICAgICBsYWJlbDogbm9kZS5sYWJlbCB8fCBpZCxcbiAgICB9KSk7XG4gICAgY29uc3QgY3JlYXRlTm9kZUlmTm90RXhpc3RzID0gKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFncmFwaC5oYXNOb2RlKG5hbWUpKSB7XG4gICAgICAgICAgICBncmFwaC5hZGROb2RlKG5hbWUsIHsgbGFiZWw6IG5hbWUsIG5vZGVEZWY6IHt9IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWYuZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBsZXQgYW1vdW50TnVtID0gcGFyc2VGbG9hdChlZGdlLmFtb3VudCB8fCBcIjFcIik7XG4gICAgICAgIGlmIChpc05hTihhbW91bnROdW0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYGFtb3VudCBvbiBlZGdlICR7ZWRnZS5mcm9tfSAtPiAke2VkZ2UudG99IFwiJHtlZGdlLmFtb3VudH1cIiBpcyB1bnBhcnNlYWJsZWApO1xuICAgICAgICAgICAgYW1vdW50TnVtID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVOb2RlSWZOb3RFeGlzdHMoZWRnZS5mcm9tKTtcbiAgICAgICAgY3JlYXRlTm9kZUlmTm90RXhpc3RzKGVkZ2UudG8pO1xuICAgICAgICBncmFwaC5hZGRFZGdlKGVkZ2UuZnJvbSwgZWRnZS50bywge1xuICAgICAgICAgICAgbGFiZWw6IGVkZ2UubGFiZWwgfHwgZWRnZS5hbW91bnQsXG4gICAgICAgICAgICB3ZWlnaHQ6IGFtb3VudE51bSxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIixcbiAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IG1pblNpemUgPSA1LCBtYXhTaXplID0gMjU7XG4gICAgY29uc3Qgc2l6ZXMgPSBncmFwaFxuICAgICAgICAubWFwTm9kZXMoKG5vZGUpID0+IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGUobm9kZSwgXCJub2RlRGVmXCIpLndlaWdodClcbiAgICAgICAgLmZpbHRlcigobikgPT4gbiAhPSBudWxsKTtcbiAgICBjb25zdCBtaW5FeHBsaWNpdE5vZGVTaXplID0gTWF0aC5taW4oLi4uc2l6ZXMpO1xuICAgIGNvbnN0IG1heEV4cGxpY2l0Tm9kZVNpemUgPSBNYXRoLm1heCguLi5zaXplcyk7XG4gICAgY29uc29sZS5sb2cobWluRXhwbGljaXROb2RlU2l6ZSwgbWF4RXhwbGljaXROb2RlU2l6ZSk7XG4gICAgLy8gVXNlIHRvdGFsIGVkZ2Ugd2VpZ2h0cyBmb3Igbm9kZSBzaXplXG4gICAgY29uc3QgdG90YWxUcmFuc2ZlcnNCeU5vZGUgPSBncmFwaFxuICAgICAgICAubm9kZXMoKVxuICAgICAgICAubWFwKChub2RlKSA9PiBncmFwaC5yZWR1Y2VFZGdlcyhub2RlLCAoYWNjLCBfZWRnZSwgZWRnZUF0dHJzKSA9PiBhY2MgKyBlZGdlQXR0cnMud2VpZ2h0LCAwKSk7XG4gICAgY29uc3QgbWluWGZlcnMgPSBNYXRoLm1pbiguLi50b3RhbFRyYW5zZmVyc0J5Tm9kZSk7XG4gICAgY29uc3QgbWF4WGZlcnMgPSBNYXRoLm1heCguLi50b3RhbFRyYW5zZmVyc0J5Tm9kZSk7XG4gICAgY29uc3Qgc2NhbGVkU2l6ZUZvciA9ICh0cmFuc2ZlckFtb3VudCkgPT4gbWluU2l6ZSArXG4gICAgICAgICgodHJhbnNmZXJBbW91bnQgLSBtaW5YZmVycykgLyAobWF4WGZlcnMgLSBtaW5YZmVycykpICpcbiAgICAgICAgICAgIChtYXhTaXplIC0gbWluU2l6ZSk7XG4gICAgY29uc3Qgc2NhbGVkRXhwbGljaXRTaXplRm9yID0gKHNpemUpID0+IG1pblNpemUgK1xuICAgICAgICAoKHNpemUgLSBtaW5FeHBsaWNpdE5vZGVTaXplKSAvXG4gICAgICAgICAgICAobWF4RXhwbGljaXROb2RlU2l6ZSAtIG1pbkV4cGxpY2l0Tm9kZVNpemUpKSAqXG4gICAgICAgICAgICAobWF4U2l6ZSAtIG1pblNpemUpO1xuICAgIGdyYXBoLmZvckVhY2hOb2RlKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsVHJhbnNmZXJzID0gZ3JhcGgucmVkdWNlRWRnZXMobm9kZSwgKGFjYywgX2VkZ2UsIGVkZ2VBdHRycykgPT4gYWNjICsgZWRnZUF0dHJzLndlaWdodCwgMCk7XG4gICAgICAgIGNvbnN0IG5vZGVBdHRycyA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNpemUgPSBub2RlQXR0cnMubm9kZURlZi53ZWlnaHQgIT0gbnVsbFxuICAgICAgICAgICAgPyBzY2FsZWRFeHBsaWNpdFNpemVGb3Iobm9kZUF0dHJzLm5vZGVEZWYud2VpZ2h0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBncmFwaC5zZXROb2RlQXR0cmlidXRlKG5vZGUsIFwic2l6ZVwiLCBleHBsaWNpdFNpemUgPz8gc2NhbGVkU2l6ZUZvcih0b3RhbFRyYW5zZmVycykpO1xuICAgIH0pO1xuICAgIC8vIFBvc2l0aW9uIG5vZGVzIG9uIGEgY2lyY2xlLCB0aGVuIHJ1biBGb3JjZSBBdGxhcyAyIGZvciBhIHdoaWxlIHRvIGdldFxuICAgIC8vIHByb3BlciBncmFwaCBsYXlvdXQ6XG4gICAgZ3JhcGhvbG9neV9sYXlvdXRfMS5jaXJjdWxhci5hc3NpZ24oZ3JhcGgpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZ3JhcGhvbG9neV9sYXlvdXRfZm9yY2VhdGxhczJfMS5kZWZhdWx0LmluZmVyU2V0dGluZ3MoZ3JhcGgpO1xuICAgIGdyYXBob2xvZ3lfbGF5b3V0X2ZvcmNlYXRsYXMyXzEuZGVmYXVsdC5hc3NpZ24oZ3JhcGgsIHsgc2V0dGluZ3MsIGl0ZXJhdGlvbnM6IDYwMCB9KTtcbiAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgZ2xvYmFsVGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHJldHVybiBncmFwaDtcbn1cbmV4cG9ydHMuYnVpbGRHcmFwaCA9IGJ1aWxkR3JhcGg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmlldyA9IGV4cG9ydHMuU2lnbWFHcmFwaFZpZXcgPSBleHBvcnRzLlRhYmxlTm9kZURhdGFWaWV3ID0gdm9pZCAwO1xuY29uc3Qgc2lnbWFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2lnbWFcIikpO1xuY29uc3QgY2hvbmt5QXJyb3dzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY2hvbmt5QXJyb3dzXCIpKTtcbi8vIEZJWE1FOiB0aGlzIG1pZ2h0IGJlIGdvb2QgdG8gcmVwbGFjZSB3aXRoIHJlYWN0IGFuZCBUU1guIHRoZSBzdG9jayBET01cbi8vIHN0dWZmIHN1Y2tzXG5jbGFzcyBUYWJsZU5vZGVEYXRhVmlldyB7XG4gICAgY29uc3RydWN0b3IoZWxlbSkge1xuICAgICAgICB0aGlzLnRhYmxlID0gZWxlbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZS10YWJsZV1cIik7XG4gICAgICAgIHRoaXMubmFtZUVsZW0gPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlLW5hbWVdXCIpO1xuICAgIH1cbiAgICByZW5kZXJQcm9wZXJ0eShpbnRvRWwsIGlkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBTUEVDSUFMUyA9IHtcbiAgICAgICAgICAgIGdvb2dsZVNlYXJjaDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgIGFuY2hvci5ocmVmID0gYGh0dHBzOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgICAgICAgICAgICAgICBhbmNob3IudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpbnRvRWwuYXBwZW5kQ2hpbGQoYW5jaG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpbnRvRWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gWFhYOiB0eXBlIGNyaW1lcz9cbiAgICAgICAgY29uc3QgcmVuZGVyRnVuYyA9IFNQRUNJQUxTW2lkXSB8fCBkZWZhdWx0UmVuZGVyO1xuICAgICAgICByZW5kZXJGdW5jKCk7XG4gICAgfVxuICAgIG9uTm9kZVNlbGVjdGVkKG5vZGVJZCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcy50YWJsZS50Qm9kaWVzWzBdKVxuICAgICAgICAgICAgdGhpcy50YWJsZS50Qm9kaWVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm5hbWVFbGVtLnRleHRDb250ZW50ID0gbm9kZS5sYWJlbCB8fCBub2RlSWQ7XG4gICAgICAgIGNvbnN0IHRib2R5ID0gdGhpcy50YWJsZS5jcmVhdGVUQm9keSgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtwcm9wLCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUucHJvcHMgfHwge30pKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XG4gICAgICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAgICAgbmFtZUVsLnRleHRDb250ZW50ID0gcHJvcDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvcGVydHkodmFsdWVFbCwgcHJvcCwgdmFsKTtcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChuYW1lRWwpO1xuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlRWwpO1xuICAgICAgICAgICAgdGJvZHkuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGFibGVOb2RlRGF0YVZpZXcgPSBUYWJsZU5vZGVEYXRhVmlldztcbmNsYXNzIFNpZ21hR3JhcGhWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzaWdtYSkge1xuICAgICAgICB0aGlzLm9uTm9kZVNlbGVjdGVkID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXRlID0geyBob3ZlcmVkTm9kZTogbnVsbCwgaGlnaGxpZ2h0Tm9kZXM6IG51bGwgfTtcbiAgICAgICAgdGhpcy5zaWdtYSA9IHNpZ21hO1xuICAgICAgICB0aGlzLm5vZGVSZWR1Y2VyID0gdGhpcy5ub2RlUmVkdWNlci5iaW5kKHRoaXMpO1xuICAgICAgICBzaWdtYS5zZXRTZXR0aW5nKFwibm9kZVJlZHVjZXJcIiwgdGhpcy5ub2RlUmVkdWNlcik7XG4gICAgICAgIHNpZ21hLmFkZExpc3RlbmVyKFwiY2xpY2tOb2RlXCIsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncmFwaCA9IHNpZ21hLmdldEdyYXBoKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlRGVmID0gZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZShwYXlsb2FkLm5vZGUsIFwibm9kZURlZlwiKTtcbiAgICAgICAgICAgIHRoaXMub25Ob2RlU2VsZWN0ZWQocGF5bG9hZC5ub2RlLCBub2RlRGVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ21hLmFkZExpc3RlbmVyKFwiZW50ZXJOb2RlXCIsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkTm9kZSA9IHBheWxvYWQubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoID0gdGhpcy5zaWdtYS5nZXRHcmFwaCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oaWdobGlnaHROb2RlcyA9IG5ldyBTZXQoZ3JhcGgubmVpZ2hib3JzKGhvdmVyZWROb2RlKSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhvdmVyZWROb2RlID0gaG92ZXJlZE5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWdtYS5hZGRMaXN0ZW5lcihcImxlYXZlTm9kZVwiLCAoX3BheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oaWdobGlnaHROb2RlcyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub2RlUmVkdWNlcihub2RlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHsgLi4uZGF0YSB9O1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5zdGF0ZS5ob3ZlcmVkTm9kZSkge1xuICAgICAgICAgICAgcmVzLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaWdobGlnaHROb2RlcyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ob3ZlcmVkTm9kZSAhPT0gbm9kZSAmJlxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuaGlnaGxpZ2h0Tm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICByZXMuY29sb3IgPSBcIiNlZWVcIjtcbiAgICAgICAgICAgIHJlcy5sYWJlbCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAga2lsbCgpIHtcbiAgICAgICAgdGhpcy5zaWdtYS5raWxsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaWdtYUdyYXBoVmlldyA9IFNpZ21hR3JhcGhWaWV3O1xuY2xhc3MgVmlldyB7XG4gICAgY29uc3RydWN0b3IoZ3JhcGgsIGdyYXBoQ29udGFpbmVyLCBwcm9wc0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLm5vZGVEYXRhVmlldyA9IG5ldyBUYWJsZU5vZGVEYXRhVmlldyhwcm9wc0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuc2lnbWFHcmFwaFZpZXcgPSBuZXcgU2lnbWFHcmFwaFZpZXcobmV3IHNpZ21hXzEuZGVmYXVsdChncmFwaCwgZ3JhcGhDb250YWluZXIsIHtcbiAgICAgICAgICAgIHJlbmRlckVkZ2VMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICBlZGdlUHJvZ3JhbUNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICBhcnJvdzogY2hvbmt5QXJyb3dzXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zaWdtYUdyYXBoVmlldy5vbk5vZGVTZWxlY3RlZCA9IChub2RlSWQsIG5vZGUpID0+IHRoaXMubm9kZURhdGFWaWV3Lm9uTm9kZVNlbGVjdGVkKG5vZGVJZCwgbm9kZSk7XG4gICAgfVxuICAgIGtpbGwoKSB7XG4gICAgICAgIHRoaXMuc2lnbWFHcmFwaFZpZXcua2lsbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmlldyA9IFZpZXc7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpbmdlc3RfMSA9IHJlcXVpcmUoXCIuL2luZ2VzdFwiKTtcbmNvbnN0IHJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9yZW5kZXJlclwiKTtcbmZ1bmN0aW9uIHN0YXJ0dXAoKSB7XG4gICAgY29uc3QgdGV4dENvbnRyb2wgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhc3RlLWpzb25cIik7XG4gICAgbGV0IG15VmlldztcbiAgICBjb25zdCBncmFwaENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2lnbWEtY29udGFpbmVyXCIpO1xuICAgIGNvbnN0IGxvYWRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctaW5kaWNhdGlvblwiKTtcbiAgICBjb25zdCBmYWlsdXJlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFpbHVyZXNcIik7XG4gICAgY29uc3Qgbm9kZURhdGFWaWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9wZXJ0aWVzLXRhYmxlXCIpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG9uQWNjZXB0VGV4dCh0ZXh0KSB7XG4gICAgICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkxvYWQodGV4dCksIDApO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBvbkxvYWQoY29udGVudCwgdGl0bGUpIHtcbiAgICAgICAgaWYgKG15Vmlldykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJraWxsXCIpO1xuICAgICAgICAgICAgbXlWaWV3LmtpbGwoKTtcbiAgICAgICAgICAgIG15VmlldyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZG9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ3JhcGhEZWY7XG4gICAgICAgIGxldCBncmFwaDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdyYXBoRGVmID0gKDAsIGluZ2VzdF8xLmpzb25UZXh0VG9HcmFwaERlZikoY29udGVudCk7XG4gICAgICAgICAgICBncmFwaCA9ICgwLCBpbmdlc3RfMS5idWlsZEdyYXBoKShncmFwaERlZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZhaWx1cmVzLnRleHRDb250ZW50ID0gYEZhaWxlZCB0byBwYXJzZSBKU09OLCB0cnkgY29weWluZyBpdCBhZ2FpbjogJHtlLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZmFpbHVyZXMudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICBkb2N1bWVudC50aXRsZSA9IGAke2dyYXBoRGVmLnRpdGxlIHx8IHRpdGxlIHx8IFwidW50aXRsZWRcIn0gLSBMb29raW5nIEdsYXNzIPCflI5gO1xuICAgICAgICBteVZpZXcgPSBuZXcgcmVuZGVyZXJfMS5WaWV3KGdyYXBoLCBncmFwaENvbnRhaW5lciwgbm9kZURhdGFWaWV3KTtcbiAgICB9XG4gICAgdGV4dENvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIChldikgPT4ge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gZXYuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDbGlwYm9hcmQgZGF0YSBpcyBudWxsP1wiO1xuICAgICAgICB9XG4gICAgICAgIG9uQWNjZXB0VGV4dChkYXRhKTtcbiAgICB9KTtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQganNvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBhd2FpdCAoYXdhaXQgZmV0Y2goXCJwcmVsb2FkZWQtZGF0YS5qc29uXCIpKS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICA7XG4gICAgICAgIGpzb24gPT09IHVuZGVmaW5lZCB8fCBvbkFjY2VwdFRleHQoanNvbik7XG4gICAgfSkoKTtcbn1cbnN0YXJ0dXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==